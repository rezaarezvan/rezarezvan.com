<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Concurrent Programming: Part 10 - Parallel linked lists - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In this part we&rsquo;ll cover the synchronization challenges that arise when designing (correct) and efficient parallelizations.
But let&rsquo;s first see the burdens with locks
The trouble with locks Standard techniques for concurrent programming are ultimately based on locks.
Programming with locks has several drawbacks:
Performance overhead.
Lock granularity is hard to choose:
Not enough locking: race conditions.
Too much locking: not enough parallelism.
Risk of deadlock and starvation.
Lock-based implementations do not compose (easily)." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="Concurrent Programming: Part 10 - Parallel linked lists" />
<meta property="og:description" content="In this part we&rsquo;ll cover the synchronization challenges that arise when designing (correct) and efficient parallelizations.
But let&rsquo;s first see the burdens with locks
The trouble with locks Standard techniques for concurrent programming are ultimately based on locks.
Programming with locks has several drawbacks:
Performance overhead.
Lock granularity is hard to choose:
Not enough locking: race conditions.
Too much locking: not enough parallelism.
Risk of deadlock and starvation.
Lock-based implementations do not compose (easily)." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/Concurrent_programming_10/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2023-02-19T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-02-19T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Concurrent Programming: Part 10 - Parallel linked lists"/>
<meta name="twitter:description" content="In this part we&rsquo;ll cover the synchronization challenges that arise when designing (correct) and efficient parallelizations.
But let&rsquo;s first see the burdens with locks
The trouble with locks Standard techniques for concurrent programming are ultimately based on locks.
Programming with locks has several drawbacks:
Performance overhead.
Lock granularity is hard to choose:
Not enough locking: race conditions.
Too much locking: not enough parallelism.
Risk of deadlock and starvation.
Lock-based implementations do not compose (easily)."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Concurrent Programming: Part 10 - Parallel linked lists</h1>
			<div class="meta">Posted on Feb 19, 2023</div>
		</div>
		

		<section class="body">
			<p>In this part we&rsquo;ll cover the <em>synchronization challenges</em> that arise when designing (correct) and efficient parallelizations.</p>
<p>But let&rsquo;s first see the burdens with locks</p>
<h3 id="the-trouble-with-locks">The trouble with locks</h3>
<p>Standard techniques for concurrent programming are ultimately based on locks.</p>
<p>Programming with locks has several drawbacks:</p>
<ul>
<li>
<p>Performance overhead.</p>
</li>
<li>
<p>Lock granularity is hard to choose:</p>
<ul>
<li>
<p>Not enough locking: race conditions.</p>
</li>
<li>
<p>Too much locking: not enough parallelism.</p>
</li>
</ul>
</li>
<li>
<p>Risk of deadlock and starvation.</p>
</li>
<li>
<p>Lock-based implementations do not compose (easily).</p>
</li>
<li>
<p>Lock-based programs are hard to maintain and modify.</p>
</li>
</ul>
<p>Message-passing programming is higher-level, but it also inevitably incurs on
synchronization costs â€“ of magnitude comparable to those associated with locks.</p>
<p>A good rule of thumb is:</p>
<ul>
<li>
<p>Lock-based programming is <em>pessimistic</em>: be prepared for the worst possible conditions:</p>
<ul>
<li>If things can go wrong, they will.</li>
</ul>
</li>
<li>
<p>Lock-free programming is <em>optimistic</em>: do what you have to do without worrying about race conditions:</p>
<ul>
<li>If things go wrong, just try again!</li>
</ul>
</li>
</ul>
<p>Ultimately, what Lock-free programming relies on is:</p>
<ul>
<li>
<p>Using stronger primitives for atomic access.</p>
</li>
<li>
<p>Building optimistic algorithms using those primitives.</p>
</li>
</ul>
<p>For example, remember the <code>compare-and-set</code> and <code>test-and-set</code> methods we have encountered.</p>
<p>Even if these are not &lsquo;free&rsquo;, these operations also take time and performance.</p>
<p>There are two different classes of lock-free algorithms:</p>
<ul>
<li>
<p>Lock-free: guarantee <em>system-wide</em> progress: infinitely often, some process makes progress.</p>
</li>
<li>
<p>Wait-free: guarantee <em>per-process</em> progress: every process eventually makes progress.</p>
</li>
</ul>
<p>Wait-free is stronger than lock-free:</p>
<ul>
<li>Lock-free algorithms are free from deadlock.</li>
<li>Wait-free algorithms are free from deadlock <em>and starvation</em>.</li>
</ul>
<p>Let&rsquo;s see how we can parallelize linked lists!</p>
<p>But before that, let&rsquo;s quickly just have our linked list defined:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class SequentialNode&lt;T&gt; implements Node&lt;T&gt; {
</span></span><span style="display:flex;"><span>    // Value stored in node
</span></span><span style="display:flex;"><span>    private T item;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Hash code of item
</span></span><span style="display:flex;"><span>    private int key;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Next node in chain
</span></span><span style="display:flex;"><span>    private Node&lt;T&gt; next;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    T item() { return item; }
</span></span><span style="display:flex;"><span>    int key() { return key; }
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; next() { return next; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void setItem(T item) { this.item = item; }
</span></span><span style="display:flex;"><span>    void setKey(int key) { this.key = key; }
</span></span><span style="display:flex;"><span>    void setNext(Node&lt;T&gt; next) { this.next = next; }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    protected Node&lt;T&gt;, Node&lt;T&gt; find(Node&lt;T&gt; start, int key) {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        curr = start;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        do {
</span></span><span style="display:flex;"><span>            pred = curr; curr = curr.next();
</span></span><span style="display:flex;"><span>        } while (curr.key() &lt; key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return (pred,curr);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean has(T item) {
</span></span><span style="display:flex;"><span>        int key = item.key();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Find position of key from head:
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, key);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return curr.key() == key;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean add(T item) {
</span></span><span style="display:flex;"><span>        // New node to be added
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; node = new Node&lt;&gt;(item);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // curr.key &gt;= item.key()
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (curr.key() == item.key()) {
</span></span><span style="display:flex;"><span>            return false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        else {
</span></span><span style="display:flex;"><span>            node.setNext(curr);
</span></span><span style="display:flex;"><span>            pred.setNext(node);
</span></span><span style="display:flex;"><span>            return true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean remove(T item) {
</span></span><span style="display:flex;"><span>        // curr.key() &gt;= item.key()
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (curr.key() &gt; item.key()) {
</span></span><span style="display:flex;"><span>            return false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        else {
</span></span><span style="display:flex;"><span>            pred.setNext(curr.next());
</span></span><span style="display:flex;"><span>            return true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><h3 id="coarse-grained-locking">Coarse grained locking</h3>
<p>The simple idea is to lock every method.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class CoarseSet&lt;T&gt; extends SequentialSet&lt;T&gt; {
</span></span><span style="display:flex;"><span>    // Lock controlling access to the whole set
</span></span><span style="display:flex;"><span>    private Lock lock = new ReentrantLock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean add(T item) {
</span></span><span style="display:flex;"><span>        lock.lock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            // Execute â€˜addâ€™ while locking
</span></span><span style="display:flex;"><span>            return super.add(item);
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            // Done: release lock
</span></span><span style="display:flex;"><span>            lock.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean remove(T item) {
</span></span><span style="display:flex;"><span>        lock.lock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            // Execute â€˜removeâ€™ while locking
</span></span><span style="display:flex;"><span>            return super.remove(item);
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            // Done: release lock
</span></span><span style="display:flex;"><span>            lock.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public boolean has(T item) {
</span></span><span style="display:flex;"><span>        lock.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            // Execute â€˜hasâ€™ while locking
</span></span><span style="display:flex;"><span>            return super.has(item);
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            // Done: release lock
</span></span><span style="display:flex;"><span>            lock.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now this is a <strong>very</strong> naive approach - but let&rsquo;s list the pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Obviously correct â€“ avoids race conditions and deadlocks.</p>
</li>
<li>
<p>If the lock is fair, so is access to the list.</p>
</li>
<li>
<p>If contention is low (not many threads accessing the set concurrently), <code>CoarseSet</code> is quite efficient.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>Access to the list is sequential â€“ missing opportunities for parallelization.</p>
</li>
<li>
<p>If contention is high (many threads accessing the set concurrently), <code>CoarseSet</code> is quite slow.</p>
</li>
</ul>
</li>
</ul>
<p>Now let&rsquo;s look at <code>CoarseSet</code> predecessor</p>
<h3 id="fine-grained-locking">Fine-grained locking</h3>
<p>The idea here is, instead of locking the whole list when doing operations, we just lock that specific node(s).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class FineSet&lt;T&gt; extends SequentialSet&lt;T&gt; {
</span></span><span style="display:flex;"><span>    public FineSet() {
</span></span><span style="display:flex;"><span>        // Smallest key
</span></span><span style="display:flex;"><span>        head = new LockableNode&lt;&gt;(Integer.MIN _ VALUE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Largest key
</span></span><span style="display:flex;"><span>        tail = new LockableNode&lt;&gt;(Integer.MAX _ VALUE);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        head.setNext(tail);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Since each node is lockable:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class LockableNode&lt;T&gt; extends SequentialNode&lt;T&gt; {
</span></span><span style="display:flex;"><span>    private Lock lock = new ReentrantLock();
</span></span><span style="display:flex;"><span>        void lock() { lock.lock(); }
</span></span><span style="display:flex;"><span>        void unlock() { lock.unlock(); }
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now let&rsquo;s see the implementations of each operation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Find while locking pred and curr, return locked position
</span></span><span style="display:flex;"><span>protected Node&lt;T&gt;, Node&lt;T&gt; find(Node&lt;T&gt; start, int key) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; pred, curr;
</span></span><span style="display:flex;"><span>    pred = start; curr = start.next();
</span></span><span style="display:flex;"><span>    pred.lock(); curr.lock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while (curr.key &lt; key) {
</span></span><span style="display:flex;"><span>        // Unlock pred node
</span></span><span style="display:flex;"><span>        pred.unlock();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Move to next node
</span></span><span style="display:flex;"><span>        pred = curr; curr = curr.next();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        // Lock next node
</span></span><span style="display:flex;"><span>        curr.lock();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return (pred, curr);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean add(T item) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; node = new LockableNode&lt;&gt;(item);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    try {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        // Add node as in SequentialSet, while locking
</span></span><span style="display:flex;"><span>    } finally {
</span></span><span style="display:flex;"><span>        pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean remove(T item) {
</span></span><span style="display:flex;"><span>    try {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        // Remove node as in SequentialSet, while locking
</span></span><span style="display:flex;"><span>    } finally {
</span></span><span style="display:flex;"><span>        pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean has(T item) {
</span></span><span style="display:flex;"><span>    try {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        // Check node as in SequentialSet, while locking
</span></span><span style="display:flex;"><span>    } finally {
</span></span><span style="display:flex;"><span>        pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>As we see, it&rsquo;s all about the <code>find</code> operation.</p>
<p>Pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>If locks are fair, so is access to the list, because threads proceed along the list one
after the other without changing order.</p>
</li>
<li>
<p>Threads operating on disjoint portions of the list may be able to operate in parallel.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>It is still possible that one thread prevents another thread from operating in parallel on
a disjoint portion of the list â€“ for example, if one thread wants to access the end of the
list but, another thread blocks it while locking the beginning of the list.</p>
</li>
<li>
<p>The hand-over-hand locking protocol may be quite slow, as it involves a significant
number of lock operations.</p>
</li>
</ul>
</li>
</ul>
<h3 id="optimistic-locking">Optimistic locking</h3>
<p>Let&rsquo;s try to implement <code>find</code> without using locks. The idea is to <em>validate</em>
a position <em>after finding it</em>, there is some implementation detail about the nodes,
for example we need to make sure we have the <code>volatile</code> keyword for the <code>next</code> attribute in a node.</p>
<p>But that is besides the point, let&rsquo;s take an overview of how the operations should work:</p>
<ol>
<li>
<p>Find the itemâ€™s position inside the list without locking.</p>
</li>
<li>
<p>Lock the positionâ€™s nodes <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>Validate the position while the nodes are locked:</p>
<ul>
<li>
<p>3.1 If the position is <strong>valid</strong>, perform the operation while the nodes are locked, then
release locks.</p>
</li>
<li>
<p>3.2 If the position is <strong>invalid</strong>, release locks and repeat the operation from <strong>scratch</strong>.</p>
</li>
</ul>
</li>
</ol>
<p>This approach is optimistic because it works well when validation is often successful
(so we donâ€™t have to repeat operations).</p>
<p>Now let&rsquo;s implement these operations:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>// Find as in SequentialSet find
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean add(T item) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; node = new ReadWriteNode&lt;&gt;(item);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        pred.lock(); curr.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            if (valid(pred, curr)) {
</span></span><span style="display:flex;"><span>                // Physically add node
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean remove(T item) {
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        pred.lock(); curr.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            if (valid(pred, curr)) {
</span></span><span style="display:flex;"><span>                // Physically remove node
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>    // If not valid: try again!
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean has(T item) {
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        pred.lock(); curr.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            if (valid(pred, curr)) {
</span></span><span style="display:flex;"><span>                return curr.key() == item.key();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>    // If not valid: try again!
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>protected boolean valid(Node&lt;T&gt; pred, Node&lt;T&gt; curr) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; node = head;
</span></span><span style="display:flex;"><span>    while (node.key() &lt;= pred.key()) {
</span></span><span style="display:flex;"><span>        if (node == pred) {
</span></span><span style="display:flex;"><span>            return pred.next() == curr;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        node = node.next();
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return false;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Threads operating on disjoint portions of the list can operate in parallel.</p>
</li>
<li>
<p>When validation often succeeds, there is much less locking involved than in <code>FineSet</code>.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p><code>OptimisticSet</code> is not starvation free; A thread, $t$, may fail validation forever
if other threads keep removing and adding <code>pred</code> / <code>curr</code> between when $t$ performs
<code>find</code> and when it locks <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>If traversing the list twice without locking is not significantly faster than traversing it
once with locking, <code>OptimisticSet</code> does not have a clear advantage over <code>FineSet</code>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="lazy-node-removal">Lazy node removal</h3>
<p>This is the idea that, we need a way to atomically share the information that a node is being removed, but
without locking.</p>
<p>To this end, each node includes a flag <code>valid</code> with setters and getters.</p>
<p>Which means:</p>
<ul>
<li>
<p>Validation only needs to check the mark <code>valid</code>.</p>
</li>
<li>
<p>Operation <code>remove</code> marks a node invalid before removing it.</p>
</li>
<li>
<p>Operation <code>has</code> is lock-free.</p>
</li>
<li>
<p>Operation <code>add</code> works as in <code>OptimisticSet</code>.</p>
</li>
</ul>
<p>Let&rsquo;s start with the implementation:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class LazySet&lt;T&gt; extends OptimisticSet&lt;T&gt; {
</span></span><span style="display:flex;"><span>    public LazySet() {
</span></span><span style="display:flex;"><span>        head = new ValidatedNode&lt;&gt;(Integer.MIN_VALUE);
</span></span><span style="display:flex;"><span>        tail = new ValidatedNode&lt;&gt;(Integer.MAX_VALUE);
</span></span><span style="display:flex;"><span>        head.setNext(tail);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>protected boolean valid(Node&lt;T&gt; pred, Node&lt;T&gt; curr) {
</span></span><span style="display:flex;"><span>    return pred.valid() &amp;&amp; curr.valid() &amp;&amp; pred.next() == curr;
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean has(T item) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>    return curr.valid() &amp;&amp; curr.key() == item.key();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean remove(T item) {
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        pred.lock(); curr.lock();
</span></span><span style="display:flex;"><span>        try {
</span></span><span style="display:flex;"><span>            if (valid(pred, curr)) {
</span></span><span style="display:flex;"><span>                if (curr.key() != item.key()) {
</span></span><span style="display:flex;"><span>                    return false;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                else {
</span></span><span style="display:flex;"><span>                    curr.setInvalid();
</span></span><span style="display:flex;"><span>                    pred.setNext(curr.next());
</span></span><span style="display:flex;"><span>                    return true;
</span></span><span style="display:flex;"><span>                }
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        } finally {
</span></span><span style="display:flex;"><span>            pred.unlock(); curr.unlock();
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Validation is constant time.</p>
</li>
<li>
<p>Membership checking does not require any locking â€“ itâ€™s even wait-free (it traverses
the list once without locking).</p>
</li>
<li>
<p>Physical removal of logically removed nodes could be batched and performed when
convenient â€“ thus reducing the number of times the physical chain of nodes is
changed, in turn reducing the expensive propagation of information between threads.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>Operations add and remove still require locking (as in OptimisticSet), which may
reduce the amount of parallelism.</li>
</ul>
</li>
</ul>
<p>Now lastly, let&rsquo;s solve this using <em>no locks</em>!</p>
<h3 id="lock-free-access">Lock free access</h3>
<p>If we&rsquo;re not using locks we need to use stronger synchronization primitives than locks.</p>
<p>Therefore we&rsquo;ll use the <code>compare-and-set</code> operation.</p>
<p>Let&rsquo;s try to implement <code>remove</code> using this:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public boolean remove(T item) {
</span></span><span style="display:flex;"><span>    boolean done;
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        if (curr.key() &gt;= item.key()) {
</span></span><span style="display:flex;"><span>            return false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        else {
</span></span><span style="display:flex;"><span>            done = pred.next().compareAndSet(pred.next(), curr.next());
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    } while (!done);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return true;
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This is however a naive approach and will not work, unfortunately. If two threads call <code>remove</code> at the same time,
it is possible that only one of them are successful.</p>
<p>We will need to borrow the idea of marking and updating nodes from <code>LazySet</code>.</p>
<p>Which means:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class AtomicMarkableReference&lt;V&gt; {
</span></span><span style="display:flex;"><span>    // Current reference and mark
</span></span><span style="display:flex;"><span>    V, boolean get();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // if reference == expectRef set mark to newMark and return true
</span></span><span style="display:flex;"><span>    // otherwise do not change anything and return false.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    boolean attemptMark(V expectRef, boolean newMark);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // if reference == expectRef and mark == expectMark,
</span></span><span style="display:flex;"><span>    // set reference to newRef, mark to newMark and return true;
</span></span><span style="display:flex;"><span>    // otherwise, do not change anything and return false.
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    boolean compareAndSet(V expectRef, V newRef, boolean expectMark, boolean newMark)
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>There are some more implementation details about our nodes, but let&rsquo;s skip that :).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public boolean remove(T item) {
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        if (curr.key() != item.key() || !curr.valid()) {
</span></span><span style="display:flex;"><span>            return false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (!curr.setInvalid()) {
</span></span><span style="display:flex;"><span>            continue;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        pred.setNextIfValid(curr, curr.next());
</span></span><span style="display:flex;"><span>        return true;
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>    // changed during logical removal: try again!
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean add(T item) {
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; pred, curr = find(head, item.key());
</span></span><span style="display:flex;"><span>        if (curr.key() == item.key() &amp;&amp; curr.valid()) {
</span></span><span style="display:flex;"><span>            // already in set and valid
</span></span><span style="display:flex;"><span>            return false;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>        Node&lt;T&gt; node = new LockFreeNode&lt;&gt;(item).setNext(curr);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if (pred.setNextIfValid(curr, node)) {
</span></span><span style="display:flex;"><span>            return true;
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>    // pred changed during add: try again!
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>public boolean has(T item) {
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; pred, curr = super.find(head, item.key());
</span></span><span style="display:flex;"><span>    return curr.valid() &amp;&amp; curr.key() == item.key();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>protected Node&lt;T&gt;, Node&lt;T&gt; find(Node&lt;T&gt; start, int key) {
</span></span><span style="display:flex;"><span>    boolean valid;
</span></span><span style="display:flex;"><span>    Node&lt;T&gt; pred, curr, succ;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    do {
</span></span><span style="display:flex;"><span>        pred = start;
</span></span><span style="display:flex;"><span>        curr = start.next();
</span></span><span style="display:flex;"><span>        do {
</span></span><span style="display:flex;"><span>            succ, valid = curr.nextValid();
</span></span><span style="display:flex;"><span>            while (!valid) {
</span></span><span style="display:flex;"><span>                if (!pred.setNextIfValid(curr, succ)) continue retry;
</span></span><span style="display:flex;"><span>                curr = succ; succ, valid = curr.nextValid();
</span></span><span style="display:flex;"><span>            }
</span></span><span style="display:flex;"><span>        if (curr.key() &gt;= key) return (pred, curr);
</span></span><span style="display:flex;"><span>        pred = curr; curr = succ;
</span></span><span style="display:flex;"><span>        } while (true);
</span></span><span style="display:flex;"><span>    } while (true);
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>No operations require locking: maximum potential for parallelism.</p>
</li>
<li>
<p>Membership checking does not require any locking â€“ itâ€™s even wait-free (it traverses
the list once without locking).</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>The implementation needs test-and-set-like synchronization primitives, which have to
be supported and come with their own performance costs.</p>
</li>
<li>
<p>Operations add and remove are lock-free but not wait-free: they may have to repeat
operations, and they may be delayed while they physically remove invalid nodes, with
the risk of introducing contention on nodes that have been already previously
logically deleted.</p>
</li>
</ul>
</li>
</ul>
<h3 id="when-to-lock-and-not">When to lock and not</h3>
<p>Each of the different implementations of concurrent set is the best choice for certain
applications and not for others:</p>
<ul>
<li>
<p><code>CoarseSet</code> works well with low contention.</p>
</li>
<li>
<p><code>FineSet</code> works well when threads tend to access the list orderly.</p>
</li>
<li>
<p><code>OptimisticSet</code> works well to let threads operate on disjoint portions of the list.</p>
</li>
<li>
<p><code>LazySet</code> works well when batching invalid node removal is convenient.</p>
</li>
<li>
<p><code>LockFreeSet</code> works well when locking is quite expensive</p>
</li>
</ul>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Concurrent-Programming">Concurrent Programming</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
