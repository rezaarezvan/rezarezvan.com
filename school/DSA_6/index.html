<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DSA: Part 6 - Trees - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science. Warning, this will be a quite long part soooo&hellip;
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node." />
	<meta property="og:image" content=""/>
	<meta property="og:title" content="DSA: Part 6 - Trees" />
<meta property="og:description" content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science. Warning, this will be a quite long part soooo&hellip;
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DSA_6/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-11-30T18:08:48+01:00" />
<meta property="article:modified_time" content="2022-11-30T18:08:48+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DSA: Part 6 - Trees"/>
<meta name="twitter:description" content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science. Warning, this will be a quite long part soooo&hellip;
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">DSA: Part 6 - Trees</h1>
			<div class="meta">Posted on Nov 30, 2022</div>
		</div>
		

		<section class="body">
			<p>In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science. Warning, this will be a quite long part soooo&hellip;</p>
<h3 id="trees">Trees</h3>
<p>The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A <em>hierarchical</em> data structure built up from <em>nodes</em>&rdquo;.</p>
<p>So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the <em>root</em> node is at the top of the tree.</p>
<p>In any tree there&rsquo;s always <strong>one</strong> <em>root</em> node. Each node can have so called <em>child</em> nodes, and these <em>children</em> can have their own child nodes and so on.</p>
<p>Therefore, all nodes - expect the root node - <strong>must</strong> have exactly <strong>one</strong> parent node.</p>
<h4 id="tree-rules">Tree rules</h4>
<p>I&rsquo;ve already stated some of the &lsquo;rules&rsquo; of a tree, but generally we have 3 rules that makes a collection of nodes a tree.</p>
<ul>
<li>
<p>Each node must have exactly one <strong>unique</strong> parent node - expect the root node.</p>
</li>
<li>
<p>There must exactly be <strong>one</strong> root node.</p>
</li>
<li>
<p>If the first and second rules are followed - then no &lsquo;cycles&rsquo; will appear.</p>
</li>
</ul>
<h3 id="recursive-trees">Recursive Trees</h3>
<p>Trees can also be defined recursively: &ldquo;A tree consists of a root node together with its <strong>subtrees</strong>, which do not share any common nodes&rdquo;.</p>
<p>This means, child node (of the root node) $\rightarrow$ root of subtree. This also means that a tree can be empty (no nodes) - for some applications this is needed.</p>
<h3 id="programming-with-trees">Programming with trees</h3>
<p>Now that we have some basic knowledge about trees - let&rsquo;s try to represent them with code. A very natural representation would be a directory <strong>tree</strong>.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Tree:
</span></span><span style="display:flex;"><span>    name: string
</span></span><span style="display:flex;"><span>    size: int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    children: list[Tree]
</span></span></code></pre></div><p>If we now want to compute the total size of a directory (folder) we would need to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>def total(tree: Tree) -&gt; int:
</span></span><span style="display:flex;"><span>    n: int = tree.bytes
</span></span><span style="display:flex;"><span>    for c in tree.children:
</span></span><span style="display:flex;"><span>        n += total(c)
</span></span><span style="display:flex;"><span>    return n
</span></span></code></pre></div><p>And we can see that recursion and trees go hand in hand. Now let&rsquo;s see how we can traverse the tree.</p>
<p>There are main methods for traversing - <strong>Pre-order</strong> traversal - meaning you process each node <strong>before</strong> visiting its children.
As well as <strong>Post-order</strong> traversal - meaning you process each node <strong>after</strong> visiting its children.</p>
<h3 id="binary-trees">Binary Trees</h3>
<p>Often we can use a special kind of tree called &lsquo;Binary tree&rsquo; - a binary tree is a tree where each node has exactly <strong>two</strong> children.</p>
<p>As we said before, these children can be represented as a null-value if they&rsquo;re &lsquo;missing&rsquo;. We call these children nodes the &rsquo;left&rsquo; and &lsquo;right&rsquo; nodes or subtrees.</p>
<p>Some terminology common used for trees are, <code>size</code> <code>height</code>, and <code>level</code>.
Size is the number of nodes in the (sub)tree - height, is the number of <code>levels</code> in the tree. Level is the distance from node to the root.</p>
<h3 id="binary-search-trees">Binary Search Trees</h3>
<p>Binary search trees or BSTs is a kind of binary tree but with some extra conditions:</p>
<ul>
<li>
<p>Each node has a <em>key</em></p>
</li>
<li>
<p>The node&rsquo;s key is smaller than all the keys in its right subtree</p>
</li>
<li>
<p>The node&rsquo;s key is greater than all the keys in its left subtree</p>
</li>
</ul>
<p>Or differently phrased, everything in its left subtree is less than the root, everything to the right is greater than the root.</p>
<p>With these rules searching becomes really, really effective and natural. We just compare our key to each node&rsquo;s key and see if we traverse to the right or left.</p>
<p>If we ever hit a &rsquo;null&rsquo; node, we can also say that the key we&rsquo;re searching for doesn&rsquo;t exist in this key.</p>
<p>So let us implement a map using BSTs!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class BSTMap[Key, Value]:
</span></span><span style="display:flex;"><span>    class Node:
</span></span><span style="display:flex;"><span>        key: Key
</span></span><span style="display:flex;"><span>        value: Value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        left, right: Node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    root: Node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def get(key: Key) -&gt; Value:
</span></span><span style="display:flex;"><span>    return get(key, root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def put(key : Key, val : Value):
</span></span><span style="display:flex;"><span>    root = put(key, val, root)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def get(key, node) -&gt; Value:
</span></span><span style="display:flex;"><span>    if node is None
</span></span><span style="display:flex;"><span>        return None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if key &lt; node.key
</span></span><span style="display:flex;"><span>        return get(key, node.left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    if key &gt; node.key
</span></span><span style="display:flex;"><span>        return get(key, node.right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    else:
</span></span><span style="display:flex;"><span>        return node.value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def put(key, val, node):
</span></span><span style="display:flex;"><span>    if node is None
</span></span><span style="display:flex;"><span>        return Node(key = key, value = val, left = None, right = None)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    elif key &lt; node.key:
</span></span><span style="display:flex;"><span>        node.left = put(key, value, node.left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    elif key &gt; node.key:
</span></span><span style="display:flex;"><span>        node.right = put(key, value, node.right)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    else:
</span></span><span style="display:flex;"><span>        node.value = value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return node
</span></span></code></pre></div><h3 id="fin-maxmin-value-in-bst">Fin max/min value in BST</h3>
<p>To find the max/min value in BST we just repeatedly go right/left until we hit a null node. Real simple!</p>
<p>Or in code:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def get_max(tree: BST):
</span></span><span style="display:flex;"><span>    c_node = tree.root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while c_node != None:
</span></span><span style="display:flex;"><span>        c_node = c_node.right
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return c_node.value
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def get_min(tree: BST):
</span></span><span style="display:flex;"><span>    c_node = tree.root
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while c_node != None:
</span></span><span style="display:flex;"><span>        c_node = c_node.left
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    return c_node.value
</span></span></code></pre></div><h3 id="sorting-a-bst">Sorting a BST</h3>
<p>Sometimes we might want to print/store a BST in ascending order - the way to do this of course is via recursion!</p>
<p>This is also known as <em>inorder</em> traversal - we print the left subtree, print the root then print the right subtree - we do this recursively.</p>
<p>So for example:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>def print_sorted(node: Node):
</span></span><span style="display:flex;"><span>    if node is None:
</span></span><span style="display:flex;"><span>        return
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    print_sorted(node.left)
</span></span><span style="display:flex;"><span>    print(node.key)
</span></span><span style="display:flex;"><span>    print_sorted(node.right)
</span></span></code></pre></div><p>We can also do a more general case - we make an <em>iterator</em> for the keys in the tree - by doing an inorder traversal and store the keys in a dynamic array.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>def keys() -&gt; list[Key]
</span></span><span style="display:flex;"><span>    list = []
</span></span><span style="display:flex;"><span>    inorder(root, list)
</span></span><span style="display:flex;"><span>    return list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def inorder(node: Node, list: list[Key]):
</span></span><span style="display:flex;"><span>    if node is None:
</span></span><span style="display:flex;"><span>        return
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    inorder(node.left, list)
</span></span><span style="display:flex;"><span>    list.add(node.key)
</span></span><span style="display:flex;"><span>    inorder(node.right, list)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>...
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>for key in BST.keys():
</span></span><span style="display:flex;"><span>    print(key)
</span></span></code></pre></div><h3 id="deletion">Deletion</h3>
<p>Deletion can be quite tricky in trees, and especially in BSTs - we can&rsquo;t just remove a node however, there are some rules.</p>
<h4 id="deleting-a-leaf">Deleting a leaf</h4>
<p>A so called leaf is a node with no children (or visually the leafs are the bottom nodes). These are fine to remove without any corrections.</p>
<p>Since we just remove that child, with no children there won&rsquo;t be any problems.</p>
<h4 id="deleting-a-node-with-one-child">Deleting a node with one child</h4>
<p>Now, in the case we want to delete a node with exactly one child, it&rsquo;s still quite trivial. Since that node only has one child, we can just replace the deleted node with its child. It doesn&rsquo;t affect the tree as a whole.</p>
<h4 id="deleting-a-node-with-two-children">Deleting a node with two children</h4>
<p>This is where it becomes tricky, but if we take a step back one think about it, we need to find a node that upholds the requirements of,
everything to the left should be smaller and everything to the right must be greater. If we think what candidates fullfil this requirement - it becomes clear two nodes are good candidates.</p>
<p>The <em>greatest</em> (rightmost) key in the node&rsquo;s <em>left</em> subtree <em><strong>or</strong></em> the <em>smallest</em> (leftmost) in the nodes&rsquo; <em>right</em> subtree.</p>
<h4 id="the-hardest-case">The hardest case</h4>
<p>The case above becomes quite simple if the candidates don&rsquo;t have any children, the hardest case in deletion is when these have one child.
What we need to do in that case is: We first delete the parent node by replacing it with its child - after we have done this we can delete the node we wanted to delete with our old (deleted) parent node.</p>
<p>So, not that hard logically - but can be a pain to implement correctly.</p>
<p>So let&rsquo;s now do exactly that :)!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>def delete(node: Node, key : Key):
</span></span><span style="display:flex;"><span>	if node is None:
</span></span><span style="display:flex;"><span>		return node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	if key &lt; node.key:
</span></span><span style="display:flex;"><span>		node.left = delete(node.left, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	elif(key &gt; node.key):
</span></span><span style="display:flex;"><span>		node.right = delete(node.right, key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	else:
</span></span><span style="display:flex;"><span>		if node.left is None:
</span></span><span style="display:flex;"><span>			temp = node.right
</span></span><span style="display:flex;"><span>			node = None
</span></span><span style="display:flex;"><span>			return temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		elif node.right is None:
</span></span><span style="display:flex;"><span>			temp = node.left
</span></span><span style="display:flex;"><span>			node = None
</span></span><span style="display:flex;"><span>			return temp
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		temp = get_max(node.left)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		node.key = temp.key
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>		node.right = delete(node.right, temp.key)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>	return node
</span></span></code></pre></div><h3 id="complexity">Complexity</h3>
<p>The complexity of operations for BST are in the best case and average case, $\mathcal{O}(log\ n)$ which is great.
In the worst case however, these operations will take $\mathcal{O}(n)$ since the items are in ascending order.</p>
<h3 id="bst-summary">BST Summary</h3>
<p>We can use BSTs to implement a set or map, however, with ordering-based operations such as min, max, range etc with good complexity.</p>
<p>Insert/Delete/Search will take proportional time to the height of the tree. Which in the best/average case is $\mathcal{O}(log\ n)$,
but if the tree is <strong>unbalanced</strong> it will become linear.</p>
<p>So the main take away is that, if a BST is balanced, it&rsquo;s really powerful and efficient. So let&rsquo;s take a look how we can make it balanced.</p>
<h3 id="invariants">Invariants</h3>
<p>The property that, in the left subtree, the keys should be lesser than and that in the right subtree, the keys should be greater than is an example of <strong>data structure invariant</strong>.</p>
<p>A invariant is a property that the designer wants to always hold. Usually a rule about what instances of the data structure are &lsquo;valid&rsquo;.</p>
<p>But these invariants can be expensive to maintain - if we say &rsquo;this array is sorted&rsquo; we can&rsquo;t just use append anymore, we need to <em>insert</em> it. So we need to find a invariant for BSTs which is easier to maintain.</p>
<h3 id="avl-trees">AVL Trees</h3>
<p>AVL Trees has a less restrictive invariant compared to BSTs - in an AVL tree we keep the tree <em>almost</em> balanced.</p>
<p>The invariant for an AVL tree is: &ldquo;For each node, the heights of its <em>left</em> and <em>right</em> subtrees differ by at <strong>most</strong> 1&rdquo;.</p>
<h3 id="tree-rotations">Tree Rotations</h3>
<p>Now before we dive deeper into AVL trees - let&rsquo;s take a look into rotations within trees. When we talk about rotations in trees we mean that it has a different node as the root.</p>
<p>Right rotation: <em>left</em> child of root becomes root, old root becomes <em>right</em> child.
Left rotation: <em>right child</em> of root becomes root, old root becomes <em>left</em> child.</p>
<p>Tree rotations preserve ordering and contents in BSTs. Note that we can also rotate a subtree.</p>
<h3 id="avl-insertion">AVL Insertion</h3>
<p>To insert a new node into an AVL tree - we first start by doing a BST insertion - this might break the AVL tree (the invariant).</p>
<p>But to fix this we go upwards from the new node, finding and fixing nodes that break the invariant. Note that during BST insertion, each node&rsquo;s height either stays the same or goes up by 1.</p>
<p>We have different cases which we&rsquo;ll look at.</p>
<h4 id="case-1-left-left-tree">Case 1: Left-left Tree</h4>
<p>In the Left-left case, we did an insertion in the <em>left</em> child of the <em>left</em> child of this node, which broke the invariant.</p>
<p>To fix this, we just make a right rotation</p>
<h4 id="case-2-right-right-tree">Case 2: Right-right Tree</h4>
<p>In the Right-right case, we did a insertion in the <em>right</em> child of the <em>right</em> child of this node, which broke the tree.</p>
<p>To fix we make a left rotation!</p>
<h4 id="case-3-left-right-tree">Case 3: Left-right Tree</h4>
<p>In the Left-right case, the extra height is in the root&rsquo;s <em>left</em> child then in the <em>right child</em> of that. We can&rsquo;t fix it with one rotation instead - but luckily we still have a solution.</p>
<p>First we&rsquo;re going to rotate the <em>left</em> <strong>subtree</strong> <em>left</em>. When we have performed the left rotation, we&rsquo;ve now created a Left-left tree, which is fixed by one right rotation as we saw earlier.</p>
<h4 id="case-4-right-left-tree">Case 4: Right-left Tree</h4>
<p>The same logic as case 3, the extra height is in the root&rsquo;s <em>right child</em> and then in the <em>left child</em> of that one.
To fix this we first make a right rotation in the right subtree - then make a final left rotation to fix the tree.</p>
<h3 id="avl-insertion-summary">AVL Insertion Summary</h3>
<p>So we have these four cases and we know how to solve them - we just need to remember how we identify them. We identify which <em>grandchild</em> the extra unit of heigh is in.</p>
<h3 id="avl-deletion">AVL Deletion</h3>
<p>In the case of deleting the node, the same scenarios happens! But instead we <em>reduce</em> the height of some tree by 1, breaking the invariant.</p>
<p>So therefore we can use the <strong>exact same balancing algorithm</strong>. So when implementing an AVL tree we only need to implement the balancing algorithm once!</p>
<p>In conclusion, AVL trees use rotation to keep the tree balanced. In the worst case height of the tree is $1.44\ log_2(n)$, but normally close to $log_2(n)$.</p>
<h3 id="2-3-trees">2-3 Trees</h3>
<p>2-3 trees is also another <strong>height</strong> balanced trees. 2-3 trees is made from two kinds of nodes:</p>
<ul>
<li>
<p>2 - node: Has a key <code>x</code> and two subtrees <code>A</code> and <code>B</code>. Just like in a BST, A &lt; x &lt; B</p>
</li>
<li>
<p>3 - node: Has <strong>two</strong> keys <code>x</code>, <code>y</code> with <strong>three</strong> subtrees, A, B, and C. As usual, A &lt; x &lt; B &lt; y &lt; C.</p>
</li>
</ul>
<h3 id="searching-in-2-3-trees">Searching in 2-3 Trees</h3>
<p>It proceeds just as in a BST. Since - In a 2-node, compare search key against key in node, descend into one of the  two children.</p>
<p>In the case of a 3-node, compare the search key against <strong>both</strong> keys in the node, descend into one of the <strong>three</strong> children.</p>
<h3 id="how-2-3-trees-balance">How 2-3 Trees balance</h3>
<p>In the AVL case we saw that we have to balance via rotations after each insertion/deletion. In the case of a 2-3 tree, we never have to balance since it&rsquo;s <strong>always</strong> balanced.</p>
<p>Because if one child is null all children must be null together (you can test this if you want by drawing examples). This means the empty trees are all at one level (which implies a balanced tree).</p>
<p>The resulting tree will have a height of between $log_3(n)$ and $lg(n)$</p>
<h3 id="insertion-in-2-3-trees">Insertion in 2-3 trees</h3>
<p>When we want to insert a new node to a 2-3 tree we use a normal insertion, however, this might break the tree via, for example, a unbalanced tree or a &lsquo;4-node&rsquo;.</p>
<p>To fix this we use the following algorithm:</p>
<ul>
<li><em>absorb</em> the node into its parent, move up to the parent</li>
<li>If the node is a 4-node, <em>split</em> it into 2-nodes.</li>
</ul>
<p>We keep alternating these 2 steps, we stop once we don&rsquo;t need to split.</p>
<h3 id="summary-2-3-trees">Summary 2-3 trees</h3>
<p>So conceptually they are quite simple - but the implementation is quite horrible, even though the complexity is great, since the tree is always <strong>perfectly</strong> balanced.</p>
<p>So to fix this we use something called a &lsquo;red-black BSTs&rsquo;.</p>
<h3 id="red-black-bsts">Red-black BSTs</h3>
<p>A red-black BSTs implement a 2-3 tree <em>using a BST</em>. We can see a 2-3 node as a BST tree since - a 2-node becomes a regular BST node, however, a 3-node becomes <strong>two</strong> BST nodes.</p>
<p>The name &lsquo;red-black&rsquo; comes from that we color the BST nodes in order to distinguish 2-nodes from 3-nodes.</p>
<p>2-nodes become black and 3-nodes become black with <em>red child</em>. So red is &lsquo;only part of a 3-node&rsquo;.</p>
<p>So a Red-black BST is really just a 2-3 but store it in a BST since we translate it to the corresponding 2-3 tree.</p>
<h3 id="red-black-tree-invariant">Red-black Tree Invariant</h3>
<p>The invariant that we must uphold for a red-black tree is:</p>
<ul>
<li>
<p>A red node may only occur as the <em>left</em> child of a <em>black</em> node</p>
</li>
<li>
<p>Black balance: on any path from the root to a null, we pass through the same number of black nodes</p>
</li>
<li>
<p>And the BST invariant must also hold.</p>
</li>
</ul>
<h3 id="red-black-bst-insertion">Red-black BST Insertion</h3>
<p>To make an insertion into a red-black tree, we first make a normal BST insertion, the newly added node is a <em>red</em> node.</p>
<p>This may break our invariant on red nodes, but this way we always keep the black balance and BST properties.</p>
<p>But this way we&rsquo;ll only break the invariant by placing a red node in a forbidden place. There are 3 cases which this will happen.</p>
<h4 id="case-1-skew">Case 1: Skew</h4>
<p>In a skew case, we have placed it to the right of a 2-node (black node) and therefore broken the first rule. We fix it by a operation called <em>skewing</em>.</p>
<p>Which is a kind of rotation, we&rsquo;ll look at the implementation later.</p>
<h4 id="case-2-split">Case 2: Split</h4>
<p>In a split case we have created a 4-node (or a red having a red child), therefore we need to split it into 2-nodes.
In the case of splitting, we may break the black balance which means we need to continue up recursively</p>
<h4 id="case-3-red-root-node">Case 3: Red Root Node</h4>
<p>After a split, we might end up with a red node as the <em>root</em> of the whole tree. In a case like this, the fix is simple, we just make the root a black node instead!</p>
<h3 id="red-black-tree-implementation">Red-black Tree Implementation</h3>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class RBNode:
</span></span><span style="display:flex;"><span>    def __init__(self, val):
</span></span><span style="display:flex;"><span>        self.red = False
</span></span><span style="display:flex;"><span>        self.parent = None
</span></span><span style="display:flex;"><span>        self.val = val
</span></span><span style="display:flex;"><span>        self.left = None
</span></span><span style="display:flex;"><span>        self.right = None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class RBTree:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.nil = RBNode(0)
</span></span><span style="display:flex;"><span>        self.nil.red = False
</span></span><span style="display:flex;"><span>        self.nil.left = None
</span></span><span style="display:flex;"><span>        self.nil.right = None
</span></span><span style="display:flex;"><span>        self.root = self.nil
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def insert(self, val):
</span></span><span style="display:flex;"><span>    new_node = RBNode(val)
</span></span><span style="display:flex;"><span>    new_node.parent = None
</span></span><span style="display:flex;"><span>    new_node.left = self.nil
</span></span><span style="display:flex;"><span>    new_node.right = self.nil
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    # New node must be red
</span></span><span style="display:flex;"><span>    new_node.red = True
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    parent = None
</span></span><span style="display:flex;"><span>    current = self.root
</span></span><span style="display:flex;"><span>    while current != self.nil:
</span></span><span style="display:flex;"><span>        parent = current
</span></span><span style="display:flex;"><span>        if new_node.val &lt; current.val:
</span></span><span style="display:flex;"><span>            current = current.left
</span></span><span style="display:flex;"><span>        elif new_node.val &gt; current.val:
</span></span><span style="display:flex;"><span>            current = current.right
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            return
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    new_node.parent = parent
</span></span><span style="display:flex;"><span>    if parent == None:
</span></span><span style="display:flex;"><span>        self.root = new_node
</span></span><span style="display:flex;"><span>    elif new_node.val &lt; parent.val:
</span></span><span style="display:flex;"><span>        parent.left = new_node
</span></span><span style="display:flex;"><span>    else:
</span></span><span style="display:flex;"><span>        parent.right = new_node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    self.fix_insert(new_node)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def rotate_left(self, x):
</span></span><span style="display:flex;"><span>    y = x.right
</span></span><span style="display:flex;"><span>    x.right = y.left
</span></span><span style="display:flex;"><span>    if y.left != self.nil:
</span></span><span style="display:flex;"><span>        y.left.parent = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    y.parent = x.parent
</span></span><span style="display:flex;"><span>    if x.parent == None:
</span></span><span style="display:flex;"><span>        self.root = y
</span></span><span style="display:flex;"><span>    elif x == x.parent.left:
</span></span><span style="display:flex;"><span>        x.parent.left = y
</span></span><span style="display:flex;"><span>    else:
</span></span><span style="display:flex;"><span>        x.parent.right = y
</span></span><span style="display:flex;"><span>    y.left = x
</span></span><span style="display:flex;"><span>    x.parent = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def rotate_right(self, x):
</span></span><span style="display:flex;"><span>    y = x.left
</span></span><span style="display:flex;"><span>    x.left = y.right
</span></span><span style="display:flex;"><span>    if y.right != self.nil:
</span></span><span style="display:flex;"><span>        y.right.parent = x
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    y.parent = x.parent
</span></span><span style="display:flex;"><span>    if x.parent == None:
</span></span><span style="display:flex;"><span>        self.root = y
</span></span><span style="display:flex;"><span>    elif x == x.parent.right:
</span></span><span style="display:flex;"><span>        x.parent.right = y
</span></span><span style="display:flex;"><span>    else:
</span></span><span style="display:flex;"><span>        x.parent.left = y
</span></span><span style="display:flex;"><span>    y.right = x
</span></span><span style="display:flex;"><span>    x.parent = y
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def fix_insert(self, new_node):
</span></span><span style="display:flex;"><span>    while new_node != self.root and new_node.parent.red:
</span></span><span style="display:flex;"><span>        if new_node.parent == new_node.parent.parent.right:
</span></span><span style="display:flex;"><span>            u = new_node.parent.parent.left  # uncle
</span></span><span style="display:flex;"><span>            if u.red:
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>                u.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.parent.red = True
</span></span><span style="display:flex;"><span>                new_node = new_node.parent.parent
</span></span><span style="display:flex;"><span>            else:
</span></span><span style="display:flex;"><span>                if new_node == new_node.parent.left:
</span></span><span style="display:flex;"><span>                    new_node = new_node.parent
</span></span><span style="display:flex;"><span>                    self.rotate_right(new_node)
</span></span><span style="display:flex;"><span>                new_node.parent.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.parent.red = True
</span></span><span style="display:flex;"><span>                self.rotate_left(new_node.parent.parent)
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            u = new_node.parent.parent.right  # uncle
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            if u.red:
</span></span><span style="display:flex;"><span>                u.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.parent.red = True
</span></span><span style="display:flex;"><span>                new_node = new_node.parent.parent
</span></span><span style="display:flex;"><span>            else:
</span></span><span style="display:flex;"><span>                if new_node == new_node.parent.right:
</span></span><span style="display:flex;"><span>                    new_node = new_node.parent
</span></span><span style="display:flex;"><span>                    self.rotate_left(new_node)
</span></span><span style="display:flex;"><span>                new_node.parent.red = False
</span></span><span style="display:flex;"><span>                new_node.parent.parent.red = True
</span></span><span style="display:flex;"><span>                self.rotate_right(new_node.parent.parent)
</span></span><span style="display:flex;"><span>    self.root.red = False
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>def exists(self, val):
</span></span><span style="display:flex;"><span>    curr = self.root
</span></span><span style="display:flex;"><span>    while curr != self.nil and val != curr.val:
</span></span><span style="display:flex;"><span>        if val &lt; curr.val:
</span></span><span style="display:flex;"><span>            curr = curr.left
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            curr = curr.right
</span></span><span style="display:flex;"><span>    return curr
</span></span></code></pre></div><h3 id="red-black-tree-summary">Red-black Tree Summary</h3>
<p>Red-black trees are 2-3 trees implemented using a BST - they have the invariant that they have to correspond to a perfectly balanced 2-3 tree.</p>
<p>Update strategy is: Insert in a way that break the rules on red nodes, then fix it.</p>
<p>They have logarithmic performance - worst case they height is $2\ log(n)$</p>
<p>This was the end of this part - it was a lot to process, it was a lot for me as well :). In the next part we&rsquo;ll cover priority queues and how they can be implemented as a kind of tree :).</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
