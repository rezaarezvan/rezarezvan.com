<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Astro v4.11.5"><link rel="icon" type="image" href="/favicon.ico"><title>Part 5 - Hash Tables</title><!-- KaTeX support --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script><!-- inline KaTeX --><link rel="stylesheet" href="/_astro/index.B_-I1NWR.css">
<style>article[data-astro-cid-v5ro3oot]{max-width:80ch;margin:0 auto}.nav-button[data-astro-cid-v5ro3oot]{display:flex;align-items:center;padding:.5rem;border-radius:.5rem;transition:background-color .3s ease;text-decoration:none;color:var(--text-color);background-color:var(--bg-color);border:1px solid var(--border-color)}.nav-button[data-astro-cid-v5ro3oot]:hover{background-color:var(--hover-color)}.nav-button[data-astro-cid-v5ro3oot] .arrow[data-astro-cid-v5ro3oot]{font-size:1.5rem;line-height:1}.nav-button[data-astro-cid-v5ro3oot] .text[data-astro-cid-v5ro3oot]{display:flex;flex-direction:column;margin:0 .5rem}.nav-button[data-astro-cid-v5ro3oot] .label[data-astro-cid-v5ro3oot]{font-size:.8rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted-color)}.nav-button[data-astro-cid-v5ro3oot] .title[data-astro-cid-v5ro3oot]{font-weight:500}.prev-button[data-astro-cid-v5ro3oot]{justify-content:flex-start}.next-button[data-astro-cid-v5ro3oot]{justify-content:flex-end;text-align:right}@media (max-width: 640px){.nav-button[data-astro-cid-v5ro3oot]{width:100%}.next-button[data-astro-cid-v5ro3oot]{justify-content:flex-start;text-align:left}.next-button[data-astro-cid-v5ro3oot] .text[data-astro-cid-v5ro3oot]{order:2;margin-left:.5rem}.next-button[data-astro-cid-v5ro3oot] .arrow[data-astro-cid-v5ro3oot]{order:1}}
</style>
<link rel="stylesheet" href="/_astro/_slug_.C5ncBpZU.css"><script type="module">document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})});
</script></head> <body> <div class="container mx-auto px-4 flex flex-col md:flex-row min-h-screen"> <aside class="w-full md:w-64 border-b md:border-r md:border-b-0 border-[var(--border-color)] border-dashed pt-8"> <header class="flex flex-col h-full"> <div class="flex items-center mb-4"> <script>
  function setTheme(mode) {
    localStorage.setItem("theme-storage", mode);
    document.documentElement.setAttribute('data-theme', mode);
  }
  function toggleTheme() {
    const currentTheme = localStorage.getItem("theme-storage") || "light";
    const newTheme = currentTheme === "light" ? "dark" : "light";
    setTheme(newTheme);
  }
  const savedTheme = localStorage.getItem("theme-storage") || "light";
  setTheme(savedTheme);
  window.toggleTheme = toggleTheme;
</script> <button id="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme" class="flex items-center justify-center w-6" data-astro-cid-x3pjskd3>○</button>  <a href="/" class="text-2xl font-semibold ml-3 h-10 pr-3">rezvan.xyz</a> </div> <nav class="flex flex-wrap gap-2 md:flex-col md:gap-2"> <a href="/principles" class="hover:text-orange-500 dark:hover:text-orange-400 transition-colors">
[principles]
</a><a href="/cv" class="hover:text-orange-500 dark:hover:text-orange-400 transition-colors">
[cv]
</a><a href="/posts" class="hover:text-orange-500 dark:hover:text-orange-400 transition-colors">
[posts]
</a><a href="/school" class="hover:text-orange-500 dark:hover:text-orange-400 transition-colors">
[school]
</a> </nav> </header> </aside> <div class="hidden md:block"> <div class="vertical-marquee-container left" data-astro-cid-47hzastc> <div class="vertical-marquee" data-astro-cid-47hzastc> <div key="0" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="1" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="2" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="3" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="4" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="5" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="6" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="7" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="8" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="9" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div> </div> </div>  </div> <main class="flex-grow px-4 md:px-8 py-8 overflow-y-auto">  <article class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl max-w-none" data-astro-cid-v5ro3oot> <h1 class="text-3xl sm:text-4xl font-bold mb-4" data-astro-cid-v5ro3oot>Part 5 - Hash Tables</h1> <p class="text-sm text-muted-foreground mb-4" data-astro-cid-v5ro3oot>
Date: 11/29/2022 </p>  <h3 id="hash-tables">Hash Tables</h3>
<p>Hash tables are one of the most famous (and widely used) data structures. But why are they so popular and powerful?
Before we can answer that question we need to look back at sets and maps.</p>
<h3 id="sets-and-maps-in-context">Sets and Maps in Context</h3>
<p>Just to refresh our memory - a set is a <em>collection of items</em>, where duplicates aren’t allowed.
Maps are <strong>sets</strong> of <em>keys</em>, each having an associate value - or you can formulate it as - a <strong>set</strong> of <em>key-value pairs</em>.</p>
<p>Maps are used in almost all programs and applications since they’re very powerful and intuitive. They can act as databases (some databases are just straight up maps as well):</p>
<ul>
<li>Look up a person by their social security number.</li>
<li>Look up a file in a computer by its name/filetype/size.</li>
<li>Find all words appearing in a text/website/book.</li>
</ul>
<p>Only problem is that, our usual implementation of maps makes the <code>search()</code> and <code>update()</code> are quite slow, in fact, the complexity is usually
<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">)</span></span></span></span> or in case we’re using a <em>mutlimap</em> <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>n</mi><mo>⋅</mo><mi>m</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(n \cdot m)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mspace" style="margin-right:0.2222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222em;"></span></span><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathnormal">m</span><span class="mclose">)</span></span></span></span>.</p>
<p>We would like a complexity of <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mi>l</mi><mi>o</mi><mi>g</mi><mo stretchy="false">(</mo><mi>n</mi><mo stretchy="false">)</mo><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(log(n))</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord mathnormal" style="margin-right:0.01968em;">l</span><span class="mord mathnormal">o</span><span class="mord mathnormal" style="margin-right:0.03588em;">g</span><span class="mopen">(</span><span class="mord mathnormal">n</span><span class="mclose">))</span></span></span></span> or <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mn>1</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(1)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord">1</span><span class="mclose">)</span></span></span></span>. Even if we implement maps using all the different data structures we have - we still can’t achieve this:</p>
<ul>
<li>Dynamic Array of key-value pairs
<ul>
<li>Search takes linear time</li>
<li>Insertion takes linear time</li>
</ul>
</li>
<li>A Linked List
<ul>
<li>Same as the dynamic array</li>
</ul>
</li>
<li>A <em>sorted</em> Dynamic Array
<ul>
<li>Search takes logarithmic time (binary search).</li>
<li>Insertion still takes linear time…</li>
</ul>
</li>
</ul>
<p>The answer is <em><strong>Hash Tables</strong></em>!</p>
<h3 id="separate-chaining-hash-tables">Separate Chaining Hash Tables</h3>
<p>One thing to know before we dive in is - there are two different strategies when it comes to tables, we’ll begin with separate chaining.</p>
<h4 id="hash-functions">Hash Functions</h4>
<p>Before we start talking about what a hash <strong>table</strong> is we first need to look into what a hash <strong>function</strong> is. The problem with ordinary maps that they are an unordered data structure.
We need some kind of function which calculates, based on different parameters, where <code>Item x</code> should go into our map, because afterward, we can just search for that index, which is much faster. This is what hash functions are for!</p>
<p>At the same time our hash functions needs to be ‘good’. We can’t have a hash functions that only returns index 1 and stack every item into the same slot. But we also can’t be lazy, in the example of sorting a collection of people.
We can’t just go by their first letter in their name, there are a lot more names that begin with a ‘A’ than a ‘Z’ for example.</p>
<p>So we want a hash functions that also <em>evenly</em> distributes the objects, and at the same time efficient to compute.</p>
<p>With this in mind we can now define a hash table.</p>
<h3 id="hash-tables-1">Hash Tables</h3>
<p>A hash table uses a hash function to compute the array index. It’s not possible to put more than one object into one array slot, so if our hash function returns the same index for different objects (we will later see, by definition, this is a bad hash function) we need a solution.
Separate chaining is one of them.</p>
<h3 id="separate-chaining">Separate Chaining</h3>
<p>In a separate chaining hash table, instead of having just one array slot, we instead have the value/slots being a pointer. This pointer then points to collections of all the values/objects having the same hash value.</p>
<p>Usually this is a linked list, but any searchable collection works (A dynamic array for example).</p>
<h3 id="open-addressing-hash-tables">Open Addressing Hash Tables</h3>
<p>In the other case, being open addressing, each slot contains exactly one object/value. However - if we ever encounter a conflict, we just move that value/object into a free slot, the tricky part is an efficient way of finding a free slot.
We’ll see more of this later.</p>
<h3 id="separate-chaining-hash-set">Separate Chaining: Hash Set</h3>
<p>For our implementation of Hash tables using separate chaining we could use sets - and for the underlying collection, we usually use linked lists.</p>
<p>So a kind of implementation (in pseudocode) would be:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashSet &#x3C;Item> implements Set&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of Set&#x3C;Item></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // A given good hash function</span></span>
<span class="line"><span>    hash(x : Item) -> int:</span></span>
<span class="line"><span>        // Returns good hash value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(x : Item) -> boolean:</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        return bucket.contains(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        bucket.add(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(x : Item):</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        bucket.remove(x)</span></span>
<span class="line"><span></span></span></code></pre>
<p>As we can see there is quite a lot of ‘mental overhead’, using an ordinary map it also becomes faster since we have actual key-value pairs, therefore being faster.
Also, we need to know the size of the Hash table and also handle null pointers so let’s fix that as well!</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashMap&#x3C;Key, Value> implements Map&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Array of Map&#x3C;Key, Value></span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    hash(k : Key) -> int:</span></span>
<span class="line"><span>        // Returns good hash value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(k : Key) -> boolean:</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        return bucket.contains(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    get(k : Key) -> Value:</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        return bucket.get(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        if bucket == NULL:</span></span>
<span class="line"><span>            bucket = table[hash(x)] = new Map()</span></span>
<span class="line"><span>        if not bucket.contains(k):</span></span>
<span class="line"><span>            bucket.put(k, v)</span></span>
<span class="line"><span>            size += 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(k : Key):</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        bucket.remove(k)</span></span>
<span class="line"><span></span></span></code></pre>
<p>If we actually try to implement it with the underlying data structure, the linked list, it would look something like:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashMap&#x3C;Key, Value> implements Map&#x3C;Key, Value>:</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    class Node:</span></span>
<span class="line"><span>        key : Key</span></span>
<span class="line"><span>        val : Value</span></span>
<span class="line"><span>        next : Node</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    get(k : Key) -> Value:</span></span>
<span class="line"><span>        node : Node = table[hash(k)]</span></span>
<span class="line"><span>        while node != NULL:</span></span>
<span class="line"><span>            if k == node.key</span></span>
<span class="line"><span>                return node.val</span></span>
<span class="line"><span>            node = node.next</span></span>
<span class="line"><span>        return NULL</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        h : int = hash(k)</span></span>
<span class="line"><span>        node : Node = table[h]</span></span>
<span class="line"><span>        while node != NULL:</span></span>
<span class="line"><span>            if k == node.key:</span></span>
<span class="line"><span>                node.val = v</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            node = node.next</span></span>
<span class="line"><span>        // If we are given a new key</span></span>
<span class="line"><span>        table[h] = Node(k, v, table[h])</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="load-factor">Load Factor</h3>
<p>We should always assume that we have a good hash functions, since in most libraries, they are good! But to understand why it’s ‘good’ we need to understand something called <em>Load factor</em>.
The load factor is the average number of elements per slot/index.</p>
<p>So load factor = <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mfrac><mi>N</mi><mi>M</mi></mfrac></mrow><annotation encoding="application/x-tex">\frac{N}{M}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span></span></span></span>, where N is # of elements and M is the array size.
We haven’t discussed it yet but, what’s the complexity of <code>contains</code>, <code>add</code>, and <code>put</code> for example? Well it depends on the total array size and the number of elements per slot. The load factor!</p>
<p>Therefore, the complexity of each operation is <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi mathvariant="script">O</mi><mo stretchy="false">(</mo><mfrac><mi>N</mi><mi>M</mi></mfrac><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">\mathcal{O}(\frac{N}{M})</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1.2173em;vertical-align:-0.345em;"></span><span class="mord mathcal" style="margin-right:0.02778em;">O</span><span class="mopen">(</span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.8723em;"><span style="top:-2.655em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">M</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathnormal mtight" style="margin-right:0.10903em;">N</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mclose">)</span></span></span></span></p>
<p>Which tells us, if we can keep N and M roughly the same all of our operations will be constant! This is the magic with Hash tables.</p>
<p>So our array size must grow when the hash table grows. To achieve this we use a dynamic array, when we need to resize the hash table array, we create a new array and copy all old elements using <code>add()</code>.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>put(k : Key, v : Value):</span></span>
<span class="line"><span>    if size >= 8 * table.length:</span></span>
<span class="line"><span>        resize(2 * table.length)</span></span>
<span class="line"><span>    bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        if bucket == NULL:</span></span>
<span class="line"><span>            bucket = table[hash(x)] = new Map()</span></span>
<span class="line"><span>        if not bucket.contains(k):</span></span>
<span class="line"><span>            bucket.put(k, v)</span></span>
<span class="line"><span>            size += 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>remove(k : Key):</span></span>
<span class="line"><span>    if size ≤ 2 * table.length:</span></span>
<span class="line"><span>        resize(table.length / 2)</span></span>
<span class="line"><span>    bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        bucket.remove(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>resize(buckets : int):</span></span>
<span class="line"><span>    oldtable = table</span></span>
<span class="line"><span>    table = new Array with size buckets</span></span>
<span class="line"><span>    size = 0</span></span>
<span class="line"><span>    for bucket in oldtable:</span></span>
<span class="line"><span>        for k,v in bucket:</span></span>
<span class="line"><span>            this.put(k, v)</span></span>
<span class="line"><span></span></span></code></pre>
<p>In this example I’ve chosen to resize the table with a factor of 2. However, this is can actually lead to some problems.
The ‘optimal’ way is to choose a <em>prime</em> closest to <code>2 * oldsize</code>.</p>
<h3 id="hash-and-compress">Hash and compress</h3>
<p>In actuality, the hash functions are a composition of functions. First we get the <em>hash code</em> for a given object/value. Then we need to <em>compress</em> it to fit inside our hash table.</p>
<p>How we compress our is quite simple (often) - it is:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>index = hash_code % array_size</span></span>
<span class="line"><span>i = h % M</span></span>
<span class="line"><span></span></span></code></pre>
<p>This is called ‘modular’ hashing, it’s the most common one. One thing to remember that the <em>hash code</em> <strong>never</strong> changes. Only the compressed version can change since we can change the size of it.</p>
<p>So we might see different outputs for <code>hash(x)</code> depending on size - but remember, the actual <em>hash code</em> <strong>never</strong> changes.</p>
<h3 id="requirements-on-hash-functions">Requirements on hash functions</h3>
<p>There is one very strict requirement on hash functions:</p>
<ul>
<li>Equal objects must have equal hash codes</li>
</ul>
<p>Or in coding terms:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>if x === y then x.hash() == y.hash()</span></span>
<span class="line"><span></span></span></code></pre>
<p>There are some desirable properties:</p>
<ul>
<li>If x and y have the same <em>hash code</em>, then they are ‘equal’</li>
<li>The distribution should be uniform and independent</li>
</ul>
<h3 id="open-addressing-probing">Open Addressing: Probing</h3>
<p>As we defined earlier, open addressing is a method where we find a new empty slot if there’s a conflict. Probing is how we find this empty slot.</p>
<p>The easiest approach is so called <em>linear probing</em>, where we simply go to the next index (increase with some constant) and check if it’s empty, with wrapping around the array.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashSet&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of Item</span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>                if x == table[i]:</span></span>
<span class="line"><span>                    return</span></span>
<span class="line"><span>                i = (i + 1) % table.length</span></span>
<span class="line"><span>        table[i] = x</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span></span></span></code></pre>
<p>Or in the Hash Map case:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashMap&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Map&#x3C;Key, Value></span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(k : Key, v : Value):</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>                if k == table[i]:</span></span>
<span class="line"><span>                    return</span></span>
<span class="line"><span>                i = (i + 1) % table.length</span></span>
<span class="line"><span>        table[i] = value</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="open-addressing-compared-to-separate-chaining">Open Addressing compared to Separate Chaining</h3>
<p>Let’s now compare both of these approaches now that we have a grasp of them.</p>
<ul>
<li>Separate Chaining
<ul>
<li>Load factor can be > 1 without performance loss.</li>
<li>The extra list nodes take up unnecessary memory.</li>
<li>Since the list nodes are (usually) scattered in memory - we can not optimize via for example CPU caching.</li>
</ul>
</li>
<li>Open Addressing
<ul>
<li>Load factor <strong>must</strong> be &#x3C; 1, and the performance drops when load factor > 3/4.</li>
<li>Doesn’t take up unnecessary memory with extra list nodes.</li>
<li>Elements with the same hash code tend to be close in memory - therefore we can utilize CPU caching.</li>
</ul>
</li>
</ul>
<h3 id="deletion">Deletion</h3>
<p>If we want to delete object while using Open Addressing - we will encounter a very famous problem called ‘clusters’.
A short definition of clusters is, due to Open Addressing, we will get small ‘clusters’ or ‘chunks’. These are quite valuable since they tell us which objects have similar hash codes.</p>
<p>But first to understand why, let’s see how we <em>would</em> delete items.</p>
<h4 id="naive-approach">Naive approach</h4>
<p>Our naive approach would look something like:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>remove(x : Item):</span></span>
<span class="line"><span>    i = hash(x)</span></span>
<span class="line"><span>    while table[i] != NULL:</span></span>
<span class="line"><span>        if x == table[i]:</span></span>
<span class="line"><span>            table[i] = NULL</span></span>
<span class="line"><span>        i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span></code></pre>
<p>And in the map case:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>remove(k : Key):</span></span>
<span class="line"><span>    i = hash(x)</span></span>
<span class="line"><span>    while table[i] != NULL:</span></span>
<span class="line"><span>        if k == table[i]:</span></span>
<span class="line"><span>            table[i] = NULL</span></span>
<span class="line"><span>        i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span></code></pre>
<p>But this won’t work - if we then want to find something to the <strong>right</strong> of this deleted cell - but their hash is <strong>before</strong> the deleted cell, we won’t be able to, since we find the ‘NULL’ value before we can find the actual object.</p>
<p>There are two possible solutions:</p>
<ul>
<li>Lazy deletion:
<ul>
<li>We don’t necessarily ‘delete’ the item, just ‘mark’ it deleted, rather than empty.</li>
</ul>
</li>
<li>Recalculation:
<ul>
<li>We reinsert all elements in the cluster that are to the <strong>right</strong> of the deleted element.</li>
</ul>
</li>
</ul>
<p>One problem we will also encounter is, we won’t be able to properly count # of deleted cells - therefore our resizing calculations will suffer - the solution is to have a variable for each deleted cell.
If this number exceeds some threshold we resize.</p>
<h3 id="final-implementations">Final implementations</h3>
<p>So, we have covered all topics and problems that come with implementing Hash tables - so let’s implement the final version.</p>
<p>For a Hash <strong>Set</strong>:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashSet&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of HashCell</span></span>
<span class="line"><span>    size: int = 0</span></span>
<span class="line"><span>    n_deleted: int = 0</span></span>
<span class="line"><span>    DELETED: HashCell = HashCell(value = NULL)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class HashCell:</span></span>
<span class="line"><span>        value: Item</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    load_factor() -> float:</span></span>
<span class="line"><span>        return (size + deleted) / table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        if load_factor() > 0.75:</span></span>
<span class="line"><span>            resize(2 * table.length)</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while table[i] != NULL and table[i] != DELETED:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span>        if table[i] = DELETED:</span></span>
<span class="line"><span>            n_deleted -= 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        table[i] = HashCell(value = x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(x : Item) -> boolean:</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                return True</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        return False</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(x : Item):</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                table[i] = DELETED</span></span>
<span class="line"><span>                size -= 1</span></span>
<span class="line"><span>                n_deleted += 1</span></span>
<span class="line"><span>                if load_factor() &#x3C; 0.25:</span></span>
<span class="line"><span>                    resize(table.length // 2)</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    resize(buckets: int):</span></span>
<span class="line"><span>        oldtable = table</span></span>
<span class="line"><span>        table = new Array with size buckets</span></span>
<span class="line"><span>        size = n_deleted = 0</span></span>
<span class="line"><span>        for cell in oldtable:</span></span>
<span class="line"><span>            if cell != NULL and cell != DELETED:</span></span>
<span class="line"><span>                table.add(cell.value)</span></span>
<span class="line"><span></span></span></code></pre>
<p>And in the <strong>Map</strong> case:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashMap&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Array of HashCell</span></span>
<span class="line"><span>    size: int = 0</span></span>
<span class="line"><span>    n_deleted: int = 0</span></span>
<span class="line"><span>    DELETED: HashCell = HashCell(key = NULL,value = NULL)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class HashCell:</span></span>
<span class="line"><span>        key: Key</span></span>
<span class="line"><span>        value: Value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    load_factor() -> float:</span></span>
<span class="line"><span>        return (size + deleted) / table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        if load_factor() > 0.75:</span></span>
<span class="line"><span>            resize(2 * table.length)</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while table[i] != NULL and table[i] != DELETED:</span></span>
<span class="line"><span>            if k == table[i].key:</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span>        if table[i] = DELETED:</span></span>
<span class="line"><span>            n_deleted -= 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        table[i] = HashCell(key = k, value = v)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(k : Key) -> boolean:</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if k == table[i].key:</span></span>
<span class="line"><span>                return True</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        return False</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(k : Key):</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if k == table[i].value:</span></span>
<span class="line"><span>                table[i] = DELETED</span></span>
<span class="line"><span>                size -= 1</span></span>
<span class="line"><span>                n_deleted += 1</span></span>
<span class="line"><span>                if load_factor() &#x3C; 0.25:</span></span>
<span class="line"><span>                    resize(table.length // 2)</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    resize(buckets: int):</span></span>
<span class="line"><span>        oldtable = table</span></span>
<span class="line"><span>        table = new Array with size buckets</span></span>
<span class="line"><span>        size = n_deleted = 0</span></span>
<span class="line"><span>        for cell in oldtable:</span></span>
<span class="line"><span>            if cell != NULL and cell != DELETED:</span></span>
<span class="line"><span>                table.add(cell.key, cell.value)</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="clustering">Clustering</h3>
<p>As mentioned before - clusters is by-product of open addressing - but these make the search times slower, in the worst time it becomes linear!</p>
<p>The famous Donald E. Knuth formulated the so called ‘Knuth’s parking problem’ which shows how rapid this cluster problem grows.</p>
<h3 id="alternatives-to-linear-probing">Alternatives to linear probing</h3>
<p>Instead of linearly increase, we could do <em>quadratic</em>, <em>double hashing</em> which depends on a <em>second</em> hash function, or <em>moving</em> alternatives such as:
<em>cuckoo</em>, <em>hopscotch</em> and <em>Robin Hood</em> hashing. We will only use linear probing though…</p>
<h3 id="summary">Summary</h3>
<p>There’s <strong>a lot</strong> to hashing and hash tables in general. But I think we’ll leave it here, one final thing I want to bring up is:</p>
<p>Hash tables are not ordered! If we want to find a maximum value in a hash table - it will take linear time! Since there’s no underlying order.</p>
<p>In the next part we’ll begin looking at trees - starting at <strong>B</strong>alanced <strong>S</strong>earch <strong>T</strong>rees or BSTs for short. We’ll actually compare them to Hash maps, since they are quite similar in some aspects.</p>  <nav class="flex flex-col sm:flex-row justify-between mt-8 pt-4 border-t border-border" data-astro-cid-v5ro3oot> <a href="/school/dat038/dat038_4" class="nav-button prev-button mb-4 sm:mb-0" data-astro-cid-v5ro3oot> <span class="arrow" data-astro-cid-v5ro3oot>←</span> <span class="text" data-astro-cid-v5ro3oot> <span class="label" data-astro-cid-v5ro3oot>Previous</span> <span class="title" data-astro-cid-v5ro3oot>Part 4 - Abstract Data Types</span> </span> </a> <a href="/school/dat038/dat038_6" class="nav-button next-button" data-astro-cid-v5ro3oot> <span class="text" data-astro-cid-v5ro3oot> <span class="label" data-astro-cid-v5ro3oot>Next</span> <span class="title" data-astro-cid-v5ro3oot>Part 6 - Trees</span> </span> <span class="arrow" data-astro-cid-v5ro3oot>→</span> </a> </nav> </article>  </main> <div class="hidden md:block"> <div class="vertical-marquee-container right" data-astro-cid-47hzastc> <div class="vertical-marquee" data-astro-cid-47hzastc> <div key="0" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="1" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="2" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="3" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="4" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="5" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="6" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="7" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="8" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div><div key="9" class="marquee-item" data-astro-cid-47hzastc>memento mori • amor fati • sic parvis magna • per aspera ad astra • carthago delenda est • vincit qui se vincit</div> </div> </div>  </div> <aside class="hidden md:block md:w-64 md:border-l md:border-t-0 border-[var(--border-color)] border-dashed relative"> <div class="right-images-view parent-container" id="right-images-view" data-astro-cid-nbc4lsjz> <div class="overlay-gradient" data-astro-cid-nbc4lsjz></div> <div class="image-container" data-astro-cid-nbc4lsjz> <div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230815_232746.jpg" alt="1" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231002_204509.jpg" alt="2" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/BASED.jpg" alt="3" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20240315_221811.jpg" alt="4" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230527_164122.jpg" alt="5" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/csm_Shannon2_MIT_Museum_86bb6cc755.jpg" alt="6" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231101_130504.jpg" alt="7" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231008_182945.jpg" alt="8" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/ea9da47bbea37a567640daeb0894f2d0.jpg" alt="9" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230526_170311.jpg" alt="10" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230813_140522.jpg" alt="11" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230419_225615.jpg" alt="12" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/SR71_crew.jpg" alt="13" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230714_020855.jpg" alt="14" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230902_143411.jpg" alt="15" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/089a7591-bbe0-4892-a696-3e1283df1116_1280x843.png" alt="16" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230810_150419.jpg" alt="17" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/l.JPG" alt="18" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/339e4826-83bc-47d1-aa6c-f9df1932ae23_1000x750.webp" alt="19" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230808_222706.jpg" alt="20" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20230813_093431.jpg" alt="21" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20240323_220150.jpg" alt="22" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231007_193501.jpg" alt="23" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231007_193524.jpg" alt="24" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div><div class="media-wrapper" data-astro-cid-nbc4lsjz> <img src="/images/hard/20231007_193505.jpg" alt="25" class="carousel-image" loading="eager" data-astro-cid-nbc4lsjz width="200" height="200" decoding="async"> </div> </div> </div>  </aside> </div> </body></html> 