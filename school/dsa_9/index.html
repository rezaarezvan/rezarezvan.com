<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"><meta property="og:site_name" content="rezvan"><title>DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees | rezvan</title>
  <meta property="og:title" content="DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees | rezvan"><meta property="og:description" content="">
  <meta property="og:type" content="blog">
  <meta property="og:link" content="https://rezvan.xyz/school/dsa_9/"><link rel="shortcut icon" type="image/png" href=https://rezvan.xyz//images/icon.png />
  <meta property="og:image" content="https://rezvan.xyz//images/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz//css/main.css" />    
</head>

<body>
  <div class="wrapper">
	<div class="content">
		<div class="header_main">
	<a href="https://rezvan.xyz/"><p class="header_title">rezvan</p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

	</a>
  <br>
  <nav id="main">
    
      <a href="/About/">About</a>
    
      <a href="/CV/">CV</a>
    
      <a href="/school/">School</a>
    
  </nav></div>

  <article><div class="title_wrapper">
			<h1 class="title">DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees</h1><p class="single_time">Dec 7, 2022</p></div>
		<section class="post">
			<p>In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!</p>
<h3 id="weighted-graphs">Weighted Graphs</h3>
<p>As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the <em>weights</em> on the edge.
These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they <em>could</em> be anything - although many algortihms only work for positive weights.</p>
<h3 id="spanning-trees">Spanning Trees</h3>
<p>A <em>spanning tree</em> of an <strong>undircted</strong> graph, $G$, is a <em>subgraph</em> $T$ such that:</p>
<ul>
<li>
<p>is <em>connected</em></p>
</li>
<li>
<p>is acyclic</p>
</li>
<li>
<p>includes all of the nodes</p>
</li>
</ul>
<p>The important thing here is that the graph is <strong>connected</strong>, which means we don&rsquo;t have any <em>lose</em> subgraphs, we must have one <strong>connected</strong> unit.</p>
<h3 id="minimum-spanning-tree-problem">Minimum Spanning Tree Problem</h3>
<p>Given a connected, undirected <strong>weighted</strong> graph, $G$ - what is the spanning tree with the <em>minimum total weight</em></p>
<p>This specific tree is called the <em>MST</em>, or <strong>M</strong>inimum <strong>S</strong>panning <strong>T</strong>ree. MSTs have a lot of applications in the real-world.</p>
<p>Let&rsquo;s begin to look at some algortihms which find these MSTs.</p>
<h3 id="greedy-algortihm">Greedy algortihm</h3>
<p>Before we jump into the actual algortimh, let&rsquo;s look at some fundamental properties first.</p>
<ul>
<li>
<p>A <em>cut</em> in a graph is a <em>partition</em> of its nodes into two (nonempty) sets.</p>
</li>
<li>
<p>A <em>crossing edge</em> <strong>connects</strong> a node in one set with a node in another set.</p>
</li>
</ul>
<p>With these two properies, there&rsquo;s a theroem which proves that:</p>
<ul>
<li>Given any cut, the crossing edge of <strong>minimal weight</strong> is in the MST</li>
</ul>
<p>Algortihm idea:</p>
<ul>
<li>
<p>Start with all edges  colored gray</p>
</li>
<li>
<p>Find <em>cut</em> with no black <em>crossing edges</em>; Color it&rsquo;s min-weight edge black</p>
</li>
<li>
<p>Repeat until $V - 1$ edges are black</p>
</li>
</ul>
<p>This isn&rsquo;t <em>quite</em> enough for an actual implementation since:</p>
<ul>
<li>
<p>How do we choose the cut?</p>
</li>
<li>
<p>How do we <em>actually</em> choose the edge with minimum weight after finding all crossing edges?</p>
</li>
</ul>
<p>We&rsquo;ll now cover some actual algortihms which implements this.</p>
<h3 id="overview">Overview</h3>
<p>We&rsquo;ll cover <em>Kruskal&rsquo;s algortihm</em> and <em>Prim&rsquo;s algoritmh</em></p>
<p>The basic idea for Kruskal&rsquo;s is:</p>
<ul>
<li>
<p>Consider edges in ascending order of weight</p>
</li>
<li>
<p>Add next edge to the MST, unless doing so would create a cycle</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>And for Prim&rsquo;s algortihm:</p>
<ul>
<li>
<p>Start with node 0 and greedily grow the MST</p>
</li>
<li>
<p>Add to the MST the minimum weight edge with exactly one endpoint in the MST</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>We&rsquo;ll begin with Kruskal&rsquo;s algoritm</p>
<h3 id="kruskals-algortimh">Kruskal&rsquo;s Algortimh</h3>
<p>So, as in the overview, kruskal&rsquo;s algortihm is quite simple in the idea - but the only implementation challenge is - how do we determine if we create a cycle?</p>
<p>But let&rsquo;s break it down. The algortimh stores several <em>disjoint</em> subtrees of the final MST - when we add a edge, it merges two of thes subtrees.</p>
<p>So testing for cyclicty, we need to check if two nodes appear in the same set!</p>
<p>There&rsquo;s actually a good (and well-known) data strucute for this exact problem, the <em>disjoint-set</em> data structure.
It supports merging and testing in $\mathcal{O}(log*\ n)$ time. (Note log* is an actual function, it&rsquo;s constant for all practical purpoes)</p>
<p>A pseudo-code implementation would be:</p>
<pre tabindex="0"><code>def kruskals(graph: Graph):
    result = []
    i, e = 0, 0
    graph = sort(graph)
    parent = []
    rank = []
    for vertex in range(graph.V):
        parent.append(vertex)
        rank.append(0)

    while e &lt; graph.V - 1:
        u, v, w = graph[i]
        i = i + 1
        x = graph.find(parent, u)
        y = graph.find(parent, v)
        if x != y:
            e = e + 1
            result.append([u, v, w])
            graph.apply_union(parent, rank, x, y)
</code></pre><h3 id="prims-algortim">Prim&rsquo;s algortim</h3>
<p>The challenge here is instead to find and remove the min weight edge with exactly one endpoint in T.</p>
<p>If try all edges we will ofcourse have a compleixty of $\mathcal{O}(E^2)$. So let&rsquo;s not do that :)</p>
<p>However, if we use a priority queue, we can get a $\mathcal{O}(E\ log(E))$. This is still the &rsquo;lazy&rsquo; version but let&rsquo;s look at the idea:</p>
<p>Maintain a PQ of edges having (at least) one endpoint in T:</p>
<ul>
<li>
<p>Remove the minimum edge to determine next edge $e = v - w$ to add to T.</p>
</li>
<li>
<p>Disregard $e$ if both endpoints $v$ and $w$ are marked (both in T).</p>
</li>
<li>
<p>Otherwise, let $w$ be the unmarked node (not in T).</p>
<ul>
<li>
<p>Add to the PQ, any outgoing edge from $w$ (assuming other endpoint is not in T).</p>
</li>
<li>
<p>Add $e$ to T and mark $w$.</p>
</li>
</ul>
</li>
</ul>
<p>The <em>eager</em> solution would be the same <em>but</em>:
Maintain a PQ of <strong>nodes</strong> (PQ has at most one entry per node) connected by an edge to T,
where priority of node $v$ = weight of shortest edge connecting $v$ to T.</p>
<ul>
<li>
<p>Remove the minimum node $v$ and add its associtaded edge $e = v - w$ to T.</p>
</li>
<li>
<p>Update PQ by considering all edges $e = v - u$ incident to $v$</p>
<ul>
<li>
<p>Ignore if $u$ is already in T.</p>
</li>
<li>
<p>Add $u$ to PQ if not already on it.</p>
</li>
<li>
<p><strong>Decrease priortiy</strong> of $u$ if $v - u$ becomes shortest edge connecting $u$ to T.</p>
</li>
</ul>
</li>
</ul>
<p>Note this requires an index PQ, which we haven&rsquo;t implemented or went over.</p>
<h3 id="complexity">Complexity</h3>
<p>The complexity of these algorithms are:</p>
<ul>
<li>
<p>Prim&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Kruskal&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
</ul>
<h3 id="shortest-path-algorithms">Shortest Path Algorithms</h3>
<p>Finding the shortest path in a given tree is a very complex problem which we will encounter in the real-world in many applications!</p>
<p>For example in: Map Navigation, Robot navigation, Urban traffic planning, Network routing (OSPF, BGP, RIP) etc.</p>
<h3 id="variants">Variants</h3>
<p>There are many different problems when it comes to shortest path problems - Do we want the shorest path between:</p>
<ul>
<li>
<p>Single source: One node, S, to <em>every other node</em></p>
</li>
<li>
<p>Single sink: From every node to one node, T.</p>
</li>
<li>
<p>Source-sink: From one node, S, to another node, T.</p>
</li>
<li>
<p>All pairs: Between all possible pairs of nodes.</p>
</li>
</ul>
<p>But we also need to weigh in, is there any restrictions on the edge weights?
Also if we have any restraints on cycles?</p>
<p>But with all this in mind - let&rsquo;s simplifiy - Shorest path from S to each node V <strong>exists</strong>.</p>
<p>If you remember, here&rsquo;s our ADT/API for directed graphs:</p>
<pre tabindex="0"><code>class Graph&lt;Vertices&gt;:
    // Adds an edge to the graph
    add_edge(e: Edge&lt;Vertices&gt;)

    // Removes an edge from the graph
    remove_edge(e: Edge&lt;Vertices&gt;)

    // Returns true if the edge is present in the graph, otherwise false
    contains_edge(e: Edge&lt;Vertices&gt;) -&gt; boolean

    // Returns all the edges which are connected with the vertices
    outgoing_edges(from: Vertices) -&gt; Collection&lt;Edge&lt;Vertices&gt;&gt;

    // Returns the number of vertices present in the graph
    n_vertices() -&gt; Int

    // Returns the number of edges present in the graph
    n_edges() -&gt; Int

class Edge&lt;Vertices&gt;:
    from   : Vertices
    to     : Vertices
    weight : float = 1.0
</code></pre><h3 id="single-source-shortest-paths">Single-source shortest paths</h3>
<p>The <em>single-source shortest path</em> problem or, SSSP for short. We want to find the shorest path from S to every other node.</p>
<p>The solution is spanning trees! However, it&rsquo;s not the MST but the so called <strong>shortest-paths tree</strong>, SPT.</p>
<p>In an SPT, the starting node $s$ is the root of the tree:</p>
<ul>
<li>
<p>How do we retrace the shorest path from and to any nodes?</p>
<ul>
<li>
<p>This consits of all ancestors of $t$, <strong>in reverse order</strong></p>
</li>
<li>
<p>Therefore, all information we need is the parent of every node in the SPT</p>
</li>
</ul>
</li>
<li>
<p>How do we determine the length of the shortest path from and to any nodes?</p>
<ul>
<li>
<p>This is the sum of the edge in that path</p>
</li>
<li>
<p>So eithe we need to store the edge weight, or the edge itself in the SPT</p>
</li>
</ul>
</li>
</ul>
<p>So a generalized generic graphsearch would be:</p>
<pre tabindex="0"><code>GraphSearch(start: V):
    put start in collection
    repeat until the colletion is empty:
        remove a vertex v
        if v is not visited:
            mark v as visited
            add all unvisited adjacent nodes
</code></pre><p>Now let&rsquo;s suppose this collection is a <strong>priorty queue</strong> - the weights are the <strong>total cost from s to v</strong></p>
<p>This is the so called Dijkstra&rsquo;s/uniform cost algorithm/search.</p>
<pre tabindex="0"><code>UCS(start: V):
    Q = PQ // Order by the cost from start
    Q.put(start)
    while is not Q.isempty():
        Q.remove_min()
        if v not in visited:
            visited.add(v) // mark as visited
            for unvisited vertex w adjacent to v:
                the cost from s to w = cost from s to v + the cost from v to w
                Q.put(w)
</code></pre><p>This is the so called <strong>single source</strong> algortihm, if we want a <strong>source-sink</strong> we just add:</p>
<pre tabindex="0"><code>UCS(start: V):
    Q = PQ // Order by the cost from start
    Q.put(start)
    while is not Q.isempty():
        Q.remove_min()
        if v is the goal, return the shortest path from s to v
        if v not in visited:
            visited.add(v) // mark as visited
            for unvisited vertex w adjacent to v:
                the cost from s to w = cost from s to v + the cost from v to w
                Q.put(w)
</code></pre><h3 id="shortest-path-in-a-dag">Shortest path in a DAG</h3>
<p>If we know the graph doesn&rsquo;t contain any cycles, this problem become <strong>a lot</strong> easier.</p>
<p>We use the same algortihm as a UCS - but we don&rsquo;t need a PQ and we can consider the nodes in a <em>toplogical order</em>.</p>
<p>This reduces the complexity to $\mathcal{O}(E)$.</p>
<h3 id="negative-weights">Negative weights</h3>
<p>Dijkstras/UCS won&rsquo;t work with negative edge weights - we really can&rsquo;t fix this, so instead we use the <em>Bellman-ford</em> algorithm.</p>
<h3 id="complexity-1">Complexity</h3>
<p>Here&rsquo;s a table of all the complexites:</p>
<ul>
<li>
<p>Topological Sort</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No directed cycles</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E + V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UCS/Dijkstras</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(E)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dijkstras eager</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(V))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Bellman-ford</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative <strong>cycles</strong></li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="summary">Summary</h3>
<p>So the summary really here is knowing when to use what depening on what you have.</p>
<p>So in the case we have nonnegative weights (which is the most often scenario),
we can almost alway use UCS/Dijkstras, since this is almost linear.</p>
<p>If we encounter a DAG, we should perform a Topological sort algorithm, since it&rsquo;s linear</p>
<p>Negative weights and negative cycles, If we have no negatice cycles - then Bellman-ford is the approach,
otherwise we can find <strong>some path</strong> via Bellman-ford.</p>

		</section>
  </article>
	</div>

	<footer><p class="footer_msg">Memento mori</p></footer>

  </div>
</body>
</html>
