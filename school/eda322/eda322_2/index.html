<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>rezvan | Part 2 - Binary Adders</title><link rel=icon type=image/png href=https://rezvan.xyz/images/icon.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="In this part we&rsquo;ll cover different kind of (binary) adders that digital circuits use. They&rsquo;re an essential part for all the arithmetic operations which are needed.
Full Adder The (1-bit) full adder is the simplest adder unit we can create.
It takes two input bits $a$ and $b$, with $c_{in}$ (carry in) - it outputs two bit signals, $c_{out}$ and $r$
If we use a truth table and find a boolean function for it, we find that: $$ r = a\ \bar{b}\ \bar{c_{in}} + \bar{a}\ b\ \bar{c_{in}} + a\ b\ c_{in} + \bar{a}\ \bar{b}\ c_{in} $$"><meta property="og:image" content="https://raw.githubusercontent.com/rezaarezvan/rezvan.xyz/main/images/icon.png"><meta property="og:url" content="https://rezvan.xyz/school/eda322/eda322_2/"><meta property="og:site_name" content="rezvan"><meta property="og:title" content="Part 2 - Binary Adders"><meta property="og:description" content="In this part we’ll cover different kind of (binary) adders that digital circuits use. They’re an essential part for all the arithmetic operations which are needed.
Full Adder The (1-bit) full adder is the simplest adder unit we can create.
It takes two input bits $a$ and $b$, with $c_{in}$ (carry in) - it outputs two bit signals, $c_{out}$ and $r$
If we use a truth table and find a boolean function for it, we find that: $$ r = a\ \bar{b}\ \bar{c_{in}} + \bar{a}\ b\ \bar{c_{in}} + a\ b\ c_{in} + \bar{a}\ \bar{b}\ c_{in} $$"><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="school"><meta property="article:published_time" content="2023-01-18T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-26T11:09:10+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Part 2 - Binary Adders"><meta name=twitter:description content="In this part we’ll cover different kind of (binary) adders that digital circuits use. They’re an essential part for all the arithmetic operations which are needed.
Full Adder The (1-bit) full adder is the simplest adder unit we can create.
It takes two input bits $a$ and $b$, with $c_{in}$ (carry in) - it outputs two bit signals, $c_{out}$ and $r$
If we use a truth table and find a boolean function for it, we find that: $$ r = a\ \bar{b}\ \bar{c_{in}} + \bar{a}\ b\ \bar{c_{in}} + a\ b\ c_{in} + \bar{a}\ \bar{b}\ c_{in} $$"><link rel=stylesheet href=https://rezvan.xyz/css/combined.min.51ec65976b416262d827f98c76ca037bf7aeea27590e3c120eac32afbfbc40ee.css integrity="sha256-Uexll2tBYmLYJ/mMdsoDe/eu6idZDjwSDqwyr7+8QO4="><link id=lightSyntaxStyle rel=stylesheet href=https://rezvan.xyz/css/light_syntax.min.d9e0828a4ff7f2d7317942062fc751fa487b2ac2c47b934ad082abd7d3ca6690.css integrity="sha256-2eCCik/38tcxeUIGL8dR+kh7KsLEe5NK0IKr19PKZpA="><link id=darkModeStyle rel=stylesheet href=https://rezvan.xyz/css/dark.min.49ad20f2859f81550f852c48875ca9e72e4267459ed6fe82fc9b4f3cf7fdc4e8.css integrity="sha256-Sa0g8oWfgVUPhSxIh1yp5y5CZ0We1v6C/JtPPPf9xOg=" disabled><link id=darkSyntaxStyle rel=stylesheet href=https://rezvan.xyz/css/dark_syntax.min.1a878f3d8fb43359bd3b44bc70c4074f682f11066c6537bf6248b696cbe56586.css integrity="sha256-GoePPY+0M1m9O0S8cMQHT2gvEQZsZTe/Yki2lsvlZYY=" disabled><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><nav id=site-navbar><div class=navbar-content><a href=https://rezvan.xyz/ class=logo>rezvan.xyz</a><div class=navbar-links><a href=/principles class=nav-link><span class=bracket>[</span>principles<span class=bracket>]</span></a>
<a href=/cv class=nav-link><span class=bracket>[</span>cv<span class=bracket>]</span></a>
<a href=/posts class=nav-link><span class=bracket>[</span>posts<span class=bracket>]</span></a>
<a href=/school class=nav-link><span class=bracket>[</span>school<span class=bracket>]</span></a></div><div class=theme-toggle><span id=dark-mode-toggle onclick=toggleTheme() aria-label="Toggle theme">○
</span><script src=https://rezvan.xyz/js/themetoggle.js></script></div></div></nav></header><main><article><div class=title><h1>Part 2 - Binary Adders</h1><div class=meta>Posted on Jan 18, 2023</div><div class=meta>(Last updated: May 26, 2024)</div></div><section class=body><p>In this part we&rsquo;ll cover different kind of (binary) adders that digital circuits use.
They&rsquo;re an essential part for all the arithmetic operations which are needed.</p><h3 id=full-adder>Full Adder</h3><p>The (1-bit) full adder is the simplest adder unit we can create.</p><p>It takes two input bits $a$ and $b$, with $c_{in}$ (carry in) - it outputs two bit signals, $c_{out}$ and $r$</p><p>If we use a truth table and find a boolean function for it, we find that:
$$
r = a\ \bar{b}\ \bar{c_{in}} + \bar{a}\ b\ \bar{c_{in}} + a\ b\ c_{in} + \bar{a}\ \bar{b}\ c_{in}
$$</p><p>Which we can simply this to:
$$
c_{in}\ \oplus (a\ \oplus\ b)
$$</p><p>For $c_{out}$ :
$$
a\ \bar{b}\ c_{in} + \bar{a}\ b\ c_{in} + a\ b
$$</p><p>Which simplifies to:
$$
c_{in}\ (a \oplus\ b) + a\ b
$$</p><h3 id=ripple-carry-adder>Ripple Carry Adder</h3><p>So the full adder is the building block for adding two bit inputs. But that isn&rsquo;t of much use, we usually use bigger numbers.
So chaining full adders to each other becomes, for example, a 4-bit adder. For adding 4 bit numbers.</p><p>This is called a Ripple Carry Adder</p><p>For each Full Adder (FA) cell we have:
$$
r_i = a_i\ \oplus\ b_i\ \oplus\ c_{in} \newline
c_{out} = c_{in}\ (a_i \oplus\ b_i) + a_i\ b_i
$$</p><h4 id=subtraction>Subtraction</h4><p>Subtraction, mathematically is just:
$$
a + b = a + (-b)
$$</p><p>But how do we transform an integer represented in binary as negative?</p><ol><li>Complement/Negate B</li><li>Add 1</li></ol><p>Or we can write it as:
$$
a + b = a + (\bar{b} + 1)
$$</p><p>One problem that occurs with the ripple adder is that, it&rsquo;s an inherently slow design. $r_7$ needs to wait for $c_7$.</p><p>Which makes the time: $\mathcal{O}(n)$</p><h3 id=carry-select-adder>Carry Select Adder</h3><p>While the Ripple Carry Adder is simple, it&rsquo;s quite slow. A faster type of adder is the carry select adder.
It consits of ripple adders and a multiplexer (MUX). You can prove with some examples and some math that:</p><p>The time it takes for a carry select adder is $\mathcal{O}(\sqrt{n})$</p><h3 id=carry-look-ahead-adders>Carry Look-ahead Adders</h3><p>In general, for addition, best we can achieve is $\mathcal{O}(log(n))$, but we need to think in terms of trees.</p><p>We introduce two new signals. Carry &lsquo;<strong>p</strong>ropagate&rsquo; and carry &lsquo;<strong>g</strong>enerate&rsquo;.
$$
p_i = a_i\ \oplus\ b_i \newline
g_i = a_i\ b_i
$$</p><p>We propagate if, one of the 2 inputs is &lsquo;1&rsquo;. Then <em>propagate</em> the carry you received from the previous stage.
If both inputs are 1, then no matter what carry-in you received, generate a carry (out).</p><p>With this we can define:
$$
c_{i + 1} = g_i + p_i\ c_i \newline
r_i = p_i\ \oplus\ c_i
$$</p><h3 id=summary>Summary</h3><p>This was quite a short part, but adders are quite a simple, yet powerful concept.</p></section></article><nav class=navigation><div class="nav-item previous"><a href=/school/eda322/eda322/ title="Previous: Part 1 - Introduction & Boolean Algebra">&larr; Previous</a></div><div class="nav-item next"><a href=/school/eda322/eda322_3/ title="Next: Part 3 - Sequential Circuits">Next &rarr;</a></div></nav></main><footer id=site-footer><div class=social-links><a href=https://github.com/rezaarezvan title class=social-link><span class=bracket>[</span>github<span class=bracket>]</span></a>
<a href=https://x.com/rzvan__/ title class=social-link><span class=bracket>[</span>x<span class=bracket>]</span></a></div><div class=footer-marquee><div class=footer-marquee__content><span class=footer-marquee__item>memento mori • amor fati • sic parvis magna • per aspera ad astra</span>
<span class=footer-marquee__item>memento mori • amor fati • sic parvis magna • per aspera ad astra</span></div></div></footer></div></body></html>