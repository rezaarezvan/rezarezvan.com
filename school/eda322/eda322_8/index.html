<!doctype html><html><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><title>rezvan | Part 8 - Interfaces and Memory</title><link rel=icon type=image/png href=https://rezvan.xyz/images/icon.png><meta name=viewport content="width=device-width,initial-scale=1">
<meta name=description content="In this part we&rsquo;ll cover interfaces, interconnects as well as memory.
Interface timing In digital circuits, we often want to send data, from a sender, to a receiver.
How can we achieve this data passing from one module to another?
The answer is:
Open loop Flow Control Serialized In an open loop, we either have so that it&rsquo;s always &ldquo;valid&rdquo; to send data, or periodically.
In flow control, as the name suggests, the data-flow is controlled."><meta property="og:image" content="https://raw.githubusercontent.com/rezaarezvan/rezvan.xyz/main/images/icon.png"><meta property="og:url" content="https://rezvan.xyz/school/eda322/eda322_8/"><meta property="og:site_name" content="rezvan"><meta property="og:title" content="Part 8 - Interfaces and Memory"><meta property="og:description" content="In this part we’ll cover interfaces, interconnects as well as memory.
Interface timing In digital circuits, we often want to send data, from a sender, to a receiver.
How can we achieve this data passing from one module to another?
The answer is:
Open loop Flow Control Serialized In an open loop, we either have so that it’s always “valid” to send data, or periodically.
In flow control, as the name suggests, the data-flow is controlled."><meta property="og:locale" content="en_us"><meta property="og:type" content="article"><meta property="article:section" content="school"><meta property="article:published_time" content="2023-02-19T00:00:00+00:00"><meta property="article:modified_time" content="2024-05-26T11:09:10+02:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="Part 8 - Interfaces and Memory"><meta name=twitter:description content="In this part we’ll cover interfaces, interconnects as well as memory.
Interface timing In digital circuits, we often want to send data, from a sender, to a receiver.
How can we achieve this data passing from one module to another?
The answer is:
Open loop Flow Control Serialized In an open loop, we either have so that it’s always “valid” to send data, or periodically.
In flow control, as the name suggests, the data-flow is controlled."><link rel=stylesheet href=https://rezvan.xyz/css/combined.min.51ec65976b416262d827f98c76ca037bf7aeea27590e3c120eac32afbfbc40ee.css integrity="sha256-Uexll2tBYmLYJ/mMdsoDe/eu6idZDjwSDqwyr7+8QO4="><link id=lightSyntaxStyle rel=stylesheet href=https://rezvan.xyz/css/light_syntax.min.d9e0828a4ff7f2d7317942062fc751fa487b2ac2c47b934ad082abd7d3ca6690.css integrity="sha256-2eCCik/38tcxeUIGL8dR+kh7KsLEe5NK0IKr19PKZpA="><link id=darkModeStyle rel=stylesheet href=https://rezvan.xyz/css/dark.min.49ad20f2859f81550f852c48875ca9e72e4267459ed6fe82fc9b4f3cf7fdc4e8.css integrity="sha256-Sa0g8oWfgVUPhSxIh1yp5y5CZ0We1v6C/JtPPPf9xOg=" disabled><link id=darkSyntaxStyle rel=stylesheet href=https://rezvan.xyz/css/dark_syntax.min.1a878f3d8fb43359bd3b44bc70c4074f682f11066c6537bf6248b696cbe56586.css integrity="sha256-GoePPY+0M1m9O0S8cMQHT2gvEQZsZTe/Yki2lsvlZYY=" disabled><script type=text/javascript src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script type=text/x-mathjax-config>
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js></script><script defer src=https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js onload=renderMathInElement(document.body)></script><script>document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})})</script></head><body><div class=content><header><nav id=site-navbar><div class=navbar-content><a href=https://rezvan.xyz/ class=logo>rezvan.xyz</a><div class=navbar-links><a href=/principles class=nav-link><span class=bracket>[</span>principles<span class=bracket>]</span></a>
<a href=/cv class=nav-link><span class=bracket>[</span>cv<span class=bracket>]</span></a>
<a href=/posts class=nav-link><span class=bracket>[</span>posts<span class=bracket>]</span></a>
<a href=/school class=nav-link><span class=bracket>[</span>school<span class=bracket>]</span></a></div><div class=theme-toggle><span id=dark-mode-toggle onclick=toggleTheme() aria-label="Toggle theme">○
</span><script src=https://rezvan.xyz/js/themetoggle.js></script></div></div></nav></header><main><article><div class=title><h1>Part 8 - Interfaces and Memory</h1><div class=meta>Posted on Feb 19, 2023</div><div class=meta>(Last updated: May 26, 2024)</div></div><section class=body><p>In this part we&rsquo;ll cover interfaces, interconnects as well as memory.</p><h3 id=interface-timing>Interface timing</h3><p>In digital circuits, we often want to send data, from a sender, to a receiver.</p><p>How can we achieve this data passing from one module to another?</p><p>The answer is:</p><ul><li>Open loop</li><li>Flow Control</li><li>Serialized</li></ul><p>In an open loop, we either have so that it&rsquo;s always &ldquo;valid&rdquo; to send data, or periodically.</p><p>In flow control, as the name suggests, the data-flow is controlled. The sender needs to output a &ldquo;valid&rdquo; signal,
and the receiver needs to send a &ldquo;ready&rdquo; signal.</p><p>Then depending on what kind of control we have, either Push flow or Pull flow.</p><ul><li>Push flow<ul><li>Assume receiver always ready</li></ul></li><li>Pull flow<ul><li>Assume sender always has valid data</li></ul></li></ul><p>When these signals align in a clock pulse, we can send the data.</p><p>Serialization, is the idea that we split up the data into smaller chunks.
When the <em>frame</em> signal is active, it means a serial frame is about to start, or in layman terms, the beginning of a new data pack.</p><p>Flow control can be at either frame level, or word level.</p><h3 id=interconnects>Interconnects</h3><p>In circuits, there is also a need that clients can communicate with each other - how do we achieve this?</p><p>The common solution is using a so-called bus. The bus is a shared resource which clients can communicate with each other.</p><p>But there are other solutions:</p><ul><li>Crossbar switch</li><li>Interconnection networks</li></ul><p>There are a lot of different factors that impact what solution you pick:</p><ul><li>Cost</li><li>Scalability</li><li># of connections</li></ul><p>Are just a few.</p><h3 id=memory>Memory</h3><p>We&rsquo;ve already seen and worked with memory, so let&rsquo;s refresh what we&rsquo;ve covered:</p><p>Uses:</p><ul><li>Data & program storage</li><li>General purpose registers</li><li>Buffering</li><li>Lookup tables</li><li>Combinational Logic implementation</li><li>Whenever a large collection of state elements is required.</li></ul><p>Types:</p><ul><li>RAM - random access memory</li><li>ROM - read only memory</li><li>EPROM, FLASH - electrically programmable read only memory</li></ul><p>What we usually mean by memory though is, many addressable fixed size locations.</p><p>$n$ bits allow the addressing of $2^n$ memory locations.
Example: 24 bits can address $2^{24}$ = 16,777,216 locations</p><p>If each location holds 1 byte (= 8 bits) then the memory is 16 MB.
If each location holds one word (32 bits = 4 bytes) then it is 64 MB.</p><p>Computers are either <em>byte</em> or <em>word</em> addressable, meaning that each memory location holds either 8 bits (1 byte),
or a full standard <em>word</em> for that computer architecture.</p><ul><li>Each bit<ul><li>Is a gated D-latch</li></ul></li><li>Each location<ul><li>Consists of $w$ bits, either $w = 8$ or $w =$ max width</li></ul></li><li>Addressing<ul><li>$n$ locations means $log_2(n)$ address bits</li><li>Decoder circuit translates address into 1 of n locations</li></ul></li></ul><p>Now, let&rsquo;s define some words and terms that we encounter often while working with circuits:</p><ul><li>Bandwidth:<ul><li>Total amount of data across a device or across an interface,
per unit time (usually Bytes/sec)</li></ul></li><li>Latency:<ul><li>A measure of the time from a request for a data transfer until the data is received.</li></ul></li><li>Memory Interfaces for Accessing Data<ul><li>Asynchronous (unclocked):<ul><li>A change in the address results in data appearing</li></ul></li><li>Synchronous (clocked):<ul><li>A change in address, followed by an edge on CLK results in data appearing.
Sometimes, multiple requests may be outstanding.</li></ul></li></ul></li><li>Volatile:<ul><li>Looses its state when the power goes off. (the opposite: non-volatile)</li></ul></li></ul><p>Also, just to list out the volatile vs non-volatile list:</p><ul><li>Volatile:<ul><li>Random Access Memory (RAM):<ul><li>DRAM &ldquo;dynamic&rdquo;</li><li>SRAM &ldquo;static&rdquo;</li></ul></li></ul></li><li>Non-volatile:<ul><li>Read Only Memory (ROM):<ul><li>Mask ROM &ldquo;mask programmable&rdquo;</li><li>EPROM &ldquo;electrically programmable&rdquo;</li><li>EEPROM &ldquo;erasable electrically programmable&rdquo;</li><li>FLASH memory - similar to EEPROM with programmer integrated on chip</li></ul></li></ul></li></ul><p>Memory blocks can be (and often are) used to implement combinational logic functions.</p><p>Examples:</p><ul><li>LUTs in FPGAs</li><li>1Mbit x 8 EPROM can implement 8 independent functions each of $log_2(1M) = 20$ inputs.</li><li>The decoder part of a memory block can be considered a “minterm generator”.</li><li>The cell array part of a memory block can be considered an OR function over a subset of rows.</li></ul></section></article><nav class=navigation><div class="nav-item previous"><a href=/school/eda322/eda322_7/ title="Previous: Part 7 - Timing, delay & power">&larr; Previous</a></div><div class="nav-item next"><a href=/school/eda322/eda322_9/ title="Next: Part 9 - Testing">Next &rarr;</a></div></nav></main><footer id=site-footer><div class=social-links><a href=https://github.com/rezaarezvan title class=social-link><span class=bracket>[</span>github<span class=bracket>]</span></a>
<a href=https://x.com/rzvan__/ title class=social-link><span class=bracket>[</span>x<span class=bracket>]</span></a></div><div class=footer-marquee><div class=footer-marquee__content><span class=footer-marquee__item>memento mori • amor fati • sic parvis magna • per aspera ad astra</span>
<span class=footer-marquee__item>memento mori • amor fati • sic parvis magna • per aspera ad astra</span></div></div></footer></div></body></html>