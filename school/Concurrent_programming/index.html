<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>Concurrent Programming: Part 1 - Introduction - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Concurrency, multi-threading, parallelism. These are all big terms thrown around in the computer-science world. For an outsider it can be quite confusing what these exactly are and how they differ from each other. In this series we&rsquo;ll cover and dive into concurrency and its applications.
Let&rsquo;s start by defining what we mean by concurrency.
Introduction Concurrency, in its very definition is, the fact of two or more events or circumstances happening or existing at the same time." />
	<meta property="og:image" content="https://raw.githubusercontent.com/rezaarezvan/rezvan.xyz/main/images/icon.png"/>
	<meta property="og:title" content="Concurrent Programming: Part 1 - Introduction" />
<meta property="og:description" content="Concurrency, multi-threading, parallelism. These are all big terms thrown around in the computer-science world. For an outsider it can be quite confusing what these exactly are and how they differ from each other. In this series we&rsquo;ll cover and dive into concurrency and its applications.
Let&rsquo;s start by defining what we mean by concurrency.
Introduction Concurrency, in its very definition is, the fact of two or more events or circumstances happening or existing at the same time." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/Concurrent_programming/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2023-01-16T00:00:00+00:00" />
<meta property="article:modified_time" content="2023-01-16T00:00:00+00:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Concurrent Programming: Part 1 - Introduction"/>
<meta name="twitter:description" content="Concurrency, multi-threading, parallelism. These are all big terms thrown around in the computer-science world. For an outsider it can be quite confusing what these exactly are and how they differ from each other. In this series we&rsquo;ll cover and dive into concurrency and its applications.
Let&rsquo;s start by defining what we mean by concurrency.
Introduction Concurrency, in its very definition is, the fact of two or more events or circumstances happening or existing at the same time."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>

		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>

		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	

	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">Concurrent Programming: Part 1 - Introduction</h1>
			<div class="meta">Posted on Jan 16, 2023</div>
		</div>
		

		<section class="body">
			<p>Concurrency, multi-threading, parallelism. These are all big terms thrown around in the computer-science world.
For an outsider it can be quite confusing what these exactly are and how they differ from each other.
In this series we&rsquo;ll cover and dive into concurrency and its applications.</p>
<p>Let&rsquo;s start by defining what we mean by concurrency.</p>
<h1 id="introduction">Introduction</h1>
<p>Concurrency, in its very definition is, the fact of two or more events or circumstances happening or existing at the same time.</p>
<p>If we apply this to computer-science, we can see that&rsquo;s a very natural thing.
Executing two or more events at the same time is something we would love. The only problem is that, we canno&rsquo;t garantuee saftety.</p>
<p>Let&rsquo;s look at an example.</p>
<h4 id="simple-example">Simple example</h4>
<p>Let&rsquo;s look at a Java program which increments a simple counter:</p>
<p>In a sequential (non-concurrent) program this would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class Counter {
</span></span><span style="display:flex;"><span>    private int counter = 0;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public void run() {
</span></span><span style="display:flex;"><span>        int cnt = counter;
</span></span><span style="display:flex;"><span>        counter = cnt + 1;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    public int counter() {
</span></span><span style="display:flex;"><span>        return counter;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class SequentialCount {
</span></span><span style="display:flex;"><span>    public static void main(String[] args) {
</span></span><span style="display:flex;"><span>        Counter counter = new Counter();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        counter.run();
</span></span><span style="display:flex;"><span>        counter.run();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.out.println(counter.counter());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This program will <strong>always</strong> print out 2. There&rsquo;s no doubt in that.</p>
<p>If we now introduce concurrency, we will now run these at the same time, or in <em>parallel</em>, do not confuse this with parallelism.
They&rsquo;re not the same.</p>
<p>So the idea is that we run the block of code we have on <strong>independent</strong> execution units (so-called threads in Java).</p>
<p>Specifically, in Java, these threads will run on the <strong>same</strong> <code>counter</code> object. So they will share the global variable called <code>counter</code>.</p>
<p>We, the programmers, don&rsquo;t have any control in what order these threads will be executed, this is the <em>schedulers</em> job.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class ConcurrentCounter extends Counter implements Runnable {
</span></span><span style="display:flex;"><span>    /*
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    threads will execute run()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    */
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>public class ConcurrentCount {
</span></span><span style="display:flex;"><span>    public static void main(String[] args) {
</span></span><span style="display:flex;"><span>        ConcurrentCounter counter = new ConcurrentCounter();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        Thread t = new Thread(counter);
</span></span><span style="display:flex;"><span>        Thread u = new Thread(counter);
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        t.start();
</span></span><span style="display:flex;"><span>        u.start();
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        try { t.join(); u.join(); }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        catch (InterruptedException e) {
</span></span><span style="display:flex;"><span>            System.out.println(&#34;Interrupted!&#34;);
</span></span><span style="display:flex;"><span>        }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        System.out.println(counter.counter());
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>If we compile and run this, we necessarily won&rsquo;t always get the expected answer, 2. In some (rare) cases, we will get the answer 1.</p>
<p>But if there is a risk for failure, why would we even want to write concurrent programs? We&rsquo;ll the answer can be described in 3 keypoints.</p>
<ul>
<li>
<p>Abstraction</p>
<ul>
<li>By seperating tasks and making sure we don&rsquo;t have to worry about them. For example downloading multiple files at once.</li>
</ul>
</li>
<li>
<p>Responsiveness</p>
<ul>
<li>We can provide a responsive, user interface by writing concurrent programs. For example, browsing youtube while downloading files.</li>
</ul>
</li>
<li>
<p>Performance</p>
<ul>
<li>Splitting complex tasks, into smaller, subtasks will greatly increase the pure computer performance.</li>
</ul>
</li>
</ul>
<p>Let&rsquo;s also make one thing clear. Concurrency vs Parallelism. Concurrency is &ldquo;logical parallelism&rdquo; and parallelism is &ldquo;phyisical parallelism&rdquo; and parallelism is &ldquo;phyisical parallelism&rdquo;.</p>
<p>Paralleism is about taking advantage of redundant hardware.</p>
<p>Today, concurrency is everywhere, all operating-systems are based on concurrency and making sure things are speedy.</p>
<p>But these speedups aren&rsquo;t always free.</p>
<h1 id="amdahls-law">Amdahl&rsquo;s law</h1>
<p>Amdahl&rsquo;s law gives us an equation that, given $n$ processors (these are not necessarily physical processors but can be execution units) that can run in parallel.</p>
<p>What&rsquo;s the maximum speedup we can gain?
$$
\text{max speedup} = \frac{1}{(1 - p) + \frac{p}{n}}
$$</p>
<p>$p$ is the % of the program that is being run in parallel. By plugging in some arbitrary values we find quickly that, after a certain threshold, more parallelism doesn&rsquo;t help.</p>
<h1 id="terminology">Terminology</h1>
<p>Now that we&rsquo;ve looked at the basics, let&rsquo;s look at some important terminology.</p>
<p>A process is an <strong>independent unit of execution</strong>. It&rsquo;s an abstraction of a running sequential program.
This is what the operating system <strong>schedules</strong>, which <strong>process</strong> to run.</p>
<p>The <strong>scheduler</strong> is the system unit that is in charge of the <strong>process state</strong>.
There are 3 states in which a process can be in:</p>
<ul>
<li>
<p>Ready</p>
<ul>
<li>Ready to be executed, but not allocated to any execution unit.</li>
</ul>
</li>
<li>
<p>Blocked</p>
<ul>
<li>Waiting for an event to happen</li>
</ul>
</li>
<li>
<p>Running</p>
<ul>
<li>Running on some execution unit</li>
</ul>
</li>
</ul>
<p>A <strong>thread</strong> is a <em>lightweight process</em>. The actual diffrence between a process and a thread is fuzzy and implementation specific.</p>
<p>Our definition will be:</p>
<p>Process: Executing units that do <strong>not</strong> share memory.<br>
Threads: Executing units that share memory.</p>
<p>An important thing to remember is that, threads (or execution units that share memory) <strong>communicate</strong> via memory.
While processes (or execution units that do not share memory) send real messages between the processes themselves.</p>
<p>These models are called, <strong>shared memory</strong> and <strong>distributed memory</strong>.</p>
<h1 id="traces">Traces</h1>
<p>A trace is an abstraction of concrete executions, these executions being:</p>
<ul>
<li>
<p>Atomic/linearized</p>
<ul>
<li>The effects of each thread appear as if they happened instantaneously.</li>
</ul>
</li>
<li>
<p>Complete</p>
<ul>
<li>The trace includes all intermediate atomic states.</li>
</ul>
</li>
<li>
<p>Interleaved</p>
<ul>
<li>The trace is an interleaving of each thread’s linear trace (in particular, no simultaneity).</li>
</ul>
</li>
</ul>
<p>What this means is, the sequence of <em>states</em> gives an execution <strong>trace</strong> of the concurrent program.</p>
<p>So different <em>traces</em> lead to different results in the program.</p>
<h1 id="conclusion">Conclusion</h1>
<p>This concludes this first part in this series, we&rsquo;ve only looked at the pure basics and terminology here.
In the next part we&rsquo;ll cover races, locks and semaphores, which are the first real concurrency principles we&rsquo;ll look at.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Concurrent-Programming">Concurrent Programming</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
