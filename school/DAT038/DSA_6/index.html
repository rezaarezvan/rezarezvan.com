<!DOCTYPE html>
<html><head lang="en">
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"><title>rezvan | DSA: Part 6 - Trees</title><link rel="icon" type="image/png" href="/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science.
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node. Each node can have so-called child nodes, and these children can have their own child nodes and so on." />
    <meta property="og:image" content="https://raw.githubusercontent.com/rezaarezvan/rezvan.xyz/main/images/icon.png" />
    <meta property="og:title" content="DSA: Part 6 - Trees" />
<meta property="og:description" content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science.
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node. Each node can have so-called child nodes, and these children can have their own child nodes and so on." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DAT038/DSA_6/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-11-30T18:08:48+01:00" />
<meta property="article:modified_time" content="2022-11-30T18:08:48+01:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="DSA: Part 6 - Trees"/>
<meta name="twitter:description" content="In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science.
Trees The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A hierarchical data structure built up from nodes&rdquo;.
So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the root node is at the top of the tree.
In any tree there&rsquo;s always one root node. Each node can have so-called child nodes, and these children can have their own child nodes and so on."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

    
    <link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.55ceafd1ab15172b8770201b55c83270fac8611fcdae31fccb3a7fd94ac6da6e.css" />
    <link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b95ac7b1169ab6755ef14c75e8e49c983d2d56c40ee0c3d69d357d42339b5e31.css"  disabled />
    

    
    
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>

    
    <script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
    

    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
    

    
</head>
<body>
    <div class="content"><header>
    <div class="main">
        <a href="https://rezvan.xyz/">rezvan</a>
    </div>
    <nav id="site-navbar">
        
        <a href="/">home</a>
        
        <a href="/about">about</a>
        
        <a href="/principles">principles</a>
        
        <a href="/contact">contact</a>
        
        <a href="/cv">cv</a>
        
        <a href="/school">school</a>
        
        <a href="/tags">tags</a>
        
        | <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
        <script src="https://rezvan.xyz/js/themetoggle.js"></script>
        
    </nav>
</header>

<main>
    <article>
        <div class="title">
            <h1 class="title">DSA: Part 6 - Trees</h1>
            <div class="meta">Posted on Nov 30, 2022</div>
        </div>
        

        <section class="body">
            <p>In this part we&rsquo;ll cover so called &rsquo;trees&rsquo; in computer science.</p>
<h3 id="trees">Trees</h3>
<p>The formal definition of a &rsquo;tree&rsquo; is: &ldquo;A <em>hierarchical</em> data structure built up from <em>nodes</em>&rdquo;.</p>
<p>So unlike a real tree which has its root at the bottom - the computer scientist flipped it - the <em>root</em> node is at the top of the tree.</p>
<p>In any tree there&rsquo;s always <strong>one</strong> <em>root</em> node. Each node can have so-called <em>child</em> nodes, and these <em>children</em> can have their own child nodes and so on.</p>
<p>Therefore, all nodes - expect the root node - <strong>must</strong> have exactly <strong>one</strong> parent node.</p>
<h4 id="tree-rules">Tree rules</h4>
<p>I&rsquo;ve already stated some of the &lsquo;rules&rsquo; of a tree, but generally we have 3 rules that makes a collection of nodes a tree.</p>
<ul>
<li>
<p>Each node must have exactly one <strong>unique</strong> parent node - expect the root node.</p>
</li>
<li>
<p>There must exactly be <strong>one</strong> root node.</p>
</li>
<li>
<p>If the first and second rules are followed - then no &lsquo;cycles&rsquo; will appear.</p>
</li>
</ul>
<h3 id="recursive-tree">Recursive Tree</h3>
<p>Trees can also be defined recursively: &ldquo;A tree consists of a root node together with its <strong>subtrees</strong>, which do not share any common nodes&rdquo;.</p>
<p>This means, child node (of the root node) $\rightarrow$ root of subtree. This also means that a tree can be empty (no nodes) - for some applications this is needed.</p>
<h3 id="programming-with-trees">Programming with trees</h3>
<p>Now that we have some basic knowledge about trees - let&rsquo;s try to represent them with code. A very natural representation would be a directory <strong>tree</strong>.</p>
<pre tabindex="0"><code>class Tree:
    name: string
    size: int

    children: list[Tree]
</code></pre><p>If we now want to compute the total size of a directory (folder) we would need to:</p>
<pre tabindex="0"><code>def total(tree: Tree) -&gt; int:
    n: int = tree.bytes
    for c in tree.children:
        n += total(c)
    return n
</code></pre><p>And we can see that recursion and trees go hand in hand. Now let&rsquo;s see how we can traverse the tree.</p>
<p>There are main methods for traversing - <strong>Pre-order</strong> traversal - meaning you process each node <strong>before</strong> visiting its children.
As well as <strong>Post-order</strong> traversal - meaning you process each node <strong>after</strong> visiting its children.</p>
<h3 id="binary-trees">Binary Trees</h3>
<p>Often we can use a special kind of tree called &lsquo;Binary tree&rsquo; - a binary tree is a tree where each node has exactly <strong>two</strong> children.</p>
<p>As we said before, these children can be represented as a null-value if they&rsquo;re &lsquo;missing&rsquo;. We call these children nodes the &rsquo;left&rsquo; and &lsquo;right&rsquo; nodes or subtrees.</p>
<p>Some terminology common used for trees are, <code>size</code> <code>height</code>, and <code>level</code>.
Size is the number of nodes in the (sub)tree - height, is the number of <code>levels</code> in the tree. Level is the distance from node to the root.</p>
<h3 id="binary-search-trees">Binary Search Trees</h3>
<p>Binary search trees or BSTs is a kind of binary tree but with some extra conditions:</p>
<ul>
<li>
<p>Each node has a <em>key</em></p>
</li>
<li>
<p>The node&rsquo;s key is smaller than all the keys in its right subtree</p>
</li>
<li>
<p>The node&rsquo;s key is greater than all the keys in its left subtree</p>
</li>
</ul>
<p>Or differently phrased, everything in its left subtree is less than the root, everything to the right is greater than the root.</p>
<p>With these rules searching becomes really, really effective and natural. We just compare our key to each node&rsquo;s key and see if we traverse to the right or left.</p>
<p>If we ever hit a &rsquo;null&rsquo; node, we can also say that the key we&rsquo;re searching for doesn&rsquo;t exist in this key.</p>
<p>So let us implement a map using BSTs!</p>
<pre tabindex="0"><code>class BSTMap[Key, Value]:
    class Node:
        key: Key
        value: Value

        left, right: Node

    root: Node

def get(key: Key) -&gt; Value:
    return get(key, root)

def put(key : Key, val : Value):
    root = put(key, val, root)

def get(key, node) -&gt; Value:
    if node is None
        return None

    if key &lt; node.key
        return get(key, node.left)

    if key &gt; node.key
        return get(key, node.right)

    else:
        return node.value

def put(key, val, node):
    if node is None
        return Node(key = key, value = val, left = None, right = None)

    elif key &lt; node.key:
        node.left = put(key, value, node.left)

    elif key &gt; node.key:
        node.right = put(key, value, node.right)

    else:
        node.value = value

    return node
</code></pre><h3 id="fin-maxmin-value-in-bst">Fin max/min value in BST</h3>
<p>To find the max/min value in BST we just repeatedly go right/left until we hit a null node. Real simple!</p>
<p>Or in code:</p>
<pre tabindex="0"><code>
def get_max(tree: BST):
    c_node = tree.root

    while c_node != None:
        c_node = c_node.right

    return c_node.value

def get_min(tree: BST):
    c_node = tree.root

    while c_node != None:
        c_node = c_node.left

    return c_node.value
</code></pre><h3 id="sorting-a-bst">Sorting a BST</h3>
<p>Sometimes we might want to print/store a BST in ascending order - the way to do this of course is via recursion!</p>
<p>This is also known as <em>in order</em> traversal - we print the left subtree, print the root then print the right subtree - we do this recursively.</p>
<p>So for example:</p>
<pre tabindex="0"><code>def print_sorted(node: Node):
    if node is None:
        return

    print_sorted(node.left)
    print(node.key)
    print_sorted(node.right)
</code></pre><p>We can also do a more general case - we make an <em>iterator</em> for the keys in the tree - by doing an in order traversal and store the keys in a dynamic array.</p>
<pre tabindex="0"><code>def keys() -&gt; list[Key]
    list = []
    inorder(root, list)
    return list

def inorder(node: Node, list: list[Key]):
    if node is None:
        return

    inorder(node.left, list)
    list.add(node.key)
    inorder(node.right, list)

...

for key in BST.keys():
    print(key)
</code></pre><h3 id="deletion">Deletion</h3>
<p>Deletion can be quite tricky in trees, and especially in BSTs - we can&rsquo;t just remove a node however, there are some rules.</p>
<h4 id="deleting-a-leaf">Deleting a leaf</h4>
<p>A so-called leaf is a node with no children (or visually the leafs are the bottom nodes). These are fine to remove without any corrections.</p>
<p>Since we just remove that child, with no children there won&rsquo;t be any problems.</p>
<h4 id="deleting-a-node-with-one-child">Deleting a node with one child</h4>
<p>Now, in the case we want to delete a node with exactly one child, it&rsquo;s still quite trivial. Since that node only has one child, we can just replace the deleted node with its child. It doesn&rsquo;t affect the tree as a whole.</p>
<h4 id="deleting-a-node-with-two-children">Deleting a node with two children</h4>
<p>This is where it becomes tricky, but if we take a step back one think about it, we need to find a node that upholds the requirements of,
everything to the left should be smaller and everything to the right must be greater. If we think what candidates fulfill this requirement - it becomes clear two nodes are good candidates.</p>
<p>The <em>greatest</em> (rightmost) key in the node&rsquo;s <em>left</em> subtree <em><strong>or</strong></em> the <em>smallest</em> (leftmost) in the nodes&rsquo; <em>right</em> subtree.</p>
<h4 id="the-hardest-case">The hardest case</h4>
<p>The case above becomes quite simple if the candidates don&rsquo;t have any children, the hardest case in deletion is when these have one child.
What we need to do in that case is: We first delete the parent node by replacing it with its child - after we have done this we can delete the node we wanted to delete with our old (deleted) parent node.</p>
<p>So, not that hard logically - but can be a pain to implement correctly.</p>
<p>So let&rsquo;s now do exactly that :)!</p>
<pre tabindex="0"><code>def delete(node: Node, key : Key):
	if node is None:
		return node

	if key &lt; node.key:
		node.left = delete(node.left, key)

	elif(key &gt; node.key):
		node.right = delete(node.right, key)

	else:
		if node.left is None:
			temp = node.right
			node = None
			return temp

		elif node.right is None:
			temp = node.left
			node = None
			return temp

		temp = get_max(node.left)

		node.key = temp.key

		node.right = delete(node.right, temp.key)

	return node
</code></pre><h3 id="complexity">Complexity</h3>
<p>The complexity of operations for BST are in the best case and average case, $\mathcal{O}(log\ n)$ which is great.
In the worst case however, these operations will take $\mathcal{O}(n)$ since the items are in ascending order.</p>
<h3 id="bst-summary">BST Summary</h3>
<p>We can use BSTs to implement a set or map, however, with ordering-based operations such as min, max, range etc. with good complexity.</p>
<p>Insert/Delete/Search will take proportional time to the height of the tree. Which in the best/average case is $\mathcal{O}(log\ n)$,
but if the tree is <strong>unbalanced</strong> it will become linear.</p>
<p>So the main takeaway is that, if a BST is balanced, it&rsquo;s really powerful and efficient. So let&rsquo;s take a look how we can make it balanced.</p>
<h3 id="invariants">Invariants</h3>
<p>The property that, in the left subtree, the keys should be lesser than and that in the right subtree, the keys should be greater than is an example of <strong>data structure invariant</strong>.</p>
<p>An invariant is a property that the designer wants to always hold. Usually a rule about what instances of the data structure are &lsquo;valid&rsquo;.</p>
<p>But these invariants can be expensive to maintain - if we say &rsquo;this array is sorted&rsquo; we can&rsquo;t just use append anymore, we need to <em>insert</em> it. So we need to find an invariant for BSTs which is easier to maintain.</p>
<h3 id="avl-trees">AVL Trees</h3>
<p>AVL Trees has a less restrictive invariant compared to BSTs - in an AVL tree we keep the tree <em>almost</em> balanced.</p>
<p>The invariant for an AVL tree is: &ldquo;For each node, the heights of its <em>left</em> and <em>right</em> subtrees differ by at <strong>most</strong> 1&rdquo;.</p>
<h3 id="tree-rotations">Tree Rotations</h3>
<p>Now before we dive deeper into AVL trees - let&rsquo;s take a look into rotations within trees. When we talk about rotations in trees we mean that it has a different node as the root.</p>
<p>Right rotation: <em>left</em> child of root becomes root, old root becomes <em>right</em> child.
Left rotation: <em>right child</em> of root becomes root, old root becomes <em>left</em> child.</p>
<p>Tree rotations preserve ordering and contents in BSTs. Note that we can also rotate a subtree.</p>
<h3 id="avl-insertion">AVL Insertion</h3>
<p>To insert a new node into an AVL tree - we first start by doing a BST insertion - this might break the AVL tree (the invariant).</p>
<p>But to fix this we go upwards from the new node, finding and fixing nodes that break the invariant. Note that during BST insertion, each node&rsquo;s height either stays the same or goes up by 1.</p>
<p>We have different cases which we&rsquo;ll look at.</p>
<h4 id="case-1-left-left-tree">Case 1: Left-left Tree</h4>
<p>In the Left-left case, we did an insertion in the <em>left</em> child of the <em>left</em> child of this node, which broke the invariant.</p>
<p>To fix this, we just make a right rotation</p>
<h4 id="case-2-right-right-tree">Case 2: Right-right Tree</h4>
<p>In the Right-right case, we did an insertion in the <em>right</em> child of the <em>right</em> child of this node, which broke the tree.</p>
<p>To fix we make a left rotation!</p>
<h4 id="case-3-left-right-tree">Case 3: Left-right Tree</h4>
<p>In the Left-right case, the extra height is in the root&rsquo;s <em>left</em> child then in the <em>right child</em> of that. We can&rsquo;t fix it with one rotation instead - but luckily we still have a solution.</p>
<p>First we&rsquo;re going to rotate the <em>left</em> <strong>subtree</strong> <em>left</em>. When we have performed the left rotation, we&rsquo;ve now created a Left-left tree, which is fixed by one right rotation as we saw earlier.</p>
<h4 id="case-4-right-left-tree">Case 4: Right-left Tree</h4>
<p>The same logic as case 3, the extra height is in the root&rsquo;s <em>right child</em> and then in the <em>left child</em> of that one.
To fix this we first make a right rotation in the right subtree - then make a final left rotation to fix the tree.</p>
<h3 id="avl-insertion-summary">AVL Insertion Summary</h3>
<p>So we have these four cases and, we know how to solve them - we just need to remember how we identify them. We identify which <em>grandchild</em> the extra unit of height is in.</p>
<h3 id="avl-deletion">AVL Deletion</h3>
<p>In the case of deleting the node, the same situation occurs! But instead we <em>reduce</em> the height of some tree by 1, breaking the invariant.</p>
<p>So, therefore we can use the <strong>exact same balancing algorithm</strong>. So when implementing an AVL tree we only need to implement the balancing algorithm once!</p>
<p>In conclusion, AVL trees use rotation to keep the tree balanced. In the worst case height of the tree is $1.44\ log_2(n)$, but normally close to $log_2(n)$.</p>
<h3 id="2-3-trees">2-3 Trees</h3>
<p>2-3 trees is also another <strong>height</strong> balanced trees. 2-3 trees is made from two kinds of nodes:</p>
<ul>
<li>
<p>2 - node: Has a key <code>x</code> and two subtrees <code>A</code> and <code>B</code>. Just like in a BST, A &lt; x &lt; B</p>
</li>
<li>
<p>3 - node: Has <strong>two</strong> keys <code>x</code>, <code>y</code> with <strong>three</strong> subtrees, A, B, and C. As usual, A &lt; x &lt; B &lt; y &lt; C.</p>
</li>
</ul>
<h3 id="searching-in-2-3-trees">Searching in 2-3 Trees</h3>
<p>It proceeds just as in a BST. Since - In a 2-node, compare search key against key in node, descend into one of the  two children.</p>
<p>In the case of a 3-node, compare the search key against <strong>both</strong> keys in the node, descend into one of the <strong>three</strong> children.</p>
<h3 id="how-2-3-trees-balance">How 2-3 Trees balance</h3>
<p>In the AVL case we saw that we have to balance via rotations after each insertion/deletion. In the case of a 2-3 tree, we never have to balance since it&rsquo;s <strong>always</strong> balanced.</p>
<p>Because if one child is null all children must be null together (you can test this if you want by drawing examples). This means the empty trees are all at one level (which implies a balanced tree).</p>
<p>The resulting tree will have a height of between $log_3(n)$ and $lg(n)$</p>
<h3 id="insertion-in-2-3-trees">Insertion in 2-3 trees</h3>
<p>When we want to insert a new node to a 2-3 tree we use a normal insertion, however, this might break the tree via, for example, an unbalanced tree or a &lsquo;4-node&rsquo;.</p>
<p>To fix this we use the following algorithm:</p>
<ul>
<li><em>absorb</em> the node into its parent, move up to the parent</li>
<li>If the node is a 4-node, <em>split</em> it into 2-nodes.</li>
</ul>
<p>We keep alternating these 2 steps, we stop once we don&rsquo;t need to split.</p>
<h3 id="summary-2-3-trees">Summary 2-3 trees</h3>
<p>So conceptually they are quite simple - but the implementation is quite horrible, even though the complexity is great, since the tree is always <strong>perfectly</strong> balanced.</p>
<p>So to fix this we use something called a &lsquo;red-black BSTs&rsquo;.</p>
<h3 id="red-black-bsts">Red-black BSTs</h3>
<p>A red-black BSTs implement a 2-3 tree <em>using a BST</em>. We can see a 2-3 node as a BST tree since - a 2-node becomes a regular BST node, however, a 3-node becomes <strong>two</strong> BST nodes.</p>
<p>The name &lsquo;red-black&rsquo; comes from that we color the BST nodes in order to distinguish 2-nodes from 3-nodes.</p>
<p>2-nodes become black and 3-nodes become black with <em>red child</em>. So red is &lsquo;only part of a 3-node&rsquo;.</p>
<p>So a Red-black BST is really just a 2-3 but store it in a BST since we translate it to the corresponding 2-3 tree.</p>
<h3 id="red-black-tree-invariant">Red-black Tree Invariant</h3>
<p>The invariant that we must uphold for a red-black tree is:</p>
<ul>
<li>
<p>A red node may only occur as the <em>left</em> child of a <em>black</em> node</p>
</li>
<li>
<p>Black balance: on any path from the root to a null, we pass through the same number of black nodes</p>
</li>
<li>
<p>And the BST invariant must also hold.</p>
</li>
</ul>
<h3 id="red-black-bst-insertion">Red-black BST Insertion</h3>
<p>To make an insertion into a red-black tree, we first make a normal BST insertion, the newly added node is a <em>red</em> node.</p>
<p>This may break our invariant on red nodes, but this way we always keep the black balance and BST properties.</p>
<p>But this way we&rsquo;ll only break the invariant by placing a red node in a forbidden place. There are 3 cases which this will happen.</p>
<h4 id="case-1-skew">Case 1: Skew</h4>
<p>In a skew case, we have placed it to the right of a 2-node (black node) and therefore broken the first rule. We fix it by an operation called <em>skewing</em>.</p>
<p>Which is a kind of rotation, we&rsquo;ll look at the implementation later.</p>
<h4 id="case-2-split">Case 2: Split</h4>
<p>In a split case we have created a 4-node (or a red having a red child), therefore we need to split it into 2-nodes.
In the case of splitting, we may break the black balance which means we need to continue up recursively</p>
<h4 id="case-3-red-root-node">Case 3: Red Root Node</h4>
<p>After a split, we might end up with a red node as the <em>root</em> of the whole tree. In a case like this, the fix is simple, we just make the root a black node instead!</p>
<h3 id="red-black-tree-implementation">Red-black Tree Implementation</h3>
<pre tabindex="0"><code>class RBNode:
    def __init__(self, val):
        self.red = False
        self.parent = None
        self.val = val
        self.left = None
        self.right = None

class RBTree:
    def __init__(self):
        self.nil = RBNode(0)
        self.nil.red = False
        self.nil.left = None
        self.nil.right = None
        self.root = self.nil

def insert(self, val):
    new_node = RBNode(val)
    new_node.parent = None
    new_node.left = self.nil
    new_node.right = self.nil

    # New node must be red
    new_node.red = True

    parent = None
    current = self.root
    while current != self.nil:
        parent = current
        if new_node.val &lt; current.val:
            current = current.left
        elif new_node.val &gt; current.val:
            current = current.right
        else:
            return

    new_node.parent = parent
    if parent == None:
        self.root = new_node
    elif new_node.val &lt; parent.val:
        parent.left = new_node
    else:
        parent.right = new_node

    self.fix_insert(new_node)

def rotate_left(self, x):
    y = x.right
    x.right = y.left
    if y.left != self.nil:
        y.left.parent = x

    y.parent = x.parent
    if x.parent == None:
        self.root = y
    elif x == x.parent.left:
        x.parent.left = y
    else:
        x.parent.right = y
    y.left = x
    x.parent = y

def rotate_right(self, x):
    y = x.left
    x.left = y.right
    if y.right != self.nil:
        y.right.parent = x

    y.parent = x.parent
    if x.parent == None:
        self.root = y
    elif x == x.parent.right:
        x.parent.right = y
    else:
        x.parent.left = y
    y.right = x
    x.parent = y

def fix_insert(self, new_node):
    while new_node != self.root and new_node.parent.red:
        if new_node.parent == new_node.parent.parent.right:
            u = new_node.parent.parent.left  # uncle
            if u.red:

                u.red = False
                new_node.parent.red = False
                new_node.parent.parent.red = True
                new_node = new_node.parent.parent
            else:
                if new_node == new_node.parent.left:
                    new_node = new_node.parent
                    self.rotate_right(new_node)
                new_node.parent.red = False
                new_node.parent.parent.red = True
                self.rotate_left(new_node.parent.parent)
        else:
            u = new_node.parent.parent.right  # uncle

            if u.red:
                u.red = False
                new_node.parent.red = False
                new_node.parent.parent.red = True
                new_node = new_node.parent.parent
            else:
                if new_node == new_node.parent.right:
                    new_node = new_node.parent
                    self.rotate_left(new_node)
                new_node.parent.red = False
                new_node.parent.parent.red = True
                self.rotate_right(new_node.parent.parent)
    self.root.red = False

def exists(self, val):
    curr = self.root
    while curr != self.nil and val != curr.val:
        if val &lt; curr.val:
            curr = curr.left
        else:
            curr = curr.right
    return curr
</code></pre><h3 id="red-black-tree-summary">Red-black Tree Summary</h3>
<p>Red-black trees are 2-3 trees implemented using a BST - they have the invariant that they have to correspond to a perfectly balanced 2-3 tree.</p>
<p>Update strategy is: Insert in a way that break the rules on red nodes, then fix it.</p>
<p>They have logarithmic performance - worst case the height is $2\ log(n)$</p>
<p>This was the end of this part - it was a lot to process, it was a lot for me as well :). In the next part we&rsquo;ll cover priority queues and how they can be implemented as a kind of tree :).</p>

        </section>

        <div class="post-tags">
            
            
            <nav class="nav tags">
                <ul class="tags">
                    
                    <li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
                    
                </ul>
            </nav>
            
            
        </div>
        </article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
</body>

</html>
