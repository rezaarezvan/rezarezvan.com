<!DOCTYPE html>
<html><head lang="en">
    <meta charset="utf-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge"><title>rezvan | DSA: Part 4 - Abstract Data Types</title><link rel="icon" type="image/png" href="/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description"
        content="ADT vs Data Structures So, what&rsquo;s the difference between an Abstract Data Type and an actual data structure?
An ADT is a kind of specification of something - it specifies how we can interact with that object, like an API.
It consists of methods and constructors but also plain-text specifications (like the complexity for example) and explanations.
A data structure on the other hand is an actual implementation of an ADT." />
    <meta property="og:image" content="https://raw.githubusercontent.com/rezaarezvan/rezvan.xyz/main/images/icon.png" />
    <meta property="og:title" content="DSA: Part 4 - Abstract Data Types" />
<meta property="og:description" content="ADT vs Data Structures So, what&rsquo;s the difference between an Abstract Data Type and an actual data structure?
An ADT is a kind of specification of something - it specifies how we can interact with that object, like an API.
It consists of methods and constructors but also plain-text specifications (like the complexity for example) and explanations.
A data structure on the other hand is an actual implementation of an ADT." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DAT038/DSA_4/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-11-28T20:30:47+01:00" />
<meta property="article:modified_time" content="2022-11-28T20:30:47+01:00" />

<meta name="twitter:card" content="summary"/><meta name="twitter:title" content="DSA: Part 4 - Abstract Data Types"/>
<meta name="twitter:description" content="ADT vs Data Structures So, what&rsquo;s the difference between an Abstract Data Type and an actual data structure?
An ADT is a kind of specification of something - it specifies how we can interact with that object, like an API.
It consists of methods and constructors but also plain-text specifications (like the complexity for example) and explanations.
A data structure on the other hand is an actual implementation of an ADT."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
    <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

    
    <link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.55ceafd1ab15172b8770201b55c83270fac8611fcdae31fccb3a7fd94ac6da6e.css" />
    <link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b95ac7b1169ab6755ef14c75e8e49c983d2d56c40ee0c3d69d357d42339b5e31.css"  disabled />
    

    
    
    <script type="text/javascript"
        src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
        </script>

    
    <script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
    

    
    
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js"
        onload="renderMathInElement(document.body);"></script>

    
    <script>
        document.addEventListener("DOMContentLoaded", function () {
            renderMathInElement(document.body, {
                delimiters: [
                    {left: "$$", right: "$$", display: true},
                    {left: "$", right: "$", display: false}
                ]
            });
        });
    </script>
    

    
</head>
<body>
    <div class="content"><header>
    <div class="main">
        <a href="https://rezvan.xyz/">rezvan</a>
    </div>
    <nav id="site-navbar">
        
        <a href="/">home</a>
        
        <a href="/about">about</a>
        
        <a href="/principles">principles</a>
        
        <a href="/contact">contact</a>
        
        <a href="/cv">cv</a>
        
        <a href="/school">school</a>
        
        <a href="/tags">tags</a>
        
        | <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
        <script src="https://rezvan.xyz/js/themetoggle.js"></script>
        
    </nav>
</header>

<main>
    <article>
        <div class="title">
            <h1 class="title">DSA: Part 4 - Abstract Data Types</h1>
            <div class="meta">Posted on Nov 28, 2022</div>
        </div>
        

        <section class="body">
            <h3 id="adt-vs-data-structures">ADT vs Data Structures</h3>
<p>So, what&rsquo;s the difference between an <strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ype and an actual data structure?</p>
<p>An ADT is a kind of specification of something - it specifies how we can interact with that <em>object</em>, like an API.</p>
<p>It consists of methods and constructors but also plain-text specifications (like the complexity for example) and explanations.</p>
<p>A data structure on the other hand is an <strong>actual</strong> <em>implementation</em> of an ADT. It specifies how the <em>object</em> works <em>internally</em>.
But an important note is, that it doesn&rsquo;t need to be in an actual programming language - often it&rsquo;s just specified in pseudocode.</p>
<h3 id="method-descriptions">Method Descriptions</h3>
<p>As explained above - an ADT has methods/functions - but these need to be specified/have a brief plain-text explanation.
For example, all these ADTs have the same functions, but work differently:</p>
<pre tabindex="0"><code>Stack&lt;Item&gt;:
    void add(Item x)
    Item remove()

Queue&lt;Item&gt;
    void add(Item x)
    Item remove()

PrioQueue&lt;Item&gt;:
    void add(Item x)
    Item remove()
</code></pre><h3 id="different-kind-of-adts">Different kind of ADTs</h3>
<p>Now we will cover all ADTs that we will encounter in this course!</p>
<h3 id="ordered-collections-stacks-queues-etc">Ordered collections: Stacks, Queues, etc</h3>
<h4 id="stacks">Stacks</h4>
<p>Since we have covered in depth as well as implemented stacks, let&rsquo;s just briefly go over them.</p>
<p>Stacks - LIFO (&rsquo;<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>pop()</code> <code>push()</code></p>
<p>So the ADT would be:</p>
<pre tabindex="0"><code>Stack&lt;Item&gt;:
    // Adds Item X to the top of the stack
    void push(Item x)

    // Returns and removes the topmost element of the stack
    Item pop()

    // Returns the topmost element, without removing it
    Item peek()

    // Returns True if the stack is empty, False otherwise
    boolean is_empty()

    Returns the current size (length) of the stack
    int size()
</code></pre><h4 id="queues">Queues</h4>
<p>Same goes for a queue - since we&rsquo;ve already covered this in depth, we&rsquo;ll just briefly recover it.</p>
<p>Queues - FIFO (&rsquo;<strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>enqueue()</code> <code>dequeue()</code></p>
<p>So the ADT can be described as:</p>
<pre tabindex="0"><code>Queue&lt;Item&gt;:
    // Adds Item X to the end of the queue
    void enqueue(Item x)

    // Removes and returns the first item in the queue
    Item dequeue()

    // Returns True if the queue is empty, False otherwise
    boolean empty()

    // Returns True if the queue is full, False otherwise
    boolean full()

    // Returns the current size (length) of the queue
    int qsize()
</code></pre><h4 id="stacks--queues--deques">Stacks + Queues = Deques</h4>
<p>If we combine these two ADTs that we&rsquo;ve become so familiar with - we get a so-called double-ended queue!</p>
<p>Here&rsquo;s the ADT for it:</p>
<pre tabindex="0"><code>Deque&lt;Item&gt;:
    // Adds Item X to the front of the deque
    void add_first(Item x)

    // Adds Item X to the end of the deque
    void add_last(Item x)

    // Removes and returns the frontmost item in the deque
    Item remove_first()

    // Removes and returns the last item in the deque
    Item remove_last()
</code></pre><p>So why would we want to use a stack or queue - when their combination exists?</p>
<p>The answer is quite simple - it differs from problem to problem! Sometimes a stack might just be <em>exactly</em> what you want, and sometimes you might feel hindered or blocked by a ADT.</p>
<p>So you need to do research on what kind of ADT you should use before actually implementing one. Also cost/how hard the implementation will be is also a important factor.</p>
<h4 id="lists-generalizing-stacks-and-queues">Lists: Generalizing Stacks and Queues</h4>
<p>Lists is the ADT when we finally don&rsquo;t restrict ourselves to only add/remove the front/end element - and finally can add/remove wherever we want!</p>
<p>The ADT looks something like:</p>
<pre tabindex="0"><code>List&lt;Item&gt;:
    // Inserts Item X at position i in the list
    void add(Item x, int i)

    // Removes and returns the item at position i
    Item remove(int i)

    // Returns the element on position i
    Item get(int i)

    // Sets/replaces element i with x
    void set(int i, Item x)

    // Returns True if the list is currently empty, otherwise False
    boolean is_empty()

    // Returns the current size (# of elements) in the list
    int size()
</code></pre><h4 id="priority-queues">Priority Queues</h4>
<p>The only difference between priority queues, stacks and regular queues is which element to remove.
A stack removes the &lsquo;youngest&rsquo; element, a queue removes the &lsquo;oldest&rsquo; element, and a priority queue removes the &lsquo;minimum&rsquo; element. Minimum here means by some arbitrary ordering.</p>
<p>These are quite complicated to implement so, we&rsquo;ll be implementing them a bit later.</p>
<h4 id="iterating-comparing-and-sorting">Iterating, Comparing and Sorting</h4>
<p>Iterating, comparing, and sorting are all very important when it comes to ordered collections - we need to be able to iterate through the whole collection,
comparing items to each other, and of course the most important - sorting the collection!</p>
<p>These all feel like very &rsquo;low-level&rsquo; and natural things - but quite often we ourselves will need to implement these.
For example, iterating through a queue. Note that some data structures actually doesn&rsquo;t allow iterating throughout the collection!</p>
<p>Iteration also works differently, for example in Java it&rsquo;s called <code>iterator()</code> and in Python <code>__iter__()</code>.
One thing to note is that iterables and iterators are different. An <em>iterator</em> has a method that returns the next element, and a way of telling when the iteration is exhausted.</p>
<p>So, an <em>iterator</em> can only be iterated over once, while an <em>iterable</em> can be iterated many times, because it creates new iterators. Quite a mouthful.</p>
<p>So in Python for example a simple:</p>
<pre tabindex="0"><code>for x in elements:
    # do something with x
</code></pre><p>is translated to:</p>
<pre tabindex="0"><code>it = elements.__iter__()
while True:
    try:
        x = it.__next__()
    expect StopIteration():
        break

    # do something  with x
</code></pre><p>A same kind of logic is applied when we want to compare items. If something is comparable they implement a <em>comparable</em> interface for example.
But often we want our own comparisons to something rather than the &rsquo;natural ordering&rsquo; the comparable interface provides. In these cases we need to implement different <em>comparators</em>.</p>
<p>Now sorting becomes quite trivial - the built-in sorting methods either use the &rsquo;natural ordering&rsquo; comparator, or can take a comparator as an argument to sort it how we want.</p>
<h4 id="unordered-collections-maps-sets-and-graphs">Unordered collections: Maps, sets, and graphs</h4>
<p>These are just like the ordered collections, but without a specific order :)</p>
<h4 id="sets">Sets</h4>
<p>You should be quite familiar with sets from a discrete math course - but let&rsquo;s go over it anyway.</p>
<p>A set is a collection of objects where:</p>
<ul>
<li>It cannot contain duplicates of the same object.</li>
<li>Basic operations for testing for &lsquo;membership&rsquo;, and adding/removing an element.</li>
<li>Methods for size of the set and testing for emptiness.</li>
<li>Usually a kind of iterator for looping over all elements/members in set.</li>
</ul>
<p>So the ADT could look like:</p>
<pre tabindex="0"><code>Set&lt;Item&gt;:
    // Returns True if x is in the set, False otherwise
    boolean contains(Item x)

    // Adds x to the set, if it&#39;s not already in the set
    void add(Item x)

    // Removes x from the set, if it&#39;s present
    void remove(Item x)

    // Returns True if the set is currently empty, False otherwise
    boolean is_empty()

    // Returns the current size (# of elements) in the set
    int size()

    // Iterates over all elements in the set
    Iterator&lt;Item&gt; iterator()
</code></pre><h4 id="maps">Maps</h4>
<p>A map is a &lsquo;mapping&rsquo; from a &lsquo;key&rsquo; to a &lsquo;value&rsquo; with these properties:</p>
<ul>
<li>It cannot contain duplicates of the same &lsquo;key&rsquo;</li>
<li>The basic operations are <code>getting</code> and <code>setting</code> the &lsquo;value&rsquo; for a given &lsquo;key&rsquo;. Also removing a &lsquo;key&rsquo; along with its associated value.</li>
<li>Helper methods such as, <code>number_of_keys()</code>, <code>is_empty()</code></li>
<li>(Usually) an iterator to loop over all keys</li>
</ul>
<p>So an ADT would look like:</p>
<pre tabindex="0"><code>Map&lt;Key, Value&gt;:
    // Returns True if there&#39;s an association for the key, k.
    boolean contains(Key k)

    // Returns the value associated with key, k.
    Value get(Key k)

    // Associates the key, k, with the value, v.
    void put(Key k, Value v)

    // Removes the value associated with the key, k.
    void remove(Key k)

    // Returns True if the Map is currently empty, False otherwise
    boolean is_empty()

    // Returns the current size (# of key-value pairs) in the map
    int size()

    // Iterates over all keys in the map
    Iterator&lt;Key&gt; keys()
</code></pre><p>&lsquo;Maps&rsquo; have a lot of associated names:</p>
<ul>
<li>Dictionaries</li>
<li>Symbol tables</li>
<li>Associative arrays</li>
<li>Lookup tables</li>
<li>finite-domain functions</li>
<li>$\dots$</li>
</ul>
<p>Maps can be seen as a further generalization of list even. The integer position is now replaced by a generic &lsquo;key&rsquo; type.</p>
<p>For actual implementation of maps, these are the following:</p>
<ul>
<li>Lists</li>
<li>Search trees
<ul>
<li>Binary search trees
<ul>
<li>Unbalanced BSTs</li>
<li>Balanced BSTs (red-black tree, AVL trees, $\dots$)</li>
</ul>
</li>
</ul>
</li>
<li>Hash tables
<ul>
<li>Separate chaining</li>
<li>Open addressing (Linear probing, quadratic probing, $\dots$)</li>
</ul>
</li>
<li>Randomized data structures
<ul>
<li>Skip list, treap, $\dots$</li>
</ul>
</li>
</ul>
<h4 id="a-set-is-degenerated-map">A Set is Degenerated Map</h4>
<p>If we have an implementation of a map, it&rsquo;s actually quite easy to turn it into a set. We just need to create an underlying map,
whose keys are the set items!</p>
<p>So an ADT solution would be:</p>
<pre tabindex="0"><code>Set&lt;Item&gt;:
    Map&lt;Item, Void&gt; underlying_map

    boolean contains(Item x)  = underlying_map.contains(x)
    void add(Item x)          = underlying_map.add(x, null)
    void remove(Item x)       = underlying_map.remove(x)

    boolean is_empty()        = underlying_map.is_empty()
    int size()                = underlying_map.size()

    Iterator&lt;Item&gt; iterator() = underlying_map.keys()
</code></pre><h4 id="multiset-and-multimap">Multiset and multimap</h4>
<p>Sometimes we want to put several objects into the same &lsquo;slot&rsquo; (for example a set with lists).</p>
<p>A multiset (sometimes called &lsquo;bag&rsquo;) is just like a set, but can contain duplicates.</p>
<pre tabindex="0"><code>Multiset&lt;Item&gt;:
    // Returns the number of occurrences of Item x in the multiset
    int count(Item x)

    // Adds Item X to the multiset
    void add(Item x)

    // Removes one occurrence of Item x, returns the Item
    Item remove(Item x)
</code></pre><p>A multimap (or sometimes called &lsquo;index&rsquo;) is just like a map, but keys can map to several values.</p>
<pre tabindex="0"><code>Multimap&lt;Key, Value&gt;:
    // Returns the whole collection of values associated with the key, k
    Collection&lt;Value&gt; get(Key k)

    // Adds the value, v, to the key, k
    void add(Key k, Value v)

    // Removes the value, v, associated with the key, k
    void remove(Key k, Value v)
</code></pre><h4 id="multiset-and-multimap-are-maps">Multiset and Multimap are Maps</h4>
<p>Now this might sound weird - but yes, maps as well! We can just like how we implemented a set using an underlying map,
use an underlying map to implement multisets and maps.</p>
<p>An ADT for this would be:</p>
<pre tabindex="0"><code>Multimap&lt;Key, Value&gt;:
    Map&lt;Key, Set&lt;Value&gt;&gt; underlying_map

    Collection&lt;Value&gt; get(Key k) = underlying_map.get(k)

    void add(Key k, Value v)     = underlying_map.put(k, v)

    void remove(Key k, Value v)  = underlying_map.remove(k)
</code></pre><p>And for Multisets:</p>
<pre tabindex="0"><code>Mutlisets&lt;Item&gt;:
    Map&lt;Key, Item&gt; underlying_map

    int count(Item x) = underlying_map.get(x)

    void add(Item x) =
        if underlying_map.contains():
            count = underlying_map.get(x)
            count += 1
            underlying_map.put(x, count)
        else:
            underlying_map.put(x, 1)

    Item remove(Item x) = underlying_map.remove(x)
</code></pre><h3 id="graphs">Graphs</h3>
<p>Graphs should also be familiar from the discrete mathematics course - but let&rsquo;s quickly go over it. Graphs consists of <em>nodes</em> (also called vertices, points)</p>
<ul>
<li>and <em>edges</em> (also called arcs, links) that connect nodes.</li>
</ul>
<p>There are many, many types of graphs - in this course we&rsquo;ll mainly use so-called directed graphs, so our ADT will look like:</p>
<pre tabindex="0"><code>DirectedGraph&lt;Node&gt;:
    // Adds an edge to the graph
    void add(DirectedEdge&lt;Node&gt; e)

    // Removes an edge from the graph
    void remove(DirectedEdge&lt;Node&gt; e)

    // Returns True if the graph contains the edge, False otherwise
    boolean contains(DirectedEdge&lt;Node&gt; e)

    // Returns all edges that goes out from Node, n
    Collection&lt;DirectedEdge&lt;Node&gt;&gt;
        outgoing_edges(Node n)

    // Returns the total number of nodes in the graph
    int n_node()

    // Returns the total number of edges in the graph
    int n_edges()
</code></pre><p>As you can see this ADT relies on a class that specifies how an edge should work:</p>
<pre tabindex="0"><code>class DirectedEdge&lt;Node&gt;:
    // The constructor to create a new edge between two nodes
    __init__(Node from, Node to, float weight)

    // Returns the &#39;starting&#39; node
    Node from()

    // Returns the &#39;final&#39; node
    Node to()

    // Returns the weight of the edge
    double weight()
</code></pre><p>As said earlier, graphs come in many different shapes and forms - either they are directed or directed as well as weighted or unweighted.</p>
<h3 id="summary">Summary</h3>
<p><em>Phew</em> this was a lot to take in (and write&hellip;) - but to summarize - there really isn&rsquo;t a universal standard/best of what the best ADT/API looks like.</p>
<p>In my notes there is one way, I wrote it using slightly different syntax/language. But the takeaway is still the ADTs as in a concept -  all these ADTs build on the same basic idea/operations.</p>
<p>I really liked the picture from the slides in my course so, I&rsquo;ll put it here to visualize everything we have discussed today.
<img src="/school/images/Summary.png" alt="Summary"></p>
<p>In the next part we&rsquo;ll begin with concept we mentioned today - Hash tables!</p>

        </section>

        <div class="post-tags">
            
            
            <nav class="nav tags">
                <ul class="tags">
                    
                    <li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
                    
                </ul>
            </nav>
            
            
        </div>
        </article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
</body>

</html>
