<!DOCTYPE html><html lang="en"> <head><meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="Astro v4.14.2"><link rel="icon" type="image" href="/favicon.ico"><title>Part 10 - Parallel linked lists</title><!-- KaTeX support --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script><!-- inline KaTeX --><link rel="stylesheet" href="/_astro/index.CwgzIfsj.css">
<link rel="stylesheet" href="/_astro/_slug_.hCvEQTvV.css">
<style>article[data-astro-cid-v5ro3oot]{max-width:80ch;margin:0 auto}.nav-button[data-astro-cid-v5ro3oot]{display:flex;align-items:center;padding:.5rem;border-radius:.5rem;transition:background-color .3s ease;text-decoration:none;color:var(--text-color);background-color:var(--bg-color);border:1px solid var(--border-color)}.nav-button[data-astro-cid-v5ro3oot]:hover{background-color:var(--hover-color)}.nav-button[data-astro-cid-v5ro3oot] .arrow[data-astro-cid-v5ro3oot]{font-size:1.5rem;line-height:1}.nav-button[data-astro-cid-v5ro3oot] .text[data-astro-cid-v5ro3oot]{display:flex;flex-direction:column;margin:0 .5rem}.nav-button[data-astro-cid-v5ro3oot] .label[data-astro-cid-v5ro3oot]{font-size:.8rem;text-transform:uppercase;letter-spacing:.05em;color:var(--muted-color)}.nav-button[data-astro-cid-v5ro3oot] .title[data-astro-cid-v5ro3oot]{font-weight:500}.prev-button[data-astro-cid-v5ro3oot]{justify-content:flex-start}.next-button[data-astro-cid-v5ro3oot]{justify-content:flex-end;text-align:right}@media (max-width: 640px){.nav-button[data-astro-cid-v5ro3oot]{width:100%}.next-button[data-astro-cid-v5ro3oot]{justify-content:flex-start;text-align:left}.next-button[data-astro-cid-v5ro3oot] .text[data-astro-cid-v5ro3oot]{order:2;margin-left:.5rem}.next-button[data-astro-cid-v5ro3oot] .arrow[data-astro-cid-v5ro3oot]{order:1}}
</style><script type="module">document.addEventListener("DOMContentLoaded",function(){renderMathInElement(document.body,{delimiters:[{left:"$$",right:"$$",display:!0},{left:"$",right:"$",display:!1}]})});
</script></head> <body> <div class="container mx-auto px-4 flex flex-col md:flex-row min-h-screen"> <aside class="w-full md:w-64 border-b md:border-r md:border-b-0 border-[var(--border-color)] border-dashed pt-8"> <header class="flex flex-col h-full"> <div class="flex items-center mb-4"> <script>
  function setTheme(mode) {
    localStorage.setItem("theme-storage", mode);
    document.documentElement.setAttribute('data-theme', mode);
  }
  function toggleTheme() {
    const currentTheme = localStorage.getItem("theme-storage") || "light";
    const newTheme = currentTheme === "light" ? "dark" : "light";
    setTheme(newTheme);
  }
  const savedTheme = localStorage.getItem("theme-storage") || "light";
  setTheme(savedTheme);
  window.toggleTheme = toggleTheme;
</script> <button id="theme-toggle" onclick="toggleTheme()" aria-label="Toggle theme" class="w-6 h-6 cursor-pointer"> <div class="w-5 h-5 border-2 border-primary rounded-full transition-colors duration-300 ease-in-out hover:bg-primary"></div> </button> <a href="/" class="text-2xl font-semibold ml-3 h-10 pr-3">rezvan.xyz</a> </div> <nav class="flex flex-wrap gap-2 md:flex-col md:gap-2"> <a href="/principles" class="transition-colors">
[principles]
</a><a href="/cv" class="transition-colors">
[cv]
</a><a href="/posts" class="transition-colors">
[posts]
</a><a href="/school" class="transition-colors">
[school]
</a> </nav> </header> </aside> <main class="flex-grow px-4 md:px-8 py-8 overflow-y-auto">  <article class="prose prose-sm sm:prose lg:prose-lg xl:prose-xl max-w-none" data-astro-cid-v5ro3oot> <h1 class="text-3xl sm:text-4xl font-bold mb-4" data-astro-cid-v5ro3oot>Part 10 - Parallel linked lists</h1> <p class="text-sm text-muted-foreground mb-4" data-astro-cid-v5ro3oot>
Date: 2/19/2023 </p> <div class="markdown-content" data-astro-cid-v5ro3oot>  <p>In this part we’ll cover the <em>synchronization challenges</em> that arise when designing (correct) and efficient parallelizations.</p>
<p>But let’s first see the burdens with locks</p>
<h3 id="the-trouble-with-locks">The trouble with locks</h3>
<p>Standard techniques for concurrent programming are ultimately based on locks.</p>
<p>Programming with locks has several drawbacks:</p>
<ul>
<li>
<p>Performance overhead.</p>
</li>
<li>
<p>Lock granularity is hard to choose:</p>
<ul>
<li>
<p>Not enough locking: race conditions.</p>
</li>
<li>
<p>Too much locking: not enough parallelism.</p>
</li>
</ul>
</li>
<li>
<p>Risk of deadlock and starvation.</p>
</li>
<li>
<p>Lock-based implementations do not compose (easily).</p>
</li>
<li>
<p>Lock-based programs are hard to maintain and modify.</p>
</li>
</ul>
<p>Message-passing programming is higher-level, but it also inevitably incurs on
synchronization costs – of magnitude comparable to those associated with locks.</p>
<p>A good rule of thumb is:</p>
<ul>
<li>
<p>Lock-based programming is <em>pessimistic</em>: be prepared for the worst possible conditions:</p>
<ul>
<li>If things can go wrong, they will.</li>
</ul>
</li>
<li>
<p>Lock-free programming is <em>optimistic</em>: do what you have to do without worrying about race conditions:</p>
<ul>
<li>If things go wrong, just try again!</li>
</ul>
</li>
</ul>
<p>Ultimately, what Lock-free programming relies on is:</p>
<ul>
<li>
<p>Using stronger primitives for atomic access.</p>
</li>
<li>
<p>Building optimistic algorithms using those primitives.</p>
</li>
</ul>
<p>For example, remember the <code>compare-and-set</code> and <code>test-and-set</code> methods we have encountered.</p>
<p>Even if these are not ‘free’, these operations also take time and performance.</p>
<p>There are two different classes of lock-free algorithms:</p>
<ul>
<li>
<p>Lock-free: guarantee <em>system-wide</em> progress: infinitely often, some process makes progress.</p>
</li>
<li>
<p>Wait-free: guarantee <em>per-process</em> progress: every process eventually makes progress.</p>
</li>
</ul>
<p>Wait-free is stronger than lock-free:</p>
<ul>
<li>Lock-free algorithms are free from deadlock.</li>
<li>Wait-free algorithms are free from deadlock <em>and starvation</em>.</li>
</ul>
<p>Let’s see how we can parallelize linked lists!</p>
<p>But before that, let’s quickly just have our linked list defined:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SequentialNode&#x3C;T> implements Node&#x3C;T> {</span></span>
<span class="line"><span>    // Value stored in node</span></span>
<span class="line"><span>    private T item;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Hash code of item</span></span>
<span class="line"><span>    private int key;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Next node in chain</span></span>
<span class="line"><span>    private Node&#x3C;T> next;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    T item() { return item; }</span></span>
<span class="line"><span>    int key() { return key; }</span></span>
<span class="line"><span>    Node&#x3C;T> next() { return next; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void setItem(T item) { this.item = item; }</span></span>
<span class="line"><span>    void setKey(int key) { this.key = key; }</span></span>
<span class="line"><span>    void setNext(Node&#x3C;T> next) { this.next = next; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        curr = start;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        do {</span></span>
<span class="line"><span>            pred = curr; curr = curr.next();</span></span>
<span class="line"><span>        } while (curr.key() &#x3C; key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return (pred,curr);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean has(T item) {</span></span>
<span class="line"><span>        int key = item.key();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Find position of key from head:</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return curr.key() == key;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean add(T item) {</span></span>
<span class="line"><span>        // New node to be added</span></span>
<span class="line"><span>        Node&#x3C;T> node = new Node&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // curr.key >= item.key()</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (curr.key() == item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            node.setNext(curr);</span></span>
<span class="line"><span>            pred.setNext(node);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean remove(T item) {</span></span>
<span class="line"><span>        // curr.key() >= item.key()</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (curr.key() > item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            pred.setNext(curr.next());</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="coarse-grained-locking">Coarse grained locking</h3>
<p>The simple idea is to lock every method.</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class CoarseSet&#x3C;T> extends SequentialSet&#x3C;T> {</span></span>
<span class="line"><span>    // Lock controlling access to the whole set</span></span>
<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean add(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute ‘add’ while locking</span></span>
<span class="line"><span>            return super.add(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean remove(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute ‘remove’ while locking</span></span>
<span class="line"><span>            return super.remove(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean has(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute ‘has’ while locking</span></span>
<span class="line"><span>            return super.has(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Now this is a <strong>very</strong> naive approach - but let’s list the pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Obviously correct – avoids race conditions and deadlocks.</p>
</li>
<li>
<p>If the lock is fair, so is access to the list.</p>
</li>
<li>
<p>If contention is low (not many threads accessing the set concurrently), <code>CoarseSet</code> is quite efficient.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>Access to the list is sequential – missing opportunities for parallelization.</p>
</li>
<li>
<p>If contention is high (many threads accessing the set concurrently), <code>CoarseSet</code> is quite slow.</p>
</li>
</ul>
</li>
</ul>
<p>Now let’s look at <code>CoarseSet</code> predecessor</p>
<h3 id="fine-grained-locking">Fine-grained locking</h3>
<p>The idea here is, instead of locking the whole list when doing operations, we just lock that specific node(s).</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class FineSet&#x3C;T> extends SequentialSet&#x3C;T> {</span></span>
<span class="line"><span>    public FineSet() {</span></span>
<span class="line"><span>        // Smallest key</span></span>
<span class="line"><span>        head = new LockableNode&#x3C;>(Integer.MIN _ VALUE);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Largest key</span></span>
<span class="line"><span>        tail = new LockableNode&#x3C;>(Integer.MAX _ VALUE);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        head.setNext(tail);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Since each node is lockable:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LockableNode&#x3C;T> extends SequentialNode&#x3C;T> {</span></span>
<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>
<span class="line"><span>        void lock() { lock.lock(); }</span></span>
<span class="line"><span>        void unlock() { lock.unlock(); }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Now let’s see the implementations of each operation:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Find while locking pred and curr, return locked position</span></span>
<span class="line"><span>protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr;</span></span>
<span class="line"><span>    pred = start; curr = start.next();</span></span>
<span class="line"><span>    pred.lock(); curr.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    while (curr.key &#x3C; key) {</span></span>
<span class="line"><span>        // Unlock pred node</span></span>
<span class="line"><span>        pred.unlock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Move to next node</span></span>
<span class="line"><span>        pred = curr; curr = curr.next();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Lock next node</span></span>
<span class="line"><span>        curr.lock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return (pred, curr);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = new LockableNode&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Add node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Remove node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Check node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>As we see, it’s all about the <code>find</code> operation.</p>
<p>Pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>If locks are fair, so is access to the list, because threads proceed along the list one
after the other without changing order.</p>
</li>
<li>
<p>Threads operating on disjoint portions of the list may be able to operate in parallel.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>It is still possible that one thread prevents another thread from operating in parallel on
a disjoint portion of the list – for example, if one thread wants to access the end of the
list but, another thread blocks it while locking the beginning of the list.</p>
</li>
<li>
<p>The hand-over-hand locking protocol may be quite slow, as it involves a significant
number of lock operations.</p>
</li>
</ul>
</li>
</ul>
<h3 id="optimistic-locking">Optimistic locking</h3>
<p>Let’s try to implement <code>find</code> without using locks. The idea is to <em>validate</em>
a position <em>after finding it</em>, there is some implementation detail about the nodes,
for example we need to make sure we have the <code>volatile</code> keyword for the <code>next</code> attribute in a node.</p>
<p>But that is besides the point, let’s take an overview of how the operations should work:</p>
<ol>
<li>
<p>Find the item’s position inside the list without locking.</p>
</li>
<li>
<p>Lock the position’s nodes <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>Validate the position while the nodes are locked:</p>
<ul>
<li>
<p>3.1 If the position is <strong>valid</strong>, perform the operation while the nodes are locked, then
release locks.</p>
</li>
<li>
<p>3.2 If the position is <strong>invalid</strong>, release locks and repeat the operation from <strong>scratch</strong>.</p>
</li>
</ul>
</li>
</ol>
<p>This approach is optimistic because it works well when validation is often successful
(so we don’t have to repeat operations).</p>
<p>Now let’s implement these operations:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Find as in SequentialSet find</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = new ReadWriteNode&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                // Physically add node</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                // Physically remove node</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // If not valid: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                return curr.key() == item.key();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // If not valid: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected boolean valid(Node&#x3C;T> pred, Node&#x3C;T> curr) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = head;</span></span>
<span class="line"><span>    while (node.key() &#x3C;= pred.key()) {</span></span>
<span class="line"><span>        if (node == pred) {</span></span>
<span class="line"><span>            return pred.next() == curr;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        node = node.next();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Threads operating on disjoint portions of the list can operate in parallel.</p>
</li>
<li>
<p>When validation often succeeds, there is much less locking involved than in <code>FineSet</code>.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p><code>OptimisticSet</code> is not starvation free; A thread, $t$, may fail validation forever
if other threads keep removing and adding <code>pred</code> / <code>curr</code> between when $t$ performs
<code>find</code> and when it locks <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>If traversing the list twice without locking is not significantly faster than traversing it
once with locking, <code>OptimisticSet</code> does not have a clear advantage over <code>FineSet</code>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="lazy-node-removal">Lazy node removal</h3>
<p>This is the idea that, we need a way to atomically share the information that a node is being removed, but
without locking.</p>
<p>To this end, each node includes a flag <code>valid</code> with setters and getters.</p>
<p>Which means:</p>
<ul>
<li>
<p>Validation only needs to check the mark <code>valid</code>.</p>
</li>
<li>
<p>Operation <code>remove</code> marks a node invalid before removing it.</p>
</li>
<li>
<p>Operation <code>has</code> is lock-free.</p>
</li>
<li>
<p>Operation <code>add</code> works as in <code>OptimisticSet</code>.</p>
</li>
</ul>
<p>Let’s start with the implementation:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class LazySet&#x3C;T> extends OptimisticSet&#x3C;T> {</span></span>
<span class="line"><span>    public LazySet() {</span></span>
<span class="line"><span>        head = new ValidatedNode&#x3C;>(Integer.MIN_VALUE);</span></span>
<span class="line"><span>        tail = new ValidatedNode&#x3C;>(Integer.MAX_VALUE);</span></span>
<span class="line"><span>        head.setNext(tail);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected boolean valid(Node&#x3C;T> pred, Node&#x3C;T> curr) {</span></span>
<span class="line"><span>    return pred.valid() &#x26;&#x26; curr.valid() &#x26;&#x26; pred.next() == curr;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>    return curr.valid() &#x26;&#x26; curr.key() == item.key();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                if (curr.key() != item.key()) {</span></span>
<span class="line"><span>                    return false;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                else {</span></span>
<span class="line"><span>                    curr.setInvalid();</span></span>
<span class="line"><span>                    pred.setNext(curr.next());</span></span>
<span class="line"><span>                    return true;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Validation is constant time.</p>
</li>
<li>
<p>Membership checking does not require any locking – it’s even wait-free (it traverses
the list once without locking).</p>
</li>
<li>
<p>Physical removal of logically removed nodes could be batched and performed when
convenient – thus reducing the number of times the physical chain of nodes is
changed, in turn reducing the expensive propagation of information between threads.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>Operations add and remove still require locking (as in OptimisticSet), which may
reduce the amount of parallelism.</li>
</ul>
</li>
</ul>
<p>Now lastly, let’s solve this using <em>no locks</em>!</p>
<h3 id="lock-free-access">Lock free access</h3>
<p>If we’re not using locks we need to use stronger synchronization primitives than locks.</p>
<p>Therefore we’ll use the <code>compare-and-set</code> operation.</p>
<p>Let’s try to implement <code>remove</code> using this:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    boolean done;</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() >= item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            done = pred.next().compareAndSet(pred.next(), curr.next());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } while (!done);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This is however a naive approach and will not work, unfortunately. If two threads call <code>remove</code> at the same time,
it is possible that only one of them are successful.</p>
<p>We will need to borrow the idea of marking and updating nodes from <code>LazySet</code>.</p>
<p>Which means:</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class AtomicMarkableReference&#x3C;V> {</span></span>
<span class="line"><span>    // Current reference and mark</span></span>
<span class="line"><span>    V, boolean get();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // if reference == expectRef set mark to newMark and return true</span></span>
<span class="line"><span>    // otherwise do not change anything and return false.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean attemptMark(V expectRef, boolean newMark);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // if reference == expectRef and mark == expectMark,</span></span>
<span class="line"><span>    // set reference to newRef, mark to newMark and return true;</span></span>
<span class="line"><span>    // otherwise, do not change anything and return false.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean compareAndSet(V expectRef, V newRef, boolean expectMark, boolean newMark)</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>There are some more implementation details about our nodes, but let’s skip that :).</p>
<pre class="astro-code dracula" style="background-color:#282A36;color:#F8F8F2; overflow-x: auto; white-space: pre-wrap; word-wrap: break-word;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() != item.key() || !curr.valid()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (!curr.setInvalid()) {</span></span>
<span class="line"><span>            continue;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        pred.setNextIfValid(curr, curr.next());</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // changed during logical removal: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() == item.key() &#x26;&#x26; curr.valid()) {</span></span>
<span class="line"><span>            // already in set and valid</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Node&#x3C;T> node = new LockFreeNode&#x3C;>(item).setNext(curr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (pred.setNextIfValid(curr, node)) {</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // pred changed during add: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr = super.find(head, item.key());</span></span>
<span class="line"><span>    return curr.valid() &#x26;&#x26; curr.key() == item.key();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>    boolean valid;</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr, succ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        pred = start;</span></span>
<span class="line"><span>        curr = start.next();</span></span>
<span class="line"><span>        do {</span></span>
<span class="line"><span>            succ, valid = curr.nextValid();</span></span>
<span class="line"><span>            while (!valid) {</span></span>
<span class="line"><span>                if (!pred.setNextIfValid(curr, succ)) continue retry;</span></span>
<span class="line"><span>                curr = succ; succ, valid = curr.nextValid();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        if (curr.key() >= key) return (pred, curr);</span></span>
<span class="line"><span>        pred = curr; curr = succ;</span></span>
<span class="line"><span>        } while (true);</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>No operations require locking: maximum potential for parallelism.</p>
</li>
<li>
<p>Membership checking does not require any locking – it’s even wait-free (it traverses
the list once without locking).</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>The implementation needs test-and-set-like synchronization primitives, which have to
be supported and come with their own performance costs.</p>
</li>
<li>
<p>Operations add and remove are lock-free but not wait-free: they may have to repeat
operations, and they may be delayed while they physically remove invalid nodes, with
the risk of introducing contention on nodes that have been already previously
logically deleted.</p>
</li>
</ul>
</li>
</ul>
<h3 id="when-to-lock-and-not">When to lock and not</h3>
<p>Each of the different implementations of concurrent set is the best choice for certain
applications and not for others:</p>
<ul>
<li>
<p><code>CoarseSet</code> works well with low contention.</p>
</li>
<li>
<p><code>FineSet</code> works well when threads tend to access the list orderly.</p>
</li>
<li>
<p><code>OptimisticSet</code> works well to let threads operate on disjoint portions of the list.</p>
</li>
<li>
<p><code>LazySet</code> works well when batching invalid node removal is convenient.</p>
</li>
<li>
<p><code>LockFreeSet</code> works well when locking is quite expensive</p>
</li>
</ul>  </div> <nav class="flex flex-col sm:flex-row justify-between mt-8 pt-4 border-t border-border" data-astro-cid-v5ro3oot> <a href="/school/tda384/tda384_9" class="nav-button prev-button mb-4 sm:mb-0" data-astro-cid-v5ro3oot> <span class="arrow" data-astro-cid-v5ro3oot>←</span> <span class="text" data-astro-cid-v5ro3oot> <span class="label" data-astro-cid-v5ro3oot>Previous</span> <span class="title" data-astro-cid-v5ro3oot>Part 9 - Parallelizing computations</span> </span> </a>  </nav> </article>  </main> </div> </body></html> 