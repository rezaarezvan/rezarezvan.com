<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!
Weighted Graphs As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the weights on the edge. These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they could be anything - although many algortihms only work for positive weights." />
	<meta property="og:image" content="images/icon.png"/>
	<meta property="og:title" content="DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees" />
<meta property="og:description" content="In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!
Weighted Graphs As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the weights on the edge. These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they could be anything - although many algortihms only work for positive weights." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DSA_9/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-12-07T18:34:09+01:00" />
<meta property="article:modified_time" content="2022-12-07T18:34:09+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees"/>
<meta name="twitter:description" content="In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!
Weighted Graphs As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the weights on the edge. These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they could be anything - although many algortihms only work for positive weights."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees</h1>
			<div class="meta">Posted on Dec 7, 2022</div>
		</div>
		

		<section class="body">
			<p>In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!</p>
<h3 id="weighted-graphs">Weighted Graphs</h3>
<p>As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the <em>weights</em> on the edge.
These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they <em>could</em> be anything - although many algortihms only work for positive weights.</p>
<h3 id="spanning-trees">Spanning Trees</h3>
<p>A <em>spanning tree</em> of an <strong>undircted</strong> graph, $G$, is a <em>subgraph</em> $T$ such that:</p>
<ul>
<li>
<p>is <em>connected</em></p>
</li>
<li>
<p>is acyclic</p>
</li>
<li>
<p>includes all of the nodes</p>
</li>
</ul>
<p>The important thing here is that the graph is <strong>connected</strong>, which means we don&rsquo;t have any <em>lose</em> subgraphs, we must have one <strong>connected</strong> unit.</p>
<h3 id="minimum-spanning-tree-problem">Minimum Spanning Tree Problem</h3>
<p>Given a connected, undirected <strong>weighted</strong> graph, $G$ - what is the spanning tree with the <em>minimum total weight</em></p>
<p>This specific tree is called the <em>MST</em>, or <strong>M</strong>inimum <strong>S</strong>panning <strong>T</strong>ree. MSTs have a lot of applications in the real-world.</p>
<p>Let&rsquo;s begin to look at some algortihms which find these MSTs.</p>
<h3 id="greedy-algortihm">Greedy algortihm</h3>
<p>Before we jump into the actual algortimh, let&rsquo;s look at some fundamental properties first.</p>
<ul>
<li>
<p>A <em>cut</em> in a graph is a <em>partition</em> of its nodes into two (nonempty) sets.</p>
</li>
<li>
<p>A <em>crossing edge</em> <strong>connects</strong> a node in one set with a node in another set.</p>
</li>
</ul>
<p>With these two properies, there&rsquo;s a theroem which proves that:</p>
<ul>
<li>Given any cut, the crossing edge of <strong>minimal weight</strong> is in the MST</li>
</ul>
<p>Algortihm idea:</p>
<ul>
<li>
<p>Start with all edges  colored gray</p>
</li>
<li>
<p>Find <em>cut</em> with no black <em>crossing edges</em>; Color it&rsquo;s min-weight edge black</p>
</li>
<li>
<p>Repeat until $V - 1$ edges are black</p>
</li>
</ul>
<p>This isn&rsquo;t <em>quite</em> enough for an actual implementation since:</p>
<ul>
<li>
<p>How do we choose the cut?</p>
</li>
<li>
<p>How do we <em>actually</em> choose the edge with minimum weight after finding all crossing edges?</p>
</li>
</ul>
<p>We&rsquo;ll now cover some actual algortihms which implements this.</p>
<h3 id="overview">Overview</h3>
<p>We&rsquo;ll cover <em>Kruskal&rsquo;s algortihm</em> and <em>Prim&rsquo;s algoritmh</em></p>
<p>The basic idea for Kruskal&rsquo;s is:</p>
<ul>
<li>
<p>Consider edges in ascending order of weight</p>
</li>
<li>
<p>Add next edge to the MST, unless doing so would create a cycle</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>And for Prim&rsquo;s algortihm:</p>
<ul>
<li>
<p>Start with node 0 and greedily grow the MST</p>
</li>
<li>
<p>Add to the MST the minimum weight edge with exactly one endpoint in the MST</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>We&rsquo;ll begin with Kruskal&rsquo;s algoritm</p>
<h3 id="kruskals-algortimh">Kruskal&rsquo;s Algortimh</h3>
<p>So, as in the overview, kruskal&rsquo;s algortihm is quite simple in the idea - but the only implementation challenge is - how do we determine if we create a cycle?</p>
<p>But let&rsquo;s break it down. The algortimh stores several <em>disjoint</em> subtrees of the final MST - when we add a edge, it merges two of thes subtrees.</p>
<p>So testing for cyclicty, we need to check if two nodes appear in the same set!</p>
<p>There&rsquo;s actually a good (and well-known) data strucute for this exact problem, the <em>disjoint-set</em> data structure.
It supports merging and testing in $\mathcal{O}(log*\ n)$ time. (Note log* is an actual function, it&rsquo;s constant for all practical purpoes)</p>
<p>A pseudo-code implementation would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>def kruskals(graph: Graph):
</span></span><span style="display:flex;"><span>    result = []
</span></span><span style="display:flex;"><span>    i, e = 0, 0
</span></span><span style="display:flex;"><span>    graph = sort(graph)
</span></span><span style="display:flex;"><span>    parent = []
</span></span><span style="display:flex;"><span>    rank = []
</span></span><span style="display:flex;"><span>    for vertex in range(graph.V):
</span></span><span style="display:flex;"><span>        parent.append(vertex)
</span></span><span style="display:flex;"><span>        rank.append(0)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    while e &lt; graph.V - 1:
</span></span><span style="display:flex;"><span>        u, v, w = graph[i]
</span></span><span style="display:flex;"><span>        i = i + 1
</span></span><span style="display:flex;"><span>        x = graph.find(parent, u)
</span></span><span style="display:flex;"><span>        y = graph.find(parent, v)
</span></span><span style="display:flex;"><span>        if x != y:
</span></span><span style="display:flex;"><span>            e = e + 1
</span></span><span style="display:flex;"><span>            result.append([u, v, w])
</span></span><span style="display:flex;"><span>            graph.apply_union(parent, rank, x, y)
</span></span></code></pre></div><h3 id="prims-algortim">Prim&rsquo;s algortim</h3>
<p>The challenge here is instead to find and remove the min weight edge with exactly one endpoint in T.</p>
<p>If try all edges we will ofcourse have a compleixty of $\mathcal{O}(E^2)$. So let&rsquo;s not do that :)</p>
<p>However, if we use a priority queue, we can get a $\mathcal{O}(E\ log(E))$. This is still the &rsquo;lazy&rsquo; version but let&rsquo;s look at the idea:</p>
<p>Maintain a PQ of edges having (at least) one endpoint in T:</p>
<ul>
<li>
<p>Remove the minimum edge to determine next edge $e = v - w$ to add to T.</p>
</li>
<li>
<p>Disregard $e$ if both endpoints $v$ and $w$ are marked (both in T).</p>
</li>
<li>
<p>Otherwise, let $w$ be the unmarked node (not in T).</p>
<ul>
<li>
<p>Add to the PQ, any outgoing edge from $w$ (assuming other endpoint is not in T).</p>
</li>
<li>
<p>Add $e$ to T and mark $w$.</p>
</li>
</ul>
</li>
</ul>
<p>The <em>eager</em> solution would be the same <em>but</em>:
Maintain a PQ of <strong>nodes</strong> (PQ has at most one entry per node) connected by an edge to T,
where priority of node $v$ = weight of shortest edge connecting $v$ to T.</p>
<ul>
<li>
<p>Remove the minimum node $v$ and add its associtaded edge $e = v - w$ to T.</p>
</li>
<li>
<p>Update PQ by considering all edges $e = v - u$ incident to $v$</p>
<ul>
<li>
<p>Ignore if $u$ is already in T.</p>
</li>
<li>
<p>Add $u$ to PQ if not already on it.</p>
</li>
<li>
<p><strong>Decrease priortiy</strong> of $u$ if $v - u$ becomes shortest edge connecting $u$ to T.</p>
</li>
</ul>
</li>
</ul>
<p>Note this requires an index PQ, which we haven&rsquo;t implemented or went over.</p>
<h3 id="complexity">Complexity</h3>
<p>The complexity of these algorithms are:</p>
<ul>
<li>
<p>Prim&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Kruskal&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
</ul>
<h3 id="shortest-path-algorithms">Shortest Path Algorithms</h3>
<p>Finding the shortest path in a given tree is a very complex problem which we will encounter in the real-world in many applications!</p>
<p>For example in: Map Navigation, Robot navigation, Urban traffic planning, Network routing (OSPF, BGP, RIP) etc.</p>
<h3 id="variants">Variants</h3>
<p>There are many different problems when it comes to shortest path problems - Do we want the shorest path between:</p>
<ul>
<li>
<p>Single source: One node, S, to <em>every other node</em></p>
</li>
<li>
<p>Single sink: From every node to one node, T.</p>
</li>
<li>
<p>Source-sink: From one node, S, to another node, T.</p>
</li>
<li>
<p>All pairs: Between all possible pairs of nodes.</p>
</li>
</ul>
<p>But we also need to weigh in, is there any restrictions on the edge weights?
Also if we have any restraints on cycles?</p>
<p>But with all this in mind - let&rsquo;s simplifiy - Shorest path from S to each node V <strong>exists</strong>.</p>
<p>If you remember, here&rsquo;s our ADT/API for directed graphs:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Graph&lt;Vertices&gt;:
</span></span><span style="display:flex;"><span>    // Adds an edge to the graph
</span></span><span style="display:flex;"><span>    add_edge(e: Edge&lt;Vertices&gt;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes an edge from the graph
</span></span><span style="display:flex;"><span>    remove_edge(e: Edge&lt;Vertices&gt;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns true if the edge is present in the graph, otherwise false
</span></span><span style="display:flex;"><span>    contains_edge(e: Edge&lt;Vertices&gt;) -&gt; boolean
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns all the edges which are connected with the vertices
</span></span><span style="display:flex;"><span>    outgoing_edges(from: Vertices) -&gt; Collection&lt;Edge&lt;Vertices&gt;&gt;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the number of vertices present in the graph
</span></span><span style="display:flex;"><span>    n_vertices() -&gt; Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the number of edges present in the graph
</span></span><span style="display:flex;"><span>    n_edges() -&gt; Int
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Edge&lt;Vertices&gt;:
</span></span><span style="display:flex;"><span>    from   : Vertices
</span></span><span style="display:flex;"><span>    to     : Vertices
</span></span><span style="display:flex;"><span>    weight : float = 1.0
</span></span></code></pre></div><h3 id="single-source-shortest-paths">Single-source shortest paths</h3>
<p>The <em>single-source shortest path</em> problem or, SSSP for short. We want to find the shorest path from S to every other node.</p>
<p>The solution is spanning trees! However, it&rsquo;s not the MST but the so called <strong>shortest-paths tree</strong>, SPT.</p>
<p>In an SPT, the starting node $s$ is the root of the tree:</p>
<ul>
<li>
<p>How do we retrace the shorest path from and to any nodes?</p>
<ul>
<li>
<p>This consits of all ancestors of $t$, <strong>in reverse order</strong></p>
</li>
<li>
<p>Therefore, all information we need is the parent of every node in the SPT</p>
</li>
</ul>
</li>
<li>
<p>How do we determine the length of the shortest path from and to any nodes?</p>
<ul>
<li>
<p>This is the sum of the edge in that path</p>
</li>
<li>
<p>So eithe we need to store the edge weight, or the edge itself in the SPT</p>
</li>
</ul>
</li>
</ul>
<p>So a generalized generic graphsearch would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>GraphSearch(start: V):
</span></span><span style="display:flex;"><span>    put start in collection
</span></span><span style="display:flex;"><span>    repeat until the colletion is empty:
</span></span><span style="display:flex;"><span>        remove a vertex v
</span></span><span style="display:flex;"><span>        if v is not visited:
</span></span><span style="display:flex;"><span>            mark v as visited
</span></span><span style="display:flex;"><span>            add all unvisited adjacent nodes
</span></span></code></pre></div><p>Now let&rsquo;s suppose this collection is a <strong>priorty queue</strong> - the weights are the <strong>total cost from s to v</strong></p>
<p>This is the so called Dijkstra&rsquo;s/uniform cost algorithm/search.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>UCS(start: V):
</span></span><span style="display:flex;"><span>    Q = PQ // Order by the cost from start
</span></span><span style="display:flex;"><span>    Q.put(start)
</span></span><span style="display:flex;"><span>    while is not Q.isempty():
</span></span><span style="display:flex;"><span>        Q.remove_min()
</span></span><span style="display:flex;"><span>        if v not in visited:
</span></span><span style="display:flex;"><span>            visited.add(v) // mark as visited
</span></span><span style="display:flex;"><span>            for unvisited vertex w adjacent to v:
</span></span><span style="display:flex;"><span>                the cost from s to w = cost from s to v + the cost from v to w
</span></span><span style="display:flex;"><span>                Q.put(w)
</span></span></code></pre></div><p>This is the so called <strong>single source</strong> algortihm, if we want a <strong>source-sink</strong> we just add:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>UCS(start: V):
</span></span><span style="display:flex;"><span>    Q = PQ // Order by the cost from start
</span></span><span style="display:flex;"><span>    Q.put(start)
</span></span><span style="display:flex;"><span>    while is not Q.isempty():
</span></span><span style="display:flex;"><span>        Q.remove_min()
</span></span><span style="display:flex;"><span>        if v is the goal, return the shortest path from s to v
</span></span><span style="display:flex;"><span>        if v not in visited:
</span></span><span style="display:flex;"><span>            visited.add(v) // mark as visited
</span></span><span style="display:flex;"><span>            for unvisited vertex w adjacent to v:
</span></span><span style="display:flex;"><span>                the cost from s to w = cost from s to v + the cost from v to w
</span></span><span style="display:flex;"><span>                Q.put(w)
</span></span></code></pre></div><h3 id="shortest-path-in-a-dag">Shortest path in a DAG</h3>
<p>If we know the graph doesn&rsquo;t contain any cycles, this problem become <strong>a lot</strong> easier.</p>
<p>We use the same algortihm as a UCS - but we don&rsquo;t need a PQ and we can consider the nodes in a <em>toplogical order</em>.</p>
<p>This reduces the complexity to $\mathcal{O}(E)$.</p>
<h3 id="negative-weights">Negative weights</h3>
<p>Dijkstras/UCS won&rsquo;t work with negative edge weights - we really can&rsquo;t fix this, so instead we use the <em>Bellman-ford</em> algorithm.</p>
<h3 id="complexity-1">Complexity</h3>
<p>Here&rsquo;s a table of all the complexites:</p>
<ul>
<li>
<p>Topological Sort</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No directed cycles</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E + V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UCS/Dijkstras</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(E)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dijkstras eager</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(V))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Bellman-ford</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative <strong>cycles</strong></li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="summary">Summary</h3>
<p>So the summary really here is knowing when to use what depening on what you have.</p>
<p>So in the case we have nonnegative weights (which is the most often scenario),
we can almost alway use UCS/Dijkstras, since this is almost linear.</p>
<p>If we encounter a DAG, we should perform a Topological sort algorithm, since it&rsquo;s linear</p>
<p>Negative weights and negative cycles, If we have no negatice cycles - then Bellman-ford is the approach,
otherwise we can find <strong>some path</strong> via Bellman-ford.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
