<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"><meta property="og:site_name" content="rezvan"><title>DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees | rezvan</title>
  <meta property="og:title" content="DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees | rezvan"><meta property="og:description" content="">
  <meta property="og:type" content="blog">
  <meta property="og:link" content="https://rezvan.xyz/school/DSA_9/"><link rel="shortcut icon" type="image/png" href=https://rezvan.xyz//images/icon.png />
  <meta property="og:image" content="https://rezvan.xyz//images/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz//css/main.css" />

    <head>
    <link rel="stylesheet" href="../../themes/void/static/css/main.css">
</head>

<div class="js-toggle-wrapper">
    <div class="js-toggle">
        <div class="js-toggle-track">
            <div class="js-toggle-track-check">
                <img src="data:image/png;base64,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" role="presentation" style="pointer-events: none;" width="16" height="16">
            </div>
            <div class="js-toggle-track-x">
                <img src="data:image/png;base64,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" role="presentation" style="pointer-events: none;" width="16" height="16">
            </div>
        </div>
        <div class="js-toggle-thumb"></div>
        <input class="js-toggle-screenreader-only" type="checkbox" aria-label="Switch between Dark and Light mode">
    </div>
</div>

<style>

 

body.dark-mode,
body.dark-mode main {
    background-color: #0a0a0a;
    color: #eee;
}

body.dark-mode a {
    color: #eee;
    text-decoration: none;
}

body.dark-mode p {
    color: #eee;
}

body.dark-mode article a{
    text-decoration: underline;
}

body.dark-mode .post_listed .title {
    color: #eee;
}

body.dark-mode .post_listed .title:hover {
    background-color: #eee;
    color: #0a0a0a;
}

body.dark-mode .post_listed .post_time {
    color: #aaa;
}

body.dark-mode .header_title {
    color: #fff;
}

body.dark-mode .nav a {
    color: #eee;
}

body.dark-mode .nav a:visited {
    color: #eee;
}

body.dark-mode .nav a:hover {
    color: #0a0a0a;
}

 
body.dark-mode .title {
    color: #eee;
}


.js-toggle-wrapper {
    display: table;
     
    margin: 5px auto;
}

.js-toggle {
    touch-action: pan-x;
    display: inline-block;
    position: relative;
    cursor: pointer;
    background-color: transparent;
    border: 0;
    padding: 0;
    -webkit-touch-callout: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-tap-highlight-color: transparent;
  }

  .js-toggle-screenreader-only {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
  }

  .js-toggle-track {
    width: 50px;
    height: 24px;
    padding: 0;
    border-radius: 30px;
    background-color: hsl(222, 14%, 7%);
    transition: all 0.2s ease;
  }

  .js-toggle-track-check {
    position: absolute;
    width: 17px;
    height: 17px;
    left: 5px;
    top: 0px;
    bottom: 0px;
    margin-top: auto;
    margin-bottom: auto;
    line-height: 0;
    opacity: 0;
    transition: opacity 0.25s ease;
  }

  .js-toggle--checked .js-toggle-track-check {
    opacity: 1;
    transition: opacity 0.25s ease;
  }

  .js-toggle-track-x {
    position: absolute;
    width: 17px;
    height: 17px;
    right: 5px;
    top: 0px;
    bottom: 0px;
    margin-top: auto;
    margin-bottom: auto;
    line-height: 0;
    opacity: 1;
    transition: opacity 0.25s ease;
  }

  .js-toggle--checked .js-toggle-track-x {
    opacity: 0;
  }

  .js-toggle-thumb {
    position: absolute;
    top: 1px;
    left: 1px;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background-color: #fafafa;
    box-sizing: border-box;
    transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1) 0ms;
    transform: translateX(0);
  }

  .js-toggle--checked .js-toggle-thumb {
    transform: translateX(26px);
    border-color: #19ab27;
  }

  .js-toggle--focus .js-toggle-thumb {
    box-shadow: 0px 0px 2px 3px rgb(255, 167, 196);
  }

  .js-toggle:active .js-toggle-thumb {
    box-shadow: 0px 0px 5px 5px rgb(255, 167, 196);
  }
</style>

<script>
    var body = document.body;
	var switcher = document.getElementsByClassName('js-toggle')[0];

	
	switcher.addEventListener("click", function() {
        this.classList.toggle('js-toggle--checked');
        this.classList.add('js-toggle--focus');
		
		if (this.classList.contains('js-toggle--checked')) {
			body.classList.add('dark-mode');
			
			localStorage.setItem('darkMode', 'true');
		} else {
			body.classList.remove('dark-mode');
			setTimeout(function() {
				localStorage.removeItem('darkMode');
			}, 100);
		}
	})

	
	if (localStorage.getItem('darkMode')) {
		
        switcher.classList.add('js-toggle--checked');
        body.classList.add('dark-mode');
	}
</script>


</head>

<body>
  <div class="wrapper">
	<div class="content">
		<div class="header_main">

    <a href="https://rezvan.xyz/"><p class="header_title">rezvan</p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

    </a>

    <br>

    <nav id="main">
        
        <a href="/about/">about</a>
        
        <a href="/cv/">cv</a>
        
        <a href="/school/">school</a>
        
    </nav></div>

  <article><div class="title_wrapper">
			<h1 class="title">DSA: Part 9 - Shortest Path Algortihms &amp; Spanning Trees</h1><p class="single_time">Dec 7, 2022</p></div>
		<section class="post">
			<p>In this part we&rsquo;ll cover spanning trees along with how we can use these to solve pathfinding problems!</p>
<h3 id="weighted-graphs">Weighted Graphs</h3>
<p>As we have seen in the last part - graphs can we directed or undircted, the same thing goes for the <em>weights</em> on the edge.
These represent some kind of &lsquo;cost&rsquo;, usually these are positive float numbers, but they <em>could</em> be anything - although many algortihms only work for positive weights.</p>
<h3 id="spanning-trees">Spanning Trees</h3>
<p>A <em>spanning tree</em> of an <strong>undircted</strong> graph, $G$, is a <em>subgraph</em> $T$ such that:</p>
<ul>
<li>
<p>is <em>connected</em></p>
</li>
<li>
<p>is acyclic</p>
</li>
<li>
<p>includes all of the nodes</p>
</li>
</ul>
<p>The important thing here is that the graph is <strong>connected</strong>, which means we don&rsquo;t have any <em>lose</em> subgraphs, we must have one <strong>connected</strong> unit.</p>
<h3 id="minimum-spanning-tree-problem">Minimum Spanning Tree Problem</h3>
<p>Given a connected, undirected <strong>weighted</strong> graph, $G$ - what is the spanning tree with the <em>minimum total weight</em></p>
<p>This specific tree is called the <em>MST</em>, or <strong>M</strong>inimum <strong>S</strong>panning <strong>T</strong>ree. MSTs have a lot of applications in the real-world.</p>
<p>Let&rsquo;s begin to look at some algortihms which find these MSTs.</p>
<h3 id="greedy-algortihm">Greedy algortihm</h3>
<p>Before we jump into the actual algortimh, let&rsquo;s look at some fundamental properties first.</p>
<ul>
<li>
<p>A <em>cut</em> in a graph is a <em>partition</em> of its nodes into two (nonempty) sets.</p>
</li>
<li>
<p>A <em>crossing edge</em> <strong>connects</strong> a node in one set with a node in another set.</p>
</li>
</ul>
<p>With these two properies, there&rsquo;s a theroem which proves that:</p>
<ul>
<li>Given any cut, the crossing edge of <strong>minimal weight</strong> is in the MST</li>
</ul>
<p>Algortihm idea:</p>
<ul>
<li>
<p>Start with all edges  colored gray</p>
</li>
<li>
<p>Find <em>cut</em> with no black <em>crossing edges</em>; Color it&rsquo;s min-weight edge black</p>
</li>
<li>
<p>Repeat until $V - 1$ edges are black</p>
</li>
</ul>
<p>This isn&rsquo;t <em>quite</em> enough for an actual implementation since:</p>
<ul>
<li>
<p>How do we choose the cut?</p>
</li>
<li>
<p>How do we <em>actually</em> choose the edge with minimum weight after finding all crossing edges?</p>
</li>
</ul>
<p>We&rsquo;ll now cover some actual algortihms which implements this.</p>
<h3 id="overview">Overview</h3>
<p>We&rsquo;ll cover <em>Kruskal&rsquo;s algortihm</em> and <em>Prim&rsquo;s algoritmh</em></p>
<p>The basic idea for Kruskal&rsquo;s is:</p>
<ul>
<li>
<p>Consider edges in ascending order of weight</p>
</li>
<li>
<p>Add next edge to the MST, unless doing so would create a cycle</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>And for Prim&rsquo;s algortihm:</p>
<ul>
<li>
<p>Start with node 0 and greedily grow the MST</p>
</li>
<li>
<p>Add to the MST the minimum weight edge with exactly one endpoint in the MST</p>
</li>
<li>
<p>Repeat until there are $V - 1$ edges in the MST</p>
</li>
</ul>
<p>We&rsquo;ll begin with Kruskal&rsquo;s algoritm</p>
<h3 id="kruskals-algortimh">Kruskal&rsquo;s Algortimh</h3>
<p>So, as in the overview, kruskal&rsquo;s algortihm is quite simple in the idea - but the only implementation challenge is - how do we determine if we create a cycle?</p>
<p>But let&rsquo;s break it down. The algortimh stores several <em>disjoint</em> subtrees of the final MST - when we add a edge, it merges two of thes subtrees.</p>
<p>So testing for cyclicty, we need to check if two nodes appear in the same set!</p>
<p>There&rsquo;s actually a good (and well-known) data strucute for this exact problem, the <em>disjoint-set</em> data structure.
It supports merging and testing in $\mathcal{O}(log*\ n)$ time. (Note log* is an actual function, it&rsquo;s constant for all practical purpoes)</p>
<p>A pseudo-code implementation would be:</p>
<pre tabindex="0"><code>def kruskals(graph: Graph):
    result = []
    i, e = 0, 0
    graph = sort(graph)
    parent = []
    rank = []
    for vertex in range(graph.V):
        parent.append(vertex)
        rank.append(0)

    while e &lt; graph.V - 1:
        u, v, w = graph[i]
        i = i + 1
        x = graph.find(parent, u)
        y = graph.find(parent, v)
        if x != y:
            e = e + 1
            result.append([u, v, w])
            graph.apply_union(parent, rank, x, y)
</code></pre><h3 id="prims-algortim">Prim&rsquo;s algortim</h3>
<p>The challenge here is instead to find and remove the min weight edge with exactly one endpoint in T.</p>
<p>If try all edges we will ofcourse have a compleixty of $\mathcal{O}(E^2)$. So let&rsquo;s not do that :)</p>
<p>However, if we use a priority queue, we can get a $\mathcal{O}(E\ log(E))$. This is still the &rsquo;lazy&rsquo; version but let&rsquo;s look at the idea:</p>
<p>Maintain a PQ of edges having (at least) one endpoint in T:</p>
<ul>
<li>
<p>Remove the minimum edge to determine next edge $e = v - w$ to add to T.</p>
</li>
<li>
<p>Disregard $e$ if both endpoints $v$ and $w$ are marked (both in T).</p>
</li>
<li>
<p>Otherwise, let $w$ be the unmarked node (not in T).</p>
<ul>
<li>
<p>Add to the PQ, any outgoing edge from $w$ (assuming other endpoint is not in T).</p>
</li>
<li>
<p>Add $e$ to T and mark $w$.</p>
</li>
</ul>
</li>
</ul>
<p>The <em>eager</em> solution would be the same <em>but</em>:
Maintain a PQ of <strong>nodes</strong> (PQ has at most one entry per node) connected by an edge to T,
where priority of node $v$ = weight of shortest edge connecting $v$ to T.</p>
<ul>
<li>
<p>Remove the minimum node $v$ and add its associtaded edge $e = v - w$ to T.</p>
</li>
<li>
<p>Update PQ by considering all edges $e = v - u$ incident to $v$</p>
<ul>
<li>
<p>Ignore if $u$ is already in T.</p>
</li>
<li>
<p>Add $u$ to PQ if not already on it.</p>
</li>
<li>
<p><strong>Decrease priortiy</strong> of $u$ if $v - u$ becomes shortest edge connecting $u$ to T.</p>
</li>
</ul>
</li>
</ul>
<p>Note this requires an index PQ, which we haven&rsquo;t implemented or went over.</p>
<h3 id="complexity">Complexity</h3>
<p>The complexity of these algorithms are:</p>
<ul>
<li>
<p>Prim&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Kruskal&rsquo;s</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
</ul>
<h3 id="shortest-path-algorithms">Shortest Path Algorithms</h3>
<p>Finding the shortest path in a given tree is a very complex problem which we will encounter in the real-world in many applications!</p>
<p>For example in: Map Navigation, Robot navigation, Urban traffic planning, Network routing (OSPF, BGP, RIP) etc.</p>
<h3 id="variants">Variants</h3>
<p>There are many different problems when it comes to shortest path problems - Do we want the shorest path between:</p>
<ul>
<li>
<p>Single source: One node, S, to <em>every other node</em></p>
</li>
<li>
<p>Single sink: From every node to one node, T.</p>
</li>
<li>
<p>Source-sink: From one node, S, to another node, T.</p>
</li>
<li>
<p>All pairs: Between all possible pairs of nodes.</p>
</li>
</ul>
<p>But we also need to weigh in, is there any restrictions on the edge weights?
Also if we have any restraints on cycles?</p>
<p>But with all this in mind - let&rsquo;s simplifiy - Shorest path from S to each node V <strong>exists</strong>.</p>
<p>If you remember, here&rsquo;s our ADT/API for directed graphs:</p>
<pre tabindex="0"><code>class Graph&lt;Vertices&gt;:
    // Adds an edge to the graph
    add_edge(e: Edge&lt;Vertices&gt;)

    // Removes an edge from the graph
    remove_edge(e: Edge&lt;Vertices&gt;)

    // Returns true if the edge is present in the graph, otherwise false
    contains_edge(e: Edge&lt;Vertices&gt;) -&gt; boolean

    // Returns all the edges which are connected with the vertices
    outgoing_edges(from: Vertices) -&gt; Collection&lt;Edge&lt;Vertices&gt;&gt;

    // Returns the number of vertices present in the graph
    n_vertices() -&gt; Int

    // Returns the number of edges present in the graph
    n_edges() -&gt; Int

class Edge&lt;Vertices&gt;:
    from   : Vertices
    to     : Vertices
    weight : float = 1.0
</code></pre><h3 id="single-source-shortest-paths">Single-source shortest paths</h3>
<p>The <em>single-source shortest path</em> problem or, SSSP for short. We want to find the shorest path from S to every other node.</p>
<p>The solution is spanning trees! However, it&rsquo;s not the MST but the so called <strong>shortest-paths tree</strong>, SPT.</p>
<p>In an SPT, the starting node $s$ is the root of the tree:</p>
<ul>
<li>
<p>How do we retrace the shorest path from and to any nodes?</p>
<ul>
<li>
<p>This consits of all ancestors of $t$, <strong>in reverse order</strong></p>
</li>
<li>
<p>Therefore, all information we need is the parent of every node in the SPT</p>
</li>
</ul>
</li>
<li>
<p>How do we determine the length of the shortest path from and to any nodes?</p>
<ul>
<li>
<p>This is the sum of the edge in that path</p>
</li>
<li>
<p>So eithe we need to store the edge weight, or the edge itself in the SPT</p>
</li>
</ul>
</li>
</ul>
<p>So a generalized generic graphsearch would be:</p>
<pre tabindex="0"><code>GraphSearch(start: V):
    put start in collection
    repeat until the colletion is empty:
        remove a vertex v
        if v is not visited:
            mark v as visited
            add all unvisited adjacent nodes
</code></pre><p>Now let&rsquo;s suppose this collection is a <strong>priorty queue</strong> - the weights are the <strong>total cost from s to v</strong></p>
<p>This is the so called Dijkstra&rsquo;s/uniform cost algorithm/search.</p>
<pre tabindex="0"><code>UCS(start: V):
    Q = PQ // Order by the cost from start
    Q.put(start)
    while is not Q.isempty():
        Q.remove_min()
        if v not in visited:
            visited.add(v) // mark as visited
            for unvisited vertex w adjacent to v:
                the cost from s to w = cost from s to v + the cost from v to w
                Q.put(w)
</code></pre><p>This is the so called <strong>single source</strong> algortihm, if we want a <strong>source-sink</strong> we just add:</p>
<pre tabindex="0"><code>UCS(start: V):
    Q = PQ // Order by the cost from start
    Q.put(start)
    while is not Q.isempty():
        Q.remove_min()
        if v is the goal, return the shortest path from s to v
        if v not in visited:
            visited.add(v) // mark as visited
            for unvisited vertex w adjacent to v:
                the cost from s to w = cost from s to v + the cost from v to w
                Q.put(w)
</code></pre><h3 id="shortest-path-in-a-dag">Shortest path in a DAG</h3>
<p>If we know the graph doesn&rsquo;t contain any cycles, this problem become <strong>a lot</strong> easier.</p>
<p>We use the same algortihm as a UCS - but we don&rsquo;t need a PQ and we can consider the nodes in a <em>toplogical order</em>.</p>
<p>This reduces the complexity to $\mathcal{O}(E)$.</p>
<h3 id="negative-weights">Negative weights</h3>
<p>Dijkstras/UCS won&rsquo;t work with negative edge weights - we really can&rsquo;t fix this, so instead we use the <em>Bellman-ford</em> algorithm.</p>
<h3 id="complexity-1">Complexity</h3>
<p>Here&rsquo;s a table of all the complexites:</p>
<ul>
<li>
<p>Topological Sort</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No directed cycles</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E + V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>UCS/Dijkstras</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(E))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(E)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Dijkstras eager</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative weights</li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ log(V))$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
<li>
<p>Bellman-ford</p>
<ul>
<li>
<p>Restriction</p>
<ul>
<li>No negative <strong>cycles</strong></li>
</ul>
</li>
<li>
<p>Worst-case time complexity</p>
<ul>
<li>$\mathcal{O}(E\ V)$</li>
</ul>
</li>
<li>
<p>Space-usage</p>
<ul>
<li>$\mathcal{O}(V)$</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="summary">Summary</h3>
<p>So the summary really here is knowing when to use what depening on what you have.</p>
<p>So in the case we have nonnegative weights (which is the most often scenario),
we can almost alway use UCS/Dijkstras, since this is almost linear.</p>
<p>If we encounter a DAG, we should perform a Topological sort algorithm, since it&rsquo;s linear</p>
<p>Negative weights and negative cycles, If we have no negatice cycles - then Bellman-ford is the approach,
otherwise we can find <strong>some path</strong> via Bellman-ford.</p>

		</section>
  </article>
	</div>

	<footer><p class="footer_msg">memento mori</p></footer>

  </div>
</body>
</html>
