<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"><meta property="og:site_name" content="rezvan"><title>Concurrent Programming: Part 4 - Synchronization problems with semaphores | rezvan</title>
  <meta property="og:title" content="Concurrent Programming: Part 4 - Synchronization problems with semaphores | rezvan"><meta property="og:description" content="">
  <meta property="og:type" content="blog">
  <meta property="og:link" content="https://rezvan.xyz/school/concurrent_programming_4/"><link rel="shortcut icon" type="image/png" href=https://rezvan.xyz//images/icon.png />
  <meta property="og:image" content="https://rezvan.xyz//images/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz//css/main.css" />    
</head>

<body>
  <div class="wrapper">
	<div class="content">
		<div class="header_main">
	<a href="https://rezvan.xyz/"><p class="header_title">rezvan</p>
	</a>
  <br>
  <nav id="main">
    
      <a href="/About/">About</a>
    
      <a href="/CV/">CV</a>
    
      <a href="/school/">School</a>
    
  </nav></div>

  <article><div class="title_wrapper">
			<h1 class="title">Concurrent Programming: Part 4 - Synchronization problems with semaphores</h1><p class="single_time">Jan 24, 2023</p></div>
		<section class="post">
			<p>In this part we&rsquo;ll cover how to solve some classical synchronization problems using threads and semaphores.</p>
<h3 id="dining-philosophers">Dining Philosophers</h3>
<p>To refresh our memory on the problem let&rsquo;s cover it again:</p>
<p>The dining philosophers problem describes how to avoid deadlock (circular conditions).</p>
<p>We have five philosophers (threads) sitting at a dining table. A fork is between each adjacent pair of philosophers.</p>
<p>Each philosopher alternates between thinking (non-critical section) and eating (critical section).
In order to eat, a philosopher needs to pick up both forks that lie to the right and left of the philosopher.</p>
<p>Since the forks are shared, there is a synchronization problem.</p>
<h4 id="solution">Solution</h4>
<p>A good solution would allow:</p>
<ul>
<li>
<p>Having an arbitrary number of philosophers</p>
</li>
<li>
<p>Deadlock freedom</p>
</li>
<li>
<p>Starvation freedom</p>
</li>
<li>
<p>Reasonable efficiency, it is possible to eat in parallel.</p>
</li>
</ul>
<p>Let&rsquo;s create an interface for the table.</p>
<pre tabindex="0"><code>interface Table {

    // Philosopher at idx picks up both forks
    void getForks(int idx);

    // Philosopher at idx lies down both forks
    void putForks(int k);

}
</code></pre><p>Let&rsquo;s also represent each philosopher</p>
<pre tabindex="0"><code>class Philosopher {

    int idx;
    Table table;

    void think() {
        .
        .
        .
    }

    void eat() {
        .
        .
        .
    }

    void run() {

        while(true) {
            think();
            table.getForks();
            eat();
            table.putForks();
        }

    }

}
</code></pre><p>One possible solution is to number each fork and philosopher. That we can easily know what is right and left of each philosopher.</p>
<p>For example:</p>
<pre tabindex="0"><code>public int left(int k) {
    return k;
}

public int right(int k) {
    return (k + 1) % N;
}
</code></pre><p>To ensure mutual exclusion of the forks we can use semaphores.</p>
<p>We can even begin with using simple locks:</p>
<pre tabindex="0"><code>Lock[] forks = new Lock[N];

// To pick up fork i we do
forks[i].lock();

// To put down fork i we do
forks[i].unlock();
</code></pre><p>If we now implement a solution which makes all philosophers take up the left fork then the right fork.</p>
<p>We have a potential for deadlock, since if everyone picks up their left fork first. We have a circular waiting condition.</p>
<p>Instead, we implement a solution which ensures one philosopher picks up their right fork first, then left.
By breaking the symmetry we break the deadlock.</p>
<pre tabindex="0"><code>public void getForks(int k) {
    if (k == N) {
        forks[right(k)].lock();
        forks[left(k)].lock();
    }

    else {
        forks[left(k)].lock();
        forks[right(k)].lock();
    }
}
</code></pre><p>Another strategy could be limiting the amount of philosophers that can sit at a table. If we pick <code>M &lt; N</code>, we also ensure deadlock freedom.</p>
<p>We make each seat a semaphores like:</p>
<pre tabindex="0"><code>// M &lt; N
Semaphore seats = new Semaphore(M);

public void getForks(int k) {
    seats.down()

    forks[left(k)].lock();

    forks[right(k)].lock();
}

public void putForks(int k) {
    forks[left(k)].lock();

    forks[right(k)].lock();

    seats.down()
}
</code></pre><p>One thing that might not be obvious at first glance is that these solutions also ensure starvation freedom.
This is under the assumption that the locks/semaphores (and scheduling) are fair.</p>
<h3 id="producer-consumer">Producer-Consumer</h3>
<p>Producers and consumers exchange items through a so called shared (asynchronous) buffer.</p>
<p>The producr (asynchronously) produces items and places them on the buffer. While the consumer (asynchronously) consumes (removes) the items from the buffer.</p>

		</section>
  </article>
	</div>

	<footer><p class="footer_msg">Memento mori</p></footer>

  </div>
</body>
</html>
