<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DSA: Part 4 - Abstract Data Types - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="ADT vs Data Structures So what&rsquo;s the difference betwen a Abstract Data Type and an actual datastructure?
An ADT is a kind of specification of something - it specifies how we can intertact with that object, like an API.
It consits of methods and constructors but also plain-text specifications (like the complexity for example) and explainations.
A data structure on the other hand is an actual implementation of an ADT. It specifies how the object works interally." />
	<meta property="og:image" content="images/icon.png"/>
	<meta property="og:title" content="DSA: Part 4 - Abstract Data Types" />
<meta property="og:description" content="ADT vs Data Structures So what&rsquo;s the difference betwen a Abstract Data Type and an actual datastructure?
An ADT is a kind of specification of something - it specifies how we can intertact with that object, like an API.
It consits of methods and constructors but also plain-text specifications (like the complexity for example) and explainations.
A data structure on the other hand is an actual implementation of an ADT. It specifies how the object works interally." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DSA_4/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-11-28T20:30:47+01:00" />
<meta property="article:modified_time" content="2022-11-28T20:30:47+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DSA: Part 4 - Abstract Data Types"/>
<meta name="twitter:description" content="ADT vs Data Structures So what&rsquo;s the difference betwen a Abstract Data Type and an actual datastructure?
An ADT is a kind of specification of something - it specifies how we can intertact with that object, like an API.
It consits of methods and constructors but also plain-text specifications (like the complexity for example) and explainations.
A data structure on the other hand is an actual implementation of an ADT. It specifies how the object works interally."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">DSA: Part 4 - Abstract Data Types</h1>
			<div class="meta">Posted on Nov 28, 2022</div>
		</div>
		

		<section class="body">
			<h3 id="adt-vs-data-structures">ADT vs Data Structures</h3>
<p>So what&rsquo;s the difference betwen a <strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ype and an actual datastructure?</p>
<p>An ADT is a kind of specification of something - it specifies how we can intertact with that <em>object</em>, like an API.</p>
<p>It consits of methods and constructors but also plain-text specifications (like the complexity for example) and explainations.</p>
<p>A data structure on the other hand is an <strong>actual</strong> <em>implementation</em> of an ADT. It specifies how the <em>object</em> works <em>interally</em>.
But an important note is, that it doesn&rsquo;t need to be in an actual programming language - often it&rsquo;s just specified in pseudo-code.</p>
<h3 id="method-descriptions">Method Descriptions</h3>
<p>As explained above - an ADT has methods/functions - but these need to be specified/have a brief plain-text explaination.
For example, all these ADTs have the same functions, but work differently:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Stack&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    void add(Item x)
</span></span><span style="display:flex;"><span>    Item remove()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>Queue&lt;Item&gt;
</span></span><span style="display:flex;"><span>    void add(Item x)
</span></span><span style="display:flex;"><span>    Item remove()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>PrioQueue&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    void add(Item x)
</span></span><span style="display:flex;"><span>    Item remove()
</span></span></code></pre></div><h3 id="different-kind-of-adts">Different kind of ADTs</h3>
<p>Now we will cover all ADTs that we will encounter in this course!</p>
<h3 id="ordered-collections-stacks-queues-etc">Ordered collections: Stacks, Queues, etc</h3>
<h4 id="stacks">Stacks</h4>
<p>Since we have covered in depth as well as implemented stacks, let&rsquo;s just briefly go over them.</p>
<p>Stacks - LIFO (&rsquo;<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>pop()</code> <code>push()</code></p>
<p>So the ADT would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Stack&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Adds Item X to the top of the stack
</span></span><span style="display:flex;"><span>    void push(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns and removes the topmost element of the stack
</span></span><span style="display:flex;"><span>    Item pop()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the topmost element, without removing it
</span></span><span style="display:flex;"><span>    Item peek()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the stack is empty, False otherwise
</span></span><span style="display:flex;"><span>    boolean is_empty()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Returns the current size (length) of the stack
</span></span><span style="display:flex;"><span>    int size()
</span></span></code></pre></div><h4 id="queues">Queues</h4>
<p>Same goes for a queue - since we&rsquo;ve already covered this in depth, we&rsquo;ll just briefly recover it.</p>
<p>Queues - FIFO (&rsquo;<strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>enqueue()</code> <code>dequeue()</code></p>
<p>So the ADT can be described as:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Queue&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Adds Item X to the end of the queue
</span></span><span style="display:flex;"><span>    void enqueue(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes and returns the first item in the queue
</span></span><span style="display:flex;"><span>    Item dequeue()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the queue is empty, False otherwise
</span></span><span style="display:flex;"><span>    boolean empty()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the queue is full, False otherwise
</span></span><span style="display:flex;"><span>    boolean full()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the current size (length) of the queue
</span></span><span style="display:flex;"><span>    int qsize()
</span></span></code></pre></div><h4 id="stacks--queues--deques">Stacks + Queues = Deques</h4>
<p>If we combine these two ADTs that we&rsquo;ve become so familiar with - we get a so called double-ended queue!</p>
<p>Here&rsquo;s the ADT for it:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Deque&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Adds Item X to the front of the deque
</span></span><span style="display:flex;"><span>    void add_first(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Adds Item X to the end of the deque
</span></span><span style="display:flex;"><span>    void add_last(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes and returns the frontmost item in the deque
</span></span><span style="display:flex;"><span>    Item remove_first()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes and returns the last item in the deque
</span></span><span style="display:flex;"><span>    Item remove_last()
</span></span></code></pre></div><p>So why would we want to use a stack or queue - when their combination exists?</p>
<p>The answer is quite simple - it differs from problem to problem! Sometimes a stack might just be <em>exactly</em> what you want, and sometimes you might feel hindered or blocked by a ADT.</p>
<p>So you need to do research on what kind of ADT you should use before actually implementing one. Also cost/how hard the implementation will be is also a important factor.</p>
<h4 id="lists-generalsiing-stacks-and-queues">Lists: Generalsiing Stacks and Queues</h4>
<p>Lists is the ADT when we finally don&rsquo;t restrict ourselves to only add/remove the front/end element - and finally can add/remove wherever we want!</p>
<p>The ADT looks something like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>List&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Inserts Item X at position i in the list
</span></span><span style="display:flex;"><span>    void add(Item x, int i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes and returns the item at position i
</span></span><span style="display:flex;"><span>    Item remove(int i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the element on position i
</span></span><span style="display:flex;"><span>    Item get(int i)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Sets/replaces element i with x
</span></span><span style="display:flex;"><span>    void set(int i, Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the list is currently empty, otherwise False
</span></span><span style="display:flex;"><span>    boolean is_empty()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the current size (# of elements) in the list
</span></span><span style="display:flex;"><span>    int size()
</span></span></code></pre></div><h4 id="priority-queues">Priority Queues</h4>
<p>The only difference between priorty queues, stacks and regular queues is which element to remove.
A stack removes the &lsquo;youngest&rsquo; element, a queue removes the &lsquo;oldest&rsquo; element, and a priorty queue removes the &lsquo;minimum&rsquo; element. Minimum here means by some arbitrary ordering.</p>
<p>These are quite complicated to implement so we&rsquo;ll be implementing them a bit later.</p>
<h4 id="iterating-comparing-and-sorting">Iterating, Comparing and Sorting</h4>
<p>Iterating, comparing, and sorting are all very important when it comes to orded collections - we need to be able to iterate through the whole collection,
comparing items to each other, and of course the most important - sorting the collection!</p>
<p>These all feel like very &rsquo;low-level&rsquo; and natural things - but quite often we ourselves will need to implement these.
For example, iterating through a queue. Note that some data structures actually doesn&rsquo;t allow to iterate through out the collection!</p>
<p>Iteration also works differently, for example in Java it&rsquo;s called <code>iterator()</code> and in Python <code>__iter__()</code>.
One thing to note is that iterables and iterators are different. An <em>iterator</em> has a method that returns the next element, and a way of telling when the iteration is exhausted.</p>
<p>So, an <em>iterator</em> can only be iterated over once, while an <em>iterable</em> can be iterated many times, because it creates new iterators. Quite a mouthful.</p>
<p>So in Python for example a simple:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>for x in elements:
</span></span><span style="display:flex;"><span>    # do something with x
</span></span></code></pre></div><p>is translated to:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>it = elements.__iter__()
</span></span><span style="display:flex;"><span>while True:
</span></span><span style="display:flex;"><span>    try:
</span></span><span style="display:flex;"><span>        x = it.__next__()
</span></span><span style="display:flex;"><span>    expect StopIteration():
</span></span><span style="display:flex;"><span>        break
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    # do something  with x
</span></span></code></pre></div><p>A same kind of logic is applied when we want to compare items. If something is comparable they implement a <em>comparable</em> interface for example.
But often we want our own comparisons to something rather than the &rsquo;natural ordering&rsquo; the comparable interface provides. In these cases we need to implemnt different <em>comparators</em>.</p>
<p>Now sorting becomes quite trivial - the built in sorting methods either use the &rsquo;natural ordering&rsquo; comparator, or can take a comparator as an argument to sort it how we want.</p>
<h4 id="unordered-collections-maps-sets-and-graphs">Unordered collections: Maps, sets, and graphs</h4>
<p>These are just like the ordered collections, but without a specific order :)</p>
<h4 id="sets">Sets</h4>
<p>You should be quite familiar with sets from a discrete math course - but let&rsquo;s go over it anyways</p>
<p>A set is a collection of objects where:</p>
<ul>
<li>It cannot contain duplicates of the same object.</li>
<li>Basic operations for testing for &lsquo;membership&rsquo;, and adding/removing an element.</li>
<li>Methods for size of the set and testing for emptiness.</li>
<li>Usually a kind of iterator for looping over all elements/members in set.</li>
</ul>
<p>So the ADT coud look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Set&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Returns True if x is in the set, False otherwise
</span></span><span style="display:flex;"><span>    boolean contains(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Adds x to the set, if it&#39;s not already in the set
</span></span><span style="display:flex;"><span>    void add(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes x from the set, if it&#39;s present
</span></span><span style="display:flex;"><span>    void remove(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the set is currently empty, False otherwise
</span></span><span style="display:flex;"><span>    boolean is_empty()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the current size (# of elements) in the set
</span></span><span style="display:flex;"><span>    int size()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Iterates over all elements in the set
</span></span><span style="display:flex;"><span>    Iterator&lt;Item&gt; iterator()
</span></span></code></pre></div><h4 id="maps">Maps</h4>
<p>A map is a &lsquo;mapping&rsquo; from a &lsquo;key&rsquo; to a &lsquo;value&rsquo; with these properties:</p>
<ul>
<li>It cannot contain duplicates of the same &lsquo;key&rsquo;</li>
<li>The basic operations are <code>getting</code> and <code>setting</code> the &lsquo;value&rsquo; for a given &lsquo;key&rsquo;. Also removing a &lsquo;key&rsquo; along with its associated value&rsquo;.</li>
<li>Helper methods such as, <code>number_of_keys()</code>, <code>is_empty()</code></li>
<li>(Usually) an iterator to loop over all keys</li>
</ul>
<p>So an ADT would look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Map&lt;Key, Value&gt;:
</span></span><span style="display:flex;"><span>    // Returns True if there&#39;s an association for the key, k.
</span></span><span style="display:flex;"><span>    boolean contains(Key k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the value associated with key, k.
</span></span><span style="display:flex;"><span>    Value get(Key k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Associates the key, k, with the value, v.
</span></span><span style="display:flex;"><span>    void put(Key k, Value v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes the value associated with the key, k.
</span></span><span style="display:flex;"><span>    void remove(Key k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the Map is currently empty, False otherwise
</span></span><span style="display:flex;"><span>    boolean is_empty()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the current size (# of key-value pairs) in the map
</span></span><span style="display:flex;"><span>    int size()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Iterates over all keys in the map
</span></span><span style="display:flex;"><span>    Iterator&lt;Key&gt; keys()
</span></span></code></pre></div><p>&lsquo;Maps&rsquo; have a lot of associated names:</p>
<ul>
<li>Dictionaries</li>
<li>Symbol tables</li>
<li>Associative arrays</li>
<li>Lookup tables</li>
<li>finite-domain functions</li>
<li>$\dots$</li>
</ul>
<p>Maps can be seen as a further generalisation of list even. The integer positon is now replaced by a generic &lsquo;key&rsquo; type.</p>
<p>For actual implementation of maps, these are the following:</p>
<ul>
<li>Lists</li>
<li>Search trees
<ul>
<li>Binary search trees
<ul>
<li>Unbalanced BSTs</li>
<li>Balanced BSTs (red-black tree, AVL trees, $\dots$)</li>
</ul>
</li>
</ul>
</li>
<li>Hash tables
<ul>
<li>Separate chaining</li>
<li>Open addresing (Linear probing, quadratic probing, $\dots$)</li>
</ul>
</li>
<li>Randomised data structures
<ul>
<li>Skip lists, treaps, $\dots$</li>
</ul>
</li>
</ul>
<h4 id="a-set-is-degenerated-map">A Set is Degenerated Map</h4>
<p>If we have an implementation of a map, it&rsquo;s actually quite easy to turn it into a set. We just need to create an underlying map,
whose keys are the set items!</p>
<p>So a ADT solution would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Set&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    Map&lt;Item, Void&gt; underlying_map
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    boolean contains(Item x)  = underlying_map.contains(x)
</span></span><span style="display:flex;"><span>    void add(Item x)          = underlying_map.add(x, null)
</span></span><span style="display:flex;"><span>    void remove(Item x)       = underlying_map.remove(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    boolean is_empty()        = underlying_map.is_empty()
</span></span><span style="display:flex;"><span>    int size()                = underlying_map.size()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Iterator&lt;Item&gt; iterator() = underlying_map.keys()
</span></span></code></pre></div><h4 id="multisets-and-multimaps">Multisets and multimaps</h4>
<p>Sometimes we want to put several objects into the same &lsquo;slot&rsquo; (for example a set with lists).</p>
<p>A multiset (sometimes called &lsquo;bag&rsquo;) is just like a set, but can contain duplicates.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Multiset&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    // Returns the number of occurrences of Item x in the multiset
</span></span><span style="display:flex;"><span>    int count(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Adds Item X to the multiset
</span></span><span style="display:flex;"><span>    void add(Item x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes one occurrence of Item x, returns the Item
</span></span><span style="display:flex;"><span>    Item remove(Item x)
</span></span></code></pre></div><p>A multimap (or sometiems called &lsquo;index&rsquo;) is just like a map, but keys can map to several values.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Multimap&lt;Key, Value&gt;:
</span></span><span style="display:flex;"><span>    // Returns the whole collection of values associated with the key, k
</span></span><span style="display:flex;"><span>    Collection&lt;Value&gt; get(Key k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Adds the value, v, to the key, k
</span></span><span style="display:flex;"><span>    void add(Key k, Value v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes the value, v, associated with the key, k
</span></span><span style="display:flex;"><span>    void remove(Key k, Value v)
</span></span></code></pre></div><h4 id="multisets-and-multimaps-are-maps">Multisets and Multimaps are Maps</h4>
<p>Now this might sound weird - but yes, maps as well! We can just like how we implemented a set using an underlying map,
use an underlying map to implement multisets and maps.</p>
<p>An ADT for this would be:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Multimap&lt;Key, Value&gt;:
</span></span><span style="display:flex;"><span>    Map&lt;Key, Set&lt;Value&gt;&gt; underlying_map
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Collection&lt;Value&gt; get(Key k) = underlying_map.get(k)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void add(Key k, Value v)     = underlying_map.put(k, v)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void remove(Key k, Value v)  = underlying_map.remove(k)
</span></span></code></pre></div><p>And for Multisets:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>Mutlisets&lt;Item&gt;:
</span></span><span style="display:flex;"><span>    Map&lt;Key, Item&gt; underlying_map
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    int count(Item x) = underlying_map.get(x)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    void add(Item x) =
</span></span><span style="display:flex;"><span>        if underlying_map.contains():
</span></span><span style="display:flex;"><span>            count = underlying_map.get(x)
</span></span><span style="display:flex;"><span>            count += 1
</span></span><span style="display:flex;"><span>            underlying_map.put(x, count)
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            underlying_map.put(x, 1)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    Item remove(Item x) = underlying_map.remove(x)
</span></span></code></pre></div><h3 id="graphs">Graphs</h3>
<p>Graphs should also be familiar from the discrete maths course - but let&rsquo;s quickly go over it. Graphs consits of <em>nodes</em> (also called vertices, points)</p>
<ul>
<li>and <em>edges</em> (also called arcs, links) that connect nodes.</li>
</ul>
<p>There are many, many types of grahps - in this course we&rsquo;ll mainly use so called directed graphs, so our ADT will look like:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>DirectedGraph&lt;Node&gt;:
</span></span><span style="display:flex;"><span>    // Adds an edge to the graph
</span></span><span style="display:flex;"><span>    void add(DirectedEdge&lt;Node&gt; e)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Removes an edge from the graph
</span></span><span style="display:flex;"><span>    void remove(DirectedEdge&lt;Node&gt; e)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns True if the graph contains the edge, False otherwise
</span></span><span style="display:flex;"><span>    boolean contains(DirectedEdge&lt;Node&gt; e)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns all edges that goes out from Node, n
</span></span><span style="display:flex;"><span>    Collection&lt;DirectedEdge&lt;Node&gt;&gt;
</span></span><span style="display:flex;"><span>        outgoing_edges(Node n)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the total number of nodes in the graph
</span></span><span style="display:flex;"><span>    int n_node()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the total number of edges in the graph
</span></span><span style="display:flex;"><span>    int n_edges()
</span></span></code></pre></div><p>As you can see this ADT relies on a class that specifies how an edge should work:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class DirectedEdge&lt;Node&gt;:
</span></span><span style="display:flex;"><span>    // The constructor to create a new edge between two nodes
</span></span><span style="display:flex;"><span>    __init__(Node from, Node to, float weight)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the &#39;starting&#39; node
</span></span><span style="display:flex;"><span>    Node from()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the &#39;final&#39; node
</span></span><span style="display:flex;"><span>    Node to()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    // Returns the weight of the edge
</span></span><span style="display:flex;"><span>    double weight()
</span></span></code></pre></div><p>As said earlier, graphs come in many different shapes and forms - either they are directed or directed as well as weighted or unweighted.</p>
<h3 id="summary">Summary</h3>
<p><em>Phew</em> this was a lot to take in (and write&hellip;) - but to summarize - there really isn&rsquo;t a universal standard/best of what the best ADT/API looks like.</p>
<p>In my notes theres one way, I wrote it using slighty different syntax/language. But the take away is still the ADTs as in a concept -  all these ADTs build on the same basic idea/operations.</p>
<p>I really liked the picture from the slides in my course so I&rsquo;ll put it here to visualize everything we have discussed today.
<img src="/school/images/Summary.png" alt="Summary"></p>
<p>In the next part we&rsquo;ll begin with conecpt we mentioned today - Hash tables!</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
