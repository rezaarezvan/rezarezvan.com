<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"><meta property="og:site_name" content="rezvan"><title>DSA: Part 4 - Abstract Data Types | rezvan</title>
  <meta property="og:title" content="DSA: Part 4 - Abstract Data Types | rezvan"><meta property="og:description" content="">
  <meta property="og:type" content="blog">
  <meta property="og:link" content="https://rezvan.xyz/school/DSA_4/"><link rel="shortcut icon" type="image/png" href=https://rezvan.xyz//images/icon.png />
  <meta property="og:image" content="https://rezvan.xyz//images/icon.png" /><meta name="viewport" content="width=device-width, initial-scale=1">
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz//css/main.css" />

    <head>
    <link rel="stylesheet" href="../../themes/void/static/css/main.css">
</head>

<div class="js-toggle-wrapper">
    <div class="js-toggle">
        <div class="js-toggle-track">
            <div class="js-toggle-track-check">
                <img src="data:image/png;base64,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" role="presentation" style="pointer-events: none;" width="16" height="16">
            </div>
            <div class="js-toggle-track-x">
                <img src="data:image/png;base64,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" role="presentation" style="pointer-events: none;" width="16" height="16">
            </div>
        </div>
        <div class="js-toggle-thumb"></div>
        <input class="js-toggle-screenreader-only" type="checkbox" aria-label="Switch between Dark and Light mode">
    </div>
</div>

<style>

 

body.dark-mode,
body.dark-mode main {
    background-color: #0a0a0a;
    color: #eee;
}

body.dark-mode a {
    color: #eee;
    text-decoration: none;
}

body.dark-mode p {
    color: #eee;
}

body.dark-mode article a{
    text-decoration: underline;
}

body.dark-mode .post_listed .title {
    color: #eee;
}

body.dark-mode .post_listed .title:hover {
    background-color: #eee;
    color: #0a0a0a;
}

body.dark-mode .post_listed .post_time {
    color: #aaa;
}

body.dark-mode .header_title {
    color: #fff;
}

body.dark-mode .nav a {
    color: #eee;
}

body.dark-mode .nav a:visited {
    color: #eee;
}

body.dark-mode .nav a:hover {
    color: #0a0a0a;
}

 
body.dark-mode .title {
    color: #eee;
}


.js-toggle-wrapper {
    display: table;
     
    margin: 5px auto;
}

.js-toggle {
    touch-action: pan-x;
    display: inline-block;
    position: relative;
    cursor: pointer;
    background-color: transparent;
    border: 0;
    padding: 0;
    -webkit-touch-callout: none;
    user-select: none;
    -webkit-tap-highlight-color: rgba(0, 0, 0, 0);
    -webkit-tap-highlight-color: transparent;
  }

  .js-toggle-screenreader-only {
    border: 0;
    clip: rect(0 0 0 0);
    height: 1px;
    margin: -1px;
    overflow: hidden;
    padding: 0;
    position: absolute;
    width: 1px;
  }

  .js-toggle-track {
    width: 50px;
    height: 24px;
    padding: 0;
    border-radius: 30px;
    background-color: hsl(222, 14%, 7%);
    transition: all 0.2s ease;
  }

  .js-toggle-track-check {
    position: absolute;
    width: 17px;
    height: 17px;
    left: 5px;
    top: 0px;
    bottom: 0px;
    margin-top: auto;
    margin-bottom: auto;
    line-height: 0;
    opacity: 0;
    transition: opacity 0.25s ease;
  }

  .js-toggle--checked .js-toggle-track-check {
    opacity: 1;
    transition: opacity 0.25s ease;
  }

  .js-toggle-track-x {
    position: absolute;
    width: 17px;
    height: 17px;
    right: 5px;
    top: 0px;
    bottom: 0px;
    margin-top: auto;
    margin-bottom: auto;
    line-height: 0;
    opacity: 1;
    transition: opacity 0.25s ease;
  }

  .js-toggle--checked .js-toggle-track-x {
    opacity: 0;
  }

  .js-toggle-thumb {
    position: absolute;
    top: 1px;
    left: 1px;
    width: 22px;
    height: 22px;
    border-radius: 50%;
    background-color: #fafafa;
    box-sizing: border-box;
    transition: all 0.5s cubic-bezier(0.23, 1, 0.32, 1) 0ms;
    transform: translateX(0);
  }

  .js-toggle--checked .js-toggle-thumb {
    transform: translateX(26px);
    border-color: #19ab27;
  }

  .js-toggle--focus .js-toggle-thumb {
    box-shadow: 0px 0px 2px 3px rgb(255, 167, 196);
  }

  .js-toggle:active .js-toggle-thumb {
    box-shadow: 0px 0px 5px 5px rgb(255, 167, 196);
  }
</style>

<script>
    var body = document.body;
	var switcher = document.getElementsByClassName('js-toggle')[0];

	
	switcher.addEventListener("click", function() {
        this.classList.toggle('js-toggle--checked');
        this.classList.add('js-toggle--focus');
		
		if (this.classList.contains('js-toggle--checked')) {
			body.classList.add('dark-mode');
			
			localStorage.setItem('darkMode', 'true');
		} else {
			body.classList.remove('dark-mode');
			setTimeout(function() {
				localStorage.removeItem('darkMode');
			}, 100);
		}
	})

	
	if (localStorage.getItem('darkMode')) {
		
        switcher.classList.add('js-toggle--checked');
        body.classList.add('dark-mode');
	}
</script>


</head>

<body>
  <div class="wrapper">
	<div class="content">
		<div class="header_main">

    <a href="https://rezvan.xyz/"><p class="header_title">rezvan</p><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.css" integrity="sha384-Juol1FqnotbkyZUT5Z7gUPjQ9gzlwCENvUZTpQBAPxtusdwFLRy382PSDx5UUJ4/" crossorigin="anonymous">

<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/katex.min.js" integrity="sha384-97gW6UIJxnlKemYavrqDHSX3SiygeOwIZhwyOKRfSaf0JWKRVj9hLASHgFTzT+0O" crossorigin="anonymous"></script>
<script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.3/dist/contrib/auto-render.min.js" integrity="sha384-+VBxd3r6XgURycqtZ117nYw44OOcIax56Z4dCRWbxyPt0Koah1uHoK0o4+/RRE05" crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>

<script>
    document.addEventListener("DOMContentLoaded", function() {
        renderMathInElement(document.body, {
            delimiters: [
                {left: "$$", right: "$$", display: true},
                {left: "$", right: "$", display: false}
            ]
        });
    });
</script>

    </a>

    <br>

    <nav id="main">
        
        <a href="/">home</a>
        
        <a href="/about/">about</a>
        
        <a href="/contact/">contact</a>
        
        <a href="/cv/">cv</a>
        
        <a href="/school/">school</a>
        
    </nav></div>

  <article><div class="title_wrapper">
			<h1 class="title">DSA: Part 4 - Abstract Data Types</h1><p class="single_time">Nov 28, 2022</p></div>
		<section class="post">
			<h3 id="adt-vs-data-structures">ADT vs Data Structures</h3>
<p>So what&rsquo;s the difference betwen a <strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ype and an actual datastructure?</p>
<p>An ADT is a kind of specification of something - it specifies how we can intertact with that <em>object</em>, like an API.</p>
<p>It consits of methods and constructors but also plain-text specifications (like the complexity for example) and explainations.</p>
<p>A data structure on the other hand is an <strong>actual</strong> <em>implementation</em> of an ADT. It specifies how the <em>object</em> works <em>interally</em>.
But an important note is, that it doesn&rsquo;t need to be in an actual programming language - often it&rsquo;s just specified in pseudo-code.</p>
<h3 id="method-descriptions">Method Descriptions</h3>
<p>As explained above - an ADT has methods/functions - but these need to be specified/have a brief plain-text explaination.
For example, all these ADTs have the same functions, but work differently:</p>
<pre tabindex="0"><code>Stack&lt;Item&gt;:
    void add(Item x)
    Item remove()

Queue&lt;Item&gt;
    void add(Item x)
    Item remove()

PrioQueue&lt;Item&gt;:
    void add(Item x)
    Item remove()
</code></pre><h3 id="different-kind-of-adts">Different kind of ADTs</h3>
<p>Now we will cover all ADTs that we will encounter in this course!</p>
<h3 id="ordered-collections-stacks-queues-etc">Ordered collections: Stacks, Queues, etc</h3>
<h4 id="stacks">Stacks</h4>
<p>Since we have covered in depth as well as implemented stacks, let&rsquo;s just briefly go over them.</p>
<p>Stacks - LIFO (&rsquo;<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>pop()</code> <code>push()</code></p>
<p>So the ADT would be:</p>
<pre tabindex="0"><code>Stack&lt;Item&gt;:
    // Adds Item X to the top of the stack
    void push(Item x) 

    // Returns and removes the topmost element of the stack
    Item pop()

    // Returns the topmost element, without removing it
    Item peek()

    // Returns True if the stack is empty, False otherwise
    boolean is_empty()

    Returns the current size (length) of the stack
    int size()
</code></pre><h4 id="queues">Queues</h4>
<p>Same goes for a queue - since we&rsquo;ve already covered this in depth, we&rsquo;ll just briefly recover it.</p>
<p>Queues - FIFO (&rsquo;<strong>F</strong>irst <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut')</p>
<p>Builds on the functions <code>enqueue()</code> <code>dequeue()</code></p>
<p>So the ADT can be described as:</p>
<pre tabindex="0"><code>Queue&lt;Item&gt;:
    // Adds Item X to the end of the queue
    void enqueue(Item x)

    // Removes and returns the first item in the queue
    Item dequeue()
    
    // Returns True if the queue is empty, False otherwise
    boolean empty()

    // Returns True if the queue is full, False otherwise
    boolean full()

    // Returns the current size (length) of the queue
    int qsize()
</code></pre><h4 id="stacks--queues--deques">Stacks + Queues = Deques</h4>
<p>If we combine these two ADTs that we&rsquo;ve become so familiar with - we get a so called double-ended queue!</p>
<p>Here&rsquo;s the ADT for it:</p>
<pre tabindex="0"><code>Deque&lt;Item&gt;:
    // Adds Item X to the front of the deque
    void add_first(Item x)
    
    // Adds Item X to the end of the deque
    void add_last(Item x)

    // Removes and returns the frontmost item in the deque
    Item remove_first()

    // Removes and returns the last item in the deque
    Item remove_last()
</code></pre><p>So why would we want to use a stack or queue - when their combination exists?</p>
<p>The answer is quite simple - it differs from problem to problem! Sometimes a stack might just be <em>exactly</em> what you want, and sometimes you might feel hindered or blocked by a ADT.</p>
<p>So you need to do research on what kind of ADT you should use before actually implementing one. Also cost/how hard the implementation will be is also a important factor.</p>
<h4 id="lists-generalsiing-stacks-and-queues">Lists: Generalsiing Stacks and Queues</h4>
<p>Lists is the ADT when we finally don&rsquo;t restrict ourselves to only add/remove the front/end element - and finally can add/remove wherever we want!</p>
<p>The ADT looks something like:</p>
<pre tabindex="0"><code>List&lt;Item&gt;:
    // Inserts Item X at position i in the list
    void add(Item x, int i)

    // Removes and returns the item at position i
    Item remove(int i)

    // Returns the element on position i
    Item get(int i)

    // Sets/replaces element i with x
    void set(int i, Item x)

    // Returns True if the list is currently empty, otherwise False
    boolean is_empty()

    // Returns the current size (# of elements) in the list
    int size()
</code></pre><h4 id="priority-queues">Priority Queues</h4>
<p>The only difference between priorty queues, stacks and regular queues is which element to remove.
A stack removes the &lsquo;youngest&rsquo; element, a queue removes the &lsquo;oldest&rsquo; element, and a priorty queue removes the &lsquo;minimum&rsquo; element. Minimum here means by some arbitrary ordering.</p>
<p>These are quite complicated to implement so we&rsquo;ll be implementing them a bit later.</p>
<h4 id="iterating-comparing-and-sorting">Iterating, Comparing and Sorting</h4>
<p>Iterating, comparing, and sorting are all very important when it comes to orded collections - we need to be able to iterate through the whole collection,
comparing items to each other, and of course the most important - sorting the collection!</p>
<p>These all feel like very &rsquo;low-level&rsquo; and natural things - but quite often we ourselves will need to implement these.
For example, iterating through a queue. Note that some data structures actually doesn&rsquo;t allow to iterate through out the collection!</p>
<p>Iteration also works differently, for example in Java it&rsquo;s called <code>iterator()</code> and in Python <code>__iter__()</code>.
One thing to note is that iterables and iterators are different. An <em>iterator</em> has a method that returns the next element, and a way of telling when the iteration is exhausted.</p>
<p>So, an <em>iterator</em> can only be iterated over once, while an <em>iterable</em> can be iterated many times, because it creates new iterators. Quite a mouthful.</p>
<p>So in Python for example a simple:</p>
<pre tabindex="0"><code>for x in elements:
    # do something with x
</code></pre><p>is translated to:</p>
<pre tabindex="0"><code>it = elements.__iter__()
while True:
    try:
        x = it.__next__()
    expect StopIteration():
        break

    # do something  with x
</code></pre><p>A same kind of logic is applied when we want to compare items. If something is comparable they implement a <em>comparable</em> interface for example.
But often we want our own comparisons to something rather than the &rsquo;natural ordering&rsquo; the comparable interface provides. In these cases we need to implemnt different <em>comparators</em>.</p>
<p>Now sorting becomes quite trivial - the built in sorting methods either use the &rsquo;natural ordering&rsquo; comparator, or can take a comparator as an argument to sort it how we want.</p>
<h4 id="unordered-collections-maps-sets-and-graphs">Unordered collections: Maps, sets, and graphs</h4>
<p>These are just like the ordered collections, but without a specific order :)</p>
<h4 id="sets">Sets</h4>
<p>You should be quite familiar with sets from a discrete math course - but let&rsquo;s go over it anyways</p>
<p>A set is a collection of objects where:</p>
<ul>
<li>It cannot contain duplicates of the same object.</li>
<li>Basic operations for testing for &lsquo;membership&rsquo;, and adding/removing an element.</li>
<li>Methods for size of the set and testing for emptiness.</li>
<li>Usually a kind of iterator for looping over all elements/members in set.</li>
</ul>
<p>So the ADT coud look like:</p>
<pre tabindex="0"><code>Set&lt;Item&gt;:
    // Returns True if x is in the set, False otherwise
    boolean contains(Item x)

    // Adds x to the set, if it&#39;s not already in the set
    void add(Item x)

    // Removes x from the set, if it&#39;s present
    void remove(Item x)

    // Returns True if the set is currently empty, False otherwise
    boolean is_empty()

    // Returns the current size (# of elements) in the set
    int size()

    // Iterates over all elements in the set
    Iterator&lt;Item&gt; iterator()
</code></pre><h4 id="maps">Maps</h4>
<p>A map is a &lsquo;mapping&rsquo; from a &lsquo;key&rsquo; to a &lsquo;value&rsquo; with these properties:</p>
<ul>
<li>It cannot contain duplicates of the same &lsquo;key&rsquo;</li>
<li>The basic operations are <code>getting</code> and <code>setting</code> the &lsquo;value&rsquo; for a given &lsquo;key&rsquo;. Also removing a &lsquo;key&rsquo; along with its associated value&rsquo;.</li>
<li>Helper methods such as, <code>number_of_keys()</code>, <code>is_empty()</code></li>
<li>(Usually) an iterator to loop over all keys</li>
</ul>
<p>So an ADT would look like:</p>
<pre tabindex="0"><code>Map&lt;Key, Value&gt;:
    // Returns True if there&#39;s an association for the key, k.
    boolean contains(Key k)

    // Returns the value associated with key, k.
    Value get(Key k)

    // Associates the key, k, with the value, v.
    void put(Key k, Value v)

    // Removes the value associated with the key, k.
    void remove(Key k)

    // Returns True if the Map is currently empty, False otherwise
    boolean is_empty()

    // Returns the current size (# of key-value pairs) in the map
    int size()

    // Iterates over all keys in the map
    Iterator&lt;Key&gt; keys()
</code></pre><p>&lsquo;Maps&rsquo; have a lot of associated names:</p>
<ul>
<li>Dictionaries</li>
<li>Symbol tables</li>
<li>Associative arrays</li>
<li>Lookup tables</li>
<li>finite-domain functions</li>
<li>$\dots$</li>
</ul>
<p>Maps can be seen as a further generalisation of list even. The integer positon is now replaced by a generic &lsquo;key&rsquo; type.</p>
<p>For actual implementation of maps, these are the following:</p>
<ul>
<li>Lists</li>
<li>Search trees
<ul>
<li>Binary search trees
<ul>
<li>Unbalanced BSTs</li>
<li>Balanced BSTs (red-black tree, AVL trees, $\dots$)</li>
</ul>
</li>
</ul>
</li>
<li>Hash tables
<ul>
<li>Separate chaining</li>
<li>Open addresing (Linear probing, quadratic probing, $\dots$)</li>
</ul>
</li>
<li>Randomised data structures
<ul>
<li>Skip lists, treaps, $\dots$</li>
</ul>
</li>
</ul>
<h4 id="a-set-is-degenerated-map">A Set is Degenerated Map</h4>
<p>If we have an implementation of a map, it&rsquo;s actually quite easy to turn it into a set. We just need to create an underlying map,
whose keys are the set items!</p>
<p>So a ADT solution would be:</p>
<pre tabindex="0"><code>Set&lt;Item&gt;:
    Map&lt;Item, Void&gt; underlying_map

    boolean contains(Item x)  = underlying_map.contains(x)
    void add(Item x)          = underlying_map.add(x, null)
    void remove(Item x)       = underlying_map.remove(x)

    boolean is_empty()        = underlying_map.is_empty()
    int size()                = underlying_map.size()

    Iterator&lt;Item&gt; iterator() = underlying_map.keys()
</code></pre><h4 id="multisets-and-multimaps">Multisets and multimaps</h4>
<p>Sometimes we want to put several objects into the same &lsquo;slot&rsquo; (for example a set with lists).</p>
<p>A multiset (sometimes called &lsquo;bag&rsquo;) is just like a set, but can contain duplicates.</p>
<pre tabindex="0"><code>Multiset&lt;Item&gt;:
    // Returns the number of occurrences of Item x in the multiset
    int count(Item x)

    // Adds Item X to the multiset
    void add(Item x)

    // Removes one occurrence of Item x, returns the Item
    Item remove(Item x)
</code></pre><p>A multimap (or sometiems called &lsquo;index&rsquo;) is just like a map, but keys can map to several values.</p>
<pre tabindex="0"><code>Multimap&lt;Key, Value&gt;:
    // Returns the whole collection of values associated with the key, k   
    Collection&lt;Value&gt; get(Key k)

    // Adds the value, v, to the key, k
    void add(Key k, Value v)

    // Removes the value, v, associated with the key, k
    void remove(Key k, Value v)
</code></pre><h4 id="multisets-and-multimaps-are-maps">Multisets and Multimaps are Maps</h4>
<p>Now this might sound weird - but yes, maps as well! We can just like how we implemented a set using an underlying map,
use an underlying map to implement multisets and maps.</p>
<p>An ADT for this would be:</p>
<pre tabindex="0"><code>Multimap&lt;Key, Value&gt;:
    Map&lt;Key, Set&lt;Value&gt;&gt; underlying_map
    
    Collection&lt;Value&gt; get(Key k) = underlying_map.get(k)

    void add(Key k, Value v)     = underlying_map.put(k, v)

    void remove(Key k, Value v)  = underlying_map.remove(k)
</code></pre><p>And for Multisets:</p>
<pre tabindex="0"><code>Mutlisets&lt;Item&gt;:
    Map&lt;Key, Item&gt; underlying_map
    
    int count(Item x) = underlying_map.get(x)

    void add(Item x) = 
        if underlying_map.contains():
            count = underlying_map.get(x)
            count += 1
            underlying_map.put(x, count)
        else:
            underlying_map.put(x, 1)

    Item remove(Item x) = underlying_map.remove(x)
</code></pre><h3 id="graphs">Graphs</h3>
<p>Graphs should also be familiar from the discrete maths course - but let&rsquo;s quickly go over it. Graphs consits of <em>nodes</em> (also called vertices, points)</p>
<ul>
<li>and <em>edges</em> (also called arcs, links) that connect nodes.</li>
</ul>
<p>There are many, many types of grahps - in this course we&rsquo;ll mainly use so called directed graphs, so our ADT will look like:</p>
<pre tabindex="0"><code>DirectedGraph&lt;Node&gt;:
    // Adds an edge to the graph
    void add(DirectedEdge&lt;Node&gt; e)
    
    // Removes an edge from the graph
    void remove(DirectedEdge&lt;Node&gt; e)

    // Returns True if the graph contains the edge, False otherwise
    boolean contains(DirectedEdge&lt;Node&gt; e)
    
    // Returns all edges that goes out from Node, n
    Collection&lt;DirectedEdge&lt;Node&gt;&gt;
        outgoing_edges(Node n)
    
    // Returns the total number of nodes in the graph
    int n_node()

    // Returns the total number of edges in the graph
    int n_edges()
</code></pre><p>As you can see this ADT relies on a class that specifies how an edge should work:</p>
<pre tabindex="0"><code>class DirectedEdge&lt;Node&gt;:
    // The constructor to create a new edge between two nodes
    __init__(Node from, Node to, float weight)
    
    // Returns the &#39;starting&#39; node
    Node from()

    // Returns the &#39;final&#39; node
    Node to()

    // Returns the weight of the edge
    double weight()
</code></pre><p>As said earlier, graphs come in many different shapes and forms - either they are directed or directed as well as weighted or unweighted.</p>
<h3 id="summary">Summary</h3>
<p><em>Phew</em> this was a lot to take in (and write&hellip;) - but to summarize - there really isn&rsquo;t a universal standard/best of what the best ADT/API looks like.</p>
<p>In my notes theres one way, I wrote it using slighty different syntax/language. But the take away is still the ADTs as in a concept -  all these ADTs build on the same basic idea/operations.</p>
<p>I really liked the picture from the slides in my course so I&rsquo;ll put it here to visualize everything we have discussed today.
<img src="/school/images/Summary.png" alt="Summary"></p>
<p>In the next part we&rsquo;ll begin with conecpt we mentioned today - Hash tables!</p>

		</section>
  </article>
	</div>

	<footer><p class="footer_msg">memento mori</p></footer>

  </div>
</body>
</html>
