<!DOCTYPE html>
<html><head lang="en">
	<meta charset="utf-8" />
	<meta http-equiv="X-UA-Compatible" content="IE=edge"><title>DSA: Part 3 - Dynamic Arrays - rezvan</title><link rel="icon" type="image/png" href=images/icon.png /><meta name="viewport" content="width=device-width, initial-scale=1">
	<meta name="description" content="Dynamic arrays Finally we have arrived at the DS of DSA. In (almost) all programming languages the most common built in data structure are arrays. We have seen them, worked with them - nothing new. We&rsquo;ve probably even worked with dynamic arrays, they are an essential data structure - sometimes we don&rsquo;t know how much data we&rsquo;ll need.
But how are dynamic arrays actually implemented into a language? The ideas is actually quite simple - we use a fixed length array and make a larger, fixed length, array when we have ran out of space." />
	<meta property="og:image" content="images/icon.png"/>
	<meta property="og:title" content="DSA: Part 3 - Dynamic Arrays" />
<meta property="og:description" content="Dynamic arrays Finally we have arrived at the DS of DSA. In (almost) all programming languages the most common built in data structure are arrays. We have seen them, worked with them - nothing new. We&rsquo;ve probably even worked with dynamic arrays, they are an essential data structure - sometimes we don&rsquo;t know how much data we&rsquo;ll need.
But how are dynamic arrays actually implemented into a language? The ideas is actually quite simple - we use a fixed length array and make a larger, fixed length, array when we have ran out of space." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://rezvan.xyz/school/DSA_3/" /><meta property="article:section" content="school" />
<meta property="article:published_time" content="2022-11-27T17:26:09+01:00" />
<meta property="article:modified_time" content="2022-11-27T17:26:09+01:00" />
<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="DSA: Part 3 - Dynamic Arrays"/>
<meta name="twitter:description" content="Dynamic arrays Finally we have arrived at the DS of DSA. In (almost) all programming languages the most common built in data structure are arrays. We have seen them, worked with them - nothing new. We&rsquo;ve probably even worked with dynamic arrays, they are an essential data structure - sometimes we don&rsquo;t know how much data we&rsquo;ll need.
But how are dynamic arrays actually implemented into a language? The ideas is actually quite simple - we use a fixed length array and make a larger, fixed length, array when we have ran out of space."/>
<script src="https://cdn.jsdelivr.net/npm/feather-icons/dist/feather.min.js"></script>
	<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:ital,wght@1,500&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css2?family=Fira+Sans&display=swap" rel="stylesheet">
        <link href="https://fonts.googleapis.com/css?family=Roboto+Mono" rel="stylesheet">

	
	<link rel="stylesheet" type="text/css" media="screen" href="https://rezvan.xyz/css/main.ded288734bf67c9f89d72102879afaadf50fed4138fb485737334085f5465104.css" />
		<link id="darkModeStyle" rel="stylesheet" type="text/css" href="https://rezvan.xyz/css/dark.b47837a877382f31178bb7a2c2135fbe9c39b1d4a1cc529faee0363b6dbdc408.css"  disabled />
	

	
	
		<script type="text/javascript"
		src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
		</script>
	
		
		<script type="text/x-mathjax-config">
		MathJax.Hub.Config({
			tex2jax: {
				inlineMath: [['$','$'], ['\\(','\\)']],
				displayMath: [['$$','$$'], ['\[','\]']],
				processEscapes: true,
				processEnvironments: true,
				skipTags: ['script', 'noscript', 'style', 'textarea', 'pre'],
				TeX: { equationNumbers: { autoNumber: "AMS" },
						 extensions: ["AMSmath.js", "AMSsymbols.js"] }
			}
		});
		</script>
	

	
	
		<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css">
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script>
		<script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script>
		
		
		<script>
			document.addEventListener("DOMContentLoaded", function() {
					renderMathInElement(document.body, {
							delimiters: [
									{left: "$$", right: "$$", display: true},
									{left: "$", right: "$", display: false}
							]
					});
			});
			</script>
	
	
	
</head>
<body>
        <div class="content"><header>
	<div class="main">
		<a href="https://rezvan.xyz/">rezvan</a>
	</div>
	<nav>
		
		<a href="/">home</a>
		
		<a href="/about">about</a>
		
		<a href="/contact">contact</a>
		
		<a href="/cv">cv</a>
		
		<a href="/school">school</a>
		
		<a href="/tags">tags</a>
		
		| <span id="dark-mode-toggle" onclick="toggleTheme()"></span>
		<script src="https://rezvan.xyz/js/themetoggle.js"></script>
		
	</nav>
</header>

<main>
	<article>
		<div class="title">
			<h1 class="title">DSA: Part 3 - Dynamic Arrays</h1>
			<div class="meta">Posted on Nov 27, 2022</div>
		</div>
		

		<section class="body">
			<h3 id="dynamic-arrays">Dynamic arrays</h3>
<p>Finally we have arrived at the DS of DSA. In (almost) all programming languages the most common built in data structure are arrays.
We have seen them, worked with them - nothing new. We&rsquo;ve probably even worked with dynamic arrays, they are an essential data structure - sometimes we don&rsquo;t know how much data we&rsquo;ll need.</p>
<p>But how are dynamic arrays <em>actually</em> implemented into a language? The ideas is actually quite simple - we use a fixed length array and make a larger, fixed length, array when we have ran out of space.</p>
<h3 id="different-approaches">Different approaches</h3>
<h4 id="naive-approach">Naive Approach</h4>
<p>A very naive and brute force implementation would be, if we append a value to a array which doesn&rsquo;t have space, we copy the old array and make the index one larger so we can fit the new value.
The problem with this approach is that it&rsquo;s <em>really</em> slow. If I want to append 10 items to a list of size 1, we need to copy each time we append.</p>
<p>The complexity of this becomes $\mathcal{O}(n^2)$, which again, is really bad.</p>
<h4 id="a-better-but-naive--approach">A Better, but Naive  Approach</h4>
<p>A better approach would be that each we need to resize the array - we make some extra space for future appends. Let&rsquo;s say each time we need to resize the array we add 10 more indexes, for future use.</p>
<p>This is actually 10 times faster than our first approach! But it&rsquo;s still $\mathcal{O}(n^2)$ so&hellip;</p>
<h4 id="multiplicative-approach">Multiplicative Approach</h4>
<p>So, instead of resizing by a constant - why not just double the array size each time? With this approach:</p>
<p>To reach an array of size $2^n$ we would need to do $1 + 2 + 4 + \dots + 2^{n-1}$ total element copies
This sums up to $2^n - 1$ which makes this approach $\mathcal{O}(n)$!</p>
<h3 id="worst-case-complexities">Worst-case Complexities</h3>
<p>One might go through an example about the worst-case complexity of these two approaches. If we do that we find that both have a worst-case complexity
of $\mathcal{O}(n)$. If we ever need to resize, we would need to copy $n$ elements from the old array to the new one.</p>
<p>If we now suppose we call the <code>add</code> function $n$ times instead. What&rsquo;s the worst-case complexity now? For the constant approach it&rsquo;s quite obvious that it becomes
$\mathcal{O}(n^2)$, for each call, in the worst-case, we would need to copy n items, then n adds in total.</p>
<p>For our multiplicative approach - this instead becomes $\mathcal{O}(n)$. But this is still &rsquo;too slow&rsquo; - we would like a $\mathcal{O}(1)$ operation.</p>
<p>But don&rsquo;t worry - here we have something called <strong>amortized complexity</strong> which plays a huge role.</p>
<h3 id="amortized-complexity">Amortized Complexity</h3>
<p>If <code>add</code> had a $\mathcal{O}(1)$ worst-case complexity, $n$ calls would take $\mathcal{O}(n)$ time right?
But as we stated, our approach took $\mathcal{O}(n)$ for n calls - so we can say that <code>add</code> has a $\mathcal{O}(1)$ <em>amortized</em> complexity!</p>
<p>Basically what amortized complexity is, we take an <em>average</em> cost of the operation over n calls.</p>
<p>Now that we&rsquo;ve defined how the most important feature of dynamic arrays should work - let&rsquo;s implement one!</p>
<h3 id="implementation">Implementation</h3>
<p>A python implementation of a dynamic array:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class dynamic_array:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.array = [None]
</span></span><span style="display:flex;"><span>        self.size  = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def get(self, i):
</span></span><span style="display:flex;"><span>        if 0 &lt;= i &lt; self.size:
</span></span><span style="display:flex;"><span>            return &#34;Error, index out of bounds&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return self.array[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def set(self, i, val):
</span></span><span style="display:flex;"><span>        if 0 &lt;= i &lt; self.size:
</span></span><span style="display:flex;"><span>            return &#34;Error, index out of bounds&#34;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.array[i] = val
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def append(self, val):
</span></span><span style="display:flex;"><span>        if self.size == len(self.array):
</span></span><span style="display:flex;"><span>            self.resize()
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.array[self.size] = val
</span></span><span style="display:flex;"><span>        self.size += 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def resize(self):
</span></span><span style="display:flex;"><span>        new_array = [None] * 2
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        for i in range(len(self.array)):
</span></span><span style="display:flex;"><span>            new_array[i] = self.array[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.array = new_array
</span></span></code></pre></div><p>Now this isn&rsquo;t a perfect implementation - but it works okay.</p>
<p>Now that we understand <em>really</em> how dynamic arrays work - we can actually start implementing some more <em>interesting</em> data structures</p>
<h3 id="stacks-and-queues">Stacks and Queues</h3>
<p>Stacks and Queues are quite popular and powerful data structures. But just to refresh let&rsquo;s go over how both data structures work.</p>
<h4 id="stacks">Stacks</h4>
<p>A Stack is a so called <strong>LIFO</strong> data structure. LIFO stands for &lsquo;<strong>L</strong>ast <strong>I</strong>n <strong>F</strong>irst <strong>O</strong>ut&rsquo;. One can visualize it as a literal stack of items (therefore the name). If have a <strong>stack</strong>
of things, we might take items from the top and keep throwing away items til we reach the bottom. This is exactly how the stack data structure works!</p>
<h5 id="important-functions-for-stacks">Important Functions for Stacks</h5>
<p>These operations that I was talking about have names - if we remove the top item, we call it <code>pop()</code> - and if we place an item on the top of the stack
it&rsquo;s called <code>push()</code>. We have some helper functions that are usually needed for an implementation as well - the <code>peek()</code> function gives us the item at the top of the stack.
The <code>size()</code> returns how large the stack currently is.</p>
<h4 id="queues">Queues</h4>
<p>A queue is a so called <strong>FIFO</strong> data structure, &lsquo;<strong>F</strong>irst <strong>In</strong> <strong>F</strong>irst <strong>O</strong>ut&rsquo;. Just as the stack data structure, we can visualize this as a literal queue.
If someone joins the queue you are put in last - and the first person to join queue will be the first to leave the queue as well.</p>
<h3 id="how-to-implement-stacks-and-queues">How to implement Stacks and Queues</h3>
<p>Now that we understood the basics of these data structures - let&rsquo;s see how one can implement them. But before we dive right in let&rsquo;s see the different approaches to this.
Both stacks and queues can be implemented with Dynamic arrays as we covered - but equally as good with linked lists. We&rsquo;ll start with how we can implement it using a linked list - but let&rsquo;s refresh our memory of what a linked list is.</p>
<h4 id="linked-lists">Linked Lists</h4>
<p>A (singly) linked list consist of &lsquo;Node&rsquo; objects in a sequence - these node objects can contain one or multiple values - each node is &lsquo;pointing&rsquo; to the next node in the sequence.
A singly linked list points to the first node and the last node in the list points to nothing (Nothing can for example be <code>Null</code>)
Since it would be inefficient to calculate the size each time we call <code>size()</code>, since we would need to traverse the whole list, we instead keep a dynamic size variable that we can access.</p>
<p>Here&rsquo;s how the boilerplate classes for a Linked List might look:</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Node:
</span></span><span style="display:flex;"><span>    def __init__(self, val, next = None):
</span></span><span style="display:flex;"><span>        self.val = val
</span></span><span style="display:flex;"><span>        self.next = next
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class LinkedList:
</span></span><span style="display:flex;"><span>    def __init__(self, val = None):
</span></span><span style="display:flex;"><span>        self.head = None
</span></span><span style="display:flex;"><span>        self.size = 0
</span></span></code></pre></div><p>With our new knowledge about linked lists - we can return to stacks!</p>
<h4 id="stacks-as-linked-lists">Stacks as linked lists</h4>
<p>An implementation with a linked list for a stack is perfect - we only care about the top element in stack, therefore, when we <code>push()</code>,
we first make the new nodes next point to the current head. Then we redirect head to our new node and increase size. When we want to <code>pop()</code> -
we first store the value of our current head node temporarily, to return the value popped. Then we redirect head to the <code>next</code> of the node we want to pop.</p>
<p>In many languages we do not need to manually remove the node from the list - since it will be handled by garbage collection. But in a language like C, we would need to <code>free()</code> that node from memory.</p>
<p>So let&rsquo;s implement a stack using a linked list.</p>
<h4 id="implementation-of-a-stack-using-a-linked-list">Implementation of a stack using a linked list</h4>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Node:
</span></span><span style="display:flex;"><span>    def __init__(self, val):
</span></span><span style="display:flex;"><span>        self.val = val
</span></span><span style="display:flex;"><span>        self.next = None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Stack:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.head = None
</span></span><span style="display:flex;"><span>        self.size = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def is_empty(self):
</span></span><span style="display:flex;"><span>        if self.head == None:
</span></span><span style="display:flex;"><span>            return True
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return False
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def push(self, val):
</span></span><span style="display:flex;"><span>        if self.head == None:
</span></span><span style="display:flex;"><span>            self.head = Node(val)
</span></span><span style="display:flex;"><span>            return
</span></span><span style="display:flex;"><span> f
</span></span><span style="display:flex;"><span>        new = Node(val)
</span></span><span style="display:flex;"><span>        new.next = self.head
</span></span><span style="display:flex;"><span>        self.head = new
</span></span><span style="display:flex;"><span>        self.size += 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def pop(self):
</span></span><span style="display:flex;"><span>        if self.head == None:
</span></span><span style="display:flex;"><span>            return None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        pop = self.head.val
</span></span><span style="display:flex;"><span>        self.head = self.head.next
</span></span><span style="display:flex;"><span>        self.size -= 1
</span></span><span style="display:flex;"><span>        return pop
</span></span></code></pre></div><p>Now let&rsquo;s implement a stack using a dynamic array.</p>
<h4 id="implementation-of-a-stack-using-a-dynamic-array">Implementation of a stack using a dynamic array</h4>
<p>Before we start the implementation, let&rsquo;s consider <strong>how</strong> we should implement it before.
One thing that might not be obvious might be that, using the first element as the top - will work - but be super slow.</p>
<p>If we pop the first element - we would need to push forward the rest of the stack by 1 step. Which would take $\mathcal{O}(n)$. We want $\mathcal{O}(1)$!</p>
<p>So instead let&rsquo;s use the last element as the top!</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Stack:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.stack = [None]
</span></span><span style="display:flex;"><span>        self.size = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def is_empty(self):
</span></span><span style="display:flex;"><span>        return self.size == 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def push(self, val):
</span></span><span style="display:flex;"><span>        if self.size == len(self.stack):
</span></span><span style="display:flex;"><span>            self.resize(2 * self.size)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.stack[self.size] = val
</span></span><span style="display:flex;"><span>        self.size += 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def pop(self):
</span></span><span style="display:flex;"><span>        self.size -= 1
</span></span><span style="display:flex;"><span>        pop = self.stack[self.size]
</span></span><span style="display:flex;"><span>        self.stack[self.size] = None
</span></span><span style="display:flex;"><span>        if self.size == (len(self.stack) // 4):
</span></span><span style="display:flex;"><span>            self.resize(len(self.stack) // 2)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return pop
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def resize(self, factor):
</span></span><span style="display:flex;"><span>        new_array = [None] * factor
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        for i in range(self.size):
</span></span><span style="display:flex;"><span>            new_array[i] = self.stack[i]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.stack = new_array
</span></span></code></pre></div><h4 id="implementation-of-a-queue-using-linked-lists">Implementation of a queue using linked lists</h4>
<p>Now it&rsquo;s now to implement queues! Using a linked list seems as a very natural approach since we have a sequence of pointers forward.
However, in a queue we always need to the first and the last element. Therefore, we need another pointer to the end of the list as well.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Node:
</span></span><span style="display:flex;"><span>    def __init__(self, val):
</span></span><span style="display:flex;"><span>        self.val = val
</span></span><span style="display:flex;"><span>        self.next = None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>class Queue:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.last = None
</span></span><span style="display:flex;"><span>        self.first = None
</span></span><span style="display:flex;"><span>        self.size = 0
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def is_empty(self):
</span></span><span style="display:flex;"><span>        if self.first == None:
</span></span><span style="display:flex;"><span>            return True
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return False
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def enqueue(self, val):
</span></span><span style="display:flex;"><span>        new_node = Node(val)
</span></span><span style="display:flex;"><span>        if self.is_empty():
</span></span><span style="display:flex;"><span>            self.first = new_node
</span></span><span style="display:flex;"><span>            self.last = new_node
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            self.last.next = new_node
</span></span><span style="display:flex;"><span>            self.last = new_node
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.size += 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def dequeue(self):
</span></span><span style="display:flex;"><span>        if self.is_empty():
</span></span><span style="display:flex;"><span>            return None
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        exit = self.first
</span></span><span style="display:flex;"><span>        self.first = self.first.next
</span></span><span style="display:flex;"><span>        self.size -= 1
</span></span><span style="display:flex;"><span>        return exit.val
</span></span></code></pre></div><p>Quite simple and elegant!</p>
<h4 id="implementation-of-a-queue-using-a-dynamic-array">Implementation of a queue using a (dynamic) array</h4>
<p>One thing we have go through first is that - our implementation will be a so called circular array. Our pointers to the head and tail can (and will cross).</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-fallback" data-lang="fallback"><span style="display:flex;"><span>class Queue:
</span></span><span style="display:flex;"><span>    def __init__(self):
</span></span><span style="display:flex;"><span>        self.queue = [None]
</span></span><span style="display:flex;"><span>        self.head = 0
</span></span><span style="display:flex;"><span>        self.tail = 1
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def is_empty(self):
</span></span><span style="display:flex;"><span>        return self.head == (self.tail + 1) % len(self.queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def enqueue(self, val):
</span></span><span style="display:flex;"><span>        if (self.tail + 1) % len(self.queue) == self.head:
</span></span><span style="display:flex;"><span>            self.resize(2 * len(self.queue))
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        self.queue[self.tail] = val
</span></span><span style="display:flex;"><span>        self.tail = (self.tail + 1) % len(self.queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def dequeue(self):
</span></span><span style="display:flex;"><span>        if self.is_empty():
</span></span><span style="display:flex;"><span>            raise Exception(&#34;Queue is empty&#34;)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        result = self.queue[self.head]
</span></span><span style="display:flex;"><span>        self.head = (self.head + 1) % len(self.queue)
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        return result
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    def resize(self, new_size):
</span></span><span style="display:flex;"><span>        old_queue = self.queue
</span></span><span style="display:flex;"><span>        self.queue = [None] * new_size
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        if self.head &lt; self.tail:
</span></span><span style="display:flex;"><span>            for i in range(self.tail - self.head):
</span></span><span style="display:flex;"><span>                self.queue[i] = old_queue[(self.head + i) % len(old_queue)]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            self.head = 0
</span></span><span style="display:flex;"><span>            self.tail = self.tail - self.head
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>        else:
</span></span><span style="display:flex;"><span>            for i in range(len(old_queue) - 1):
</span></span><span style="display:flex;"><span>                _index = (self.head + i) % len(old_queue)
</span></span><span style="display:flex;"><span>                self.queue[i] = old_queue[_index]
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>            self.head = 0
</span></span><span style="display:flex;"><span>            self.tail = self.tail - self.head - 1
</span></span></code></pre></div><p>That&rsquo;s it for this part - in the next part we&rsquo;ll cover something called &lsquo;<strong>A</strong>bstract <strong>D</strong>ata <strong>T</strong>ypes&rsquo; or for short ADTs.
We&rsquo;ll define what a ADT is and what&rsquo;s the difference between them and ordinary data structures.</p>

		</section>

		<div class="post-tags">
			
			
			<nav class="nav tags">
				<ul class="tags">
					
					<li><a href="/tags/Data-Structures-Algorithms">Data Structures &amp; Algorithms</a></li>
					
				</ul>
			</nav>
			
			
		</div>
		</article>
</main>
<footer>
    <div style="display:flex"><a class="soc" href="https://github.com/rezaarezvan" rel="me" title="GitHub"><i data-feather="github"></i></a>
        <a class="border"></a><a class="soc" href="https://twitter.com/rzvan__/" rel="me" title="Twitter"><i data-feather="twitter"></i></a>
        <a class="border"></a></div><p class="footer_msg">memento mori</p></footer>


<script>
    feather.replace()
</script></div>
    </body>
</html>
