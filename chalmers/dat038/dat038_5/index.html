<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/icon" href="/favicon.ico"><meta name="generator" content="Astro v4.11.5"><!-- Canonical URL --><link rel="canonical" href="https://rezvan.xyz/chalmers/dat038/dat038_5/"><!-- Primary Meta Tags --><title>Part 5 - Hash Tables | data structures algorithms | rezvan.xyz</title><meta name="title" content="Part 5 - Hash Tables | data structures algorithms | rezvan.xyz"><meta name="description"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://rezvan.xyz/chalmers/dat038/dat038_5/"><meta property="og:title" content="Part 5 - Hash Tables | data structures algorithms | rezvan.xyz"><meta property="og:description"><meta property="og:image" content="https://rezvan.xyz/favicon.ico"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://rezvan.xyz/chalmers/dat038/dat038_5/"><meta property="twitter:title" content="Part 5 - Hash Tables | data structures algorithms | rezvan.xyz"><meta property="twitter:description"><meta property="twitter:image" content="https://rezvan.xyz/favicon.ico"><!-- PageFind --><link href="/pagefind/pagefind-ui.css" rel="stylesheet"><script src="/pagefind/pagefind-ui.js"></script><!-- KaTeX support --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script><!-- inline KaTeX --><script>
    function renderKaTeX() {
        if (typeof renderMathInElement !== "undefined") {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                ],
            });
        }
    }

    document.addEventListener("DOMContentLoaded", renderKaTeX);
    document.addEventListener("astro:after-swap", renderKaTeX);
</script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script>
    function init() {
        preloadTheme();
        onScroll();
        animate();
        updateThemeButtons();
        addCopyCodeButtons();
        setGiscusTheme();

        const backToTop = document.getElementById("back-to-top");
        backToTop?.addEventListener("click", (event) => scrollToTop(event));

        const backToPrev = document.getElementById("back-to-prev");
        backToPrev?.addEventListener("click", () => window.history.back());

        const lightThemeButton = document.getElementById("light-theme-button");
        lightThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "light");
            toggleTheme(false);
            updateThemeButtons();
        });

        const darkThemeButton = document.getElementById("dark-theme-button");
        darkThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "dark");
            toggleTheme(true);
            updateThemeButtons();
        });

        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );
        systemThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "system");
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
            updateThemeButtons();
        });

        window
            .matchMedia("(prefers-color-scheme: dark)")
            .addEventListener("change", (event) => {
                if (localStorage.theme === "system") {
                    toggleTheme(event.matches);
                }
            });

        document.addEventListener("scroll", onScroll);
    }

    function updateThemeButtons() {
        const theme = localStorage.getItem("theme");
        const lightThemeButton = document.getElementById("light-theme-button");
        const darkThemeButton = document.getElementById("dark-theme-button");
        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );

        function removeActiveButtonTheme(button) {
            button?.classList.remove("bg-black/5");
            button?.classList.remove("dark:bg-white/5");
        }

        function addActiveButtonTheme(button) {
            button?.classList.add("bg-black/5");
            button?.classList.add("dark:bg-white/5");
        }

        removeActiveButtonTheme(lightThemeButton);
        removeActiveButtonTheme(darkThemeButton);
        removeActiveButtonTheme(systemThemeButton);

        if (theme === "light") {
            addActiveButtonTheme(lightThemeButton);
        } else if (theme === "dark") {
            addActiveButtonTheme(darkThemeButton);
        } else {
            addActiveButtonTheme(systemThemeButton);
        }
    }

    function animate() {
        const animateElements = document.querySelectorAll(".animate");

        animateElements.forEach((element, index) => {
            setTimeout(() => {
                element.classList.add("show");
            }, index * 100);
        });
    }

    function onScroll() {
        if (window.scrollY > 0) {
            document.documentElement.classList.add("scrolled");
        } else {
            document.documentElement.classList.remove("scrolled");
        }
    }

    function scrollToTop(event) {
        event.preventDefault();
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    }

    function toggleTheme(dark) {
        const css = document.createElement("style");

        css.appendChild(
            document.createTextNode(
                `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
            ),
        );

        document.head.appendChild(css);

        if (dark) {
            document.documentElement.classList.add("dark");
        } else {
            document.documentElement.classList.remove("dark");
        }

        window.getComputedStyle(css).opacity;
        document.head.removeChild(css);

        setGiscusTheme();
    }

    function preloadTheme() {
        const userTheme = localStorage.theme;

        if (userTheme === "light" || userTheme === "dark") {
            toggleTheme(userTheme === "dark");
        } else {
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
        }
    }

    function addCopyCodeButtons() {
        let copyButtonLabel = "ðŸ“‹";
        let codeBlocks = Array.from(document.querySelectorAll("pre"));

        async function copyCode(codeBlock, copyButton) {
            const codeText = codeBlock.innerText;
            const buttonText = copyButton.innerText;
            const textToCopy = codeText.replace(buttonText, "");

            await navigator.clipboard.writeText(textToCopy);
            copyButton.innerText = "âœ…";

            setTimeout(() => {
                copyButton.innerText = copyButtonLabel;
            }, 2000);
        }

        for (let codeBlock of codeBlocks) {
            const wrapper = document.createElement("div");
            wrapper.style.position = "relative";

            const copyButton = document.createElement("button");
            copyButton.innerText = copyButtonLabel;
            copyButton.classList = "copy-code";

            codeBlock.setAttribute("tabindex", "0");
            codeBlock.appendChild(copyButton);

            codeBlock.parentNode.insertBefore(wrapper, codeBlock);
            wrapper.appendChild(codeBlock);

            copyButton?.addEventListener("click", async () => {
                await copyCode(codeBlock, copyButton);
            });
        }
    }

    const setGiscusTheme = () => {
        const giscus = document.querySelector(".giscus-frame");

        const isDark = document.documentElement.classList.contains("dark");

        if (giscus) {
            const url = new URL(giscus.src);
            url.searchParams.set("theme", isDark ? "dark" : "light");
            giscus.src = url.toString();
        }
    };

    document.addEventListener("DOMContentLoaded", () => init());
    document.addEventListener("astro:after-swap", () => init());
    preloadTheme();
</script><link rel="stylesheet" href="/_astro/_subject_.DPh3UX5U.css">
<style>summary[data-astro-cid-xvrfupwn]{cursor:pointer;border-top-left-radius:.5rem;border-top-right-radius:.5rem;padding:.375rem .75rem;font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}summary[data-astro-cid-xvrfupwn]:hover{background-color:#0000000d}summary[data-astro-cid-xvrfupwn]:hover:is(.dark *){background-color:#ffffff0d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]{background-color:#0000000d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]:is(.dark *){background-color:#ffffff0d}
</style><script type="module" src="/_astro/hoisted.DEn2kOLu.js"></script></head> <body> <header data-astro-transition-persist="astro-l7r54iwe-1"> <div class="mx-auto max-w-screen-sm px-3"> <div class="flex flex-wrap justify-between gap-y-2"> <a href="/" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out">  <div class="font-semibold"> rezvan.xyz </div>  </a> <nav class="flex items-center gap-1 text-sm"> <a href="/posts" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> posts </a> <span> / </span> <a href="/chalmers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> chalmers </a> <span> / </span> <a href="/cityu" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> cityu </a> <span> / </span> <a href="/pdf/cv/cv.pdf" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> cv </a> <span> / </span> <button id="magnifying-glass" aria-label="Search" class="flex items-center rounded border border-black/15 bg-neutral-100 px-2 py-1 text-xs transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:bg-neutral-900 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg height="16" stroke-linejoin="round" viewBox="0 0 16 16" width="16" style="color: currentcolor;"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 7C3.5 5.067 5.067 3.5 7 3.5C8.933 3.5 10.5 5.067 10.5 7C10.5 7.88461 10.1718 8.69256 9.63058 9.30876L9.30876 9.63058C8.69256 10.1718 7.88461 10.5 7 10.5C5.067 10.5 3.5 8.933 3.5 7ZM9.96544 11.0261C9.13578 11.6382 8.11014 12 7 12C4.23858 12 2 9.76142 2 7C2 4.23858 4.23858 2 7 2C9.76142 2 12 4.23858 12 7C12 8.11014 11.6382 9.13578 11.0261 9.96544L14.0303 12.9697L14.5607 13.5L13.5 14.5607L12.9697 14.0303L9.96544 11.0261Z" fill="currentColor"></path></svg>
&nbsp;Search
</button> </nav> </div> </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-3"> <div class="animate"> <a href="/chalmers/dat038" class="not-prose group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-7 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm"> Back to data structures algorithms </div> </a> </div> <div class="my-10 space-y-1"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> DAT038 </div>
&bull;
<div class="font-base text-sm"> <time datetime="2022-11-29T17:50:23.000Z"> November 30, 2022 </time> </div> 
&bull;
<div class="font-base text-sm">
Last modified:  <time datetime="2024-09-02T11:21:25.000Z"> September 02, 2024 </time> </div> 
&bull;
<div class="font-base text-sm"> 13 min read </div> </div> <h1 class="animate text-3xl font-semibold text-black dark:text-white"> Part 5 - Hash Tables </h1> </div> <details open class="animate rounded-lg border border-black/15 dark:border-white/20" data-astro-cid-xvrfupwn> <summary data-astro-cid-xvrfupwn>Table of Contents</summary> <nav class="" data-astro-cid-xvrfupwn> <ul class="py-3" data-astro-cid-xvrfupwn> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#hash-tables" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Hash Tables </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#sets-and-maps-in-context" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Sets and Maps in Context </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#separate-chaining-hash-tables" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Separate Chaining Hash Tables </a> <ul class="translate-x-3"> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#hash-functions" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Hash Functions </a>  </li> </ul> </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#hash-tables-1" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Hash Tables </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#separate-chaining" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Separate Chaining </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#open-addressing-hash-tables" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Open Addressing Hash Tables </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#separate-chaining-hash-set" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Separate Chaining: Hash Set </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#load-factor" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Load Factor </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#hash-and-compress" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Hash and compress </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#requirements-on-hash-functions" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Requirements on hash functions </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#open-addressing-probing" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Open Addressing: Probing </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#open-addressing-compared-to-separate-chaining" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Open Addressing compared to Separate Chaining </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#deletion" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Deletion </a> <ul class="translate-x-3"> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#naive-approach" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Naive approach </a>  </li> </ul> </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#final-implementations" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Final implementations </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#clustering" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Clustering </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#alternatives-to-linear-probing" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Alternatives to linear probing </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#summary" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Summary </a>  </li> </ul> </nav> </details> <article class="animate"> <h3 id="hash-tables">Hash Tables</h3>
<p>Hash tables are one of the most famous (and widely used) data structures. But why are they so popular and powerful?
Before we can answer that question we need to look back at sets and maps.</p>
<h3 id="sets-and-maps-in-context">Sets and Maps in Context</h3>
<p>Just to refresh our memory - a set is a <em>collection of items</em>, where duplicates arenâ€™t allowed.
Maps are <strong>sets</strong> of <em>keys</em>, each having an associate value - or you can formulate it as - a <strong>set</strong> of <em>key-value pairs</em>.</p>
<p>Maps are used in almost all programs and applications since theyâ€™re very powerful and intuitive. They can act as databases (some databases are just straight up maps as well):</p>
<ul>
<li>Look up a person by their social security number.</li>
<li>Look up a file in a computer by its name/filetype/size.</li>
<li>Find all words appearing in a text/website/book.</li>
</ul>
<p>Only problem is that, our usual implementation of maps makes the <code>search()</code> and <code>update()</code> are quite slow, in fact, the complexity is usually
$\mathcal{O}(n)$ or in case weâ€™re using a <em>mutlimap</em> $\mathcal{O}(n \cdot m)$.</p>
<p>We would like a complexity of $\mathcal{O}(log(n))$ or $\mathcal{O}(1)$. Even if we implement maps using all the different data structures we have - we still canâ€™t achieve this:</p>
<ul>
<li>Dynamic Array of key-value pairs
<ul>
<li>Search takes linear time</li>
<li>Insertion takes linear time</li>
</ul>
</li>
<li>A Linked List
<ul>
<li>Same as the dynamic array</li>
</ul>
</li>
<li>A <em>sorted</em> Dynamic Array
<ul>
<li>Search takes logarithmic time (binary search).</li>
<li>Insertion still takes linear timeâ€¦</li>
</ul>
</li>
</ul>
<p>The answer is <em><strong>Hash Tables</strong></em>!</p>
<h3 id="separate-chaining-hash-tables">Separate Chaining Hash Tables</h3>
<p>One thing to know before we dive in is - there are two different strategies when it comes to tables, weâ€™ll begin with separate chaining.</p>
<h4 id="hash-functions">Hash Functions</h4>
<p>Before we start talking about what a hash <strong>table</strong> is we first need to look into what a hash <strong>function</strong> is. The problem with ordinary maps that they are an unordered data structure.
We need some kind of function which calculates, based on different parameters, where <code>Item x</code> should go into our map, because afterward, we can just search for that index, which is much faster. This is what hash functions are for!</p>
<p>At the same time our hash functions needs to be â€˜goodâ€™. We canâ€™t have a hash functions that only returns index 1 and stack every item into the same slot. But we also canâ€™t be lazy, in the example of sorting a collection of people.
We canâ€™t just go by their first letter in their name, there are a lot more names that begin with a â€˜Aâ€™ than a â€˜Zâ€™ for example.</p>
<p>So we want a hash functions that also <em>evenly</em> distributes the objects, and at the same time efficient to compute.</p>
<p>With this in mind we can now define a hash table.</p>
<h3 id="hash-tables-1">Hash Tables</h3>
<p>A hash table uses a hash function to compute the array index. Itâ€™s not possible to put more than one object into one array slot, so if our hash function returns the same index for different objects (we will later see, by definition, this is a bad hash function) we need a solution.
Separate chaining is one of them.</p>
<h3 id="separate-chaining">Separate Chaining</h3>
<p>In a separate chaining hash table, instead of having just one array slot, we instead have the value/slots being a pointer. This pointer then points to collections of all the values/objects having the same hash value.</p>
<p>Usually this is a linked list, but any searchable collection works (A dynamic array for example).</p>
<h3 id="open-addressing-hash-tables">Open Addressing Hash Tables</h3>
<p>In the other case, being open addressing, each slot contains exactly one object/value. However - if we ever encounter a conflict, we just move that value/object into a free slot, the tricky part is an efficient way of finding a free slot.
Weâ€™ll see more of this later.</p>
<h3 id="separate-chaining-hash-set">Separate Chaining: Hash Set</h3>
<p>For our implementation of Hash tables using separate chaining we could use sets - and for the underlying collection, we usually use linked lists.</p>
<p>So a kind of implementation (in pseudocode) would be:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashSet &#x3C;Item> implements Set&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of Set&#x3C;Item></span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // A given good hash function</span></span>
<span class="line"><span>    hash(x : Item) -> int:</span></span>
<span class="line"><span>        // Returns good hash value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(x : Item) -> boolean:</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        return bucket.contains(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        bucket.add(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(x : Item):</span></span>
<span class="line"><span>        bucket : Set&#x3C;Item> = table[hash(x)]</span></span>
<span class="line"><span>        bucket.remove(x)</span></span>
<span class="line"><span></span></span></code></pre>
<p>As we can see there is quite a lot of â€˜mental overheadâ€™, using an ordinary map it also becomes faster since we have actual key-value pairs, therefore being faster.
Also, we need to know the size of the Hash table and also handle null pointers so letâ€™s fix that as well!</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashMap&#x3C;Key, Value> implements Map&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Array of Map&#x3C;Key, Value></span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    hash(k : Key) -> int:</span></span>
<span class="line"><span>        // Returns good hash value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(k : Key) -> boolean:</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        return bucket.contains(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    get(k : Key) -> Value:</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        return bucket.get(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        if bucket == NULL:</span></span>
<span class="line"><span>            bucket = table[hash(x)] = new Map()</span></span>
<span class="line"><span>        if not bucket.contains(k):</span></span>
<span class="line"><span>            bucket.put(k, v)</span></span>
<span class="line"><span>            size += 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(k : Key):</span></span>
<span class="line"><span>        bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        bucket.remove(k)</span></span>
<span class="line"><span></span></span></code></pre>
<p>If we actually try to implement it with the underlying data structure, the linked list, it would look something like:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SeparateChainingHashMap&#x3C;Key, Value> implements Map&#x3C;Key, Value>:</span></span>
<span class="line"><span>    ...</span></span>
<span class="line"><span>    class Node:</span></span>
<span class="line"><span>        key : Key</span></span>
<span class="line"><span>        val : Value</span></span>
<span class="line"><span>        next : Node</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    get(k : Key) -> Value:</span></span>
<span class="line"><span>        node : Node = table[hash(k)]</span></span>
<span class="line"><span>        while node != NULL:</span></span>
<span class="line"><span>            if k == node.key</span></span>
<span class="line"><span>                return node.val</span></span>
<span class="line"><span>            node = node.next</span></span>
<span class="line"><span>        return NULL</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        h : int = hash(k)</span></span>
<span class="line"><span>        node : Node = table[h]</span></span>
<span class="line"><span>        while node != NULL:</span></span>
<span class="line"><span>            if k == node.key:</span></span>
<span class="line"><span>                node.val = v</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            node = node.next</span></span>
<span class="line"><span>        // If we are given a new key</span></span>
<span class="line"><span>        table[h] = Node(k, v, table[h])</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="load-factor">Load Factor</h3>
<p>We should always assume that we have a good hash functions, since in most libraries, they are good! But to understand why itâ€™s â€˜goodâ€™ we need to understand something called <em>Load factor</em>.
The load factor is the average number of elements per slot/index.</p>
<p>So load factor = $\frac{N}{M}$, where N is # of elements and M is the array size.
We havenâ€™t discussed it yet but, whatâ€™s the complexity of <code>contains</code>, <code>add</code>, and <code>put</code> for example? Well it depends on the total array size and the number of elements per slot. The load factor!</p>
<p>Therefore, the complexity of each operation is $\mathcal{O}(\frac{N}{M})$</p>
<p>Which tells us, if we can keep N and M roughly the same all of our operations will be constant! This is the magic with Hash tables.</p>
<p>So our array size must grow when the hash table grows. To achieve this we use a dynamic array, when we need to resize the hash table array, we create a new array and copy all old elements using <code>add()</code>.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>put(k : Key, v : Value):</span></span>
<span class="line"><span>    if size >= 8 * table.length:</span></span>
<span class="line"><span>        resize(2 * table.length)</span></span>
<span class="line"><span>    bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        if bucket == NULL:</span></span>
<span class="line"><span>            bucket = table[hash(x)] = new Map()</span></span>
<span class="line"><span>        if not bucket.contains(k):</span></span>
<span class="line"><span>            bucket.put(k, v)</span></span>
<span class="line"><span>            size += 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>remove(k : Key):</span></span>
<span class="line"><span>    if size â‰¤ 2 * table.length:</span></span>
<span class="line"><span>        resize(table.length / 2)</span></span>
<span class="line"><span>    bucket : Map&#x3C;Key, Value> = table[hash(k)]</span></span>
<span class="line"><span>        bucket.remove(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>resize(buckets : int):</span></span>
<span class="line"><span>    oldtable = table</span></span>
<span class="line"><span>    table = new Array with size buckets</span></span>
<span class="line"><span>    size = 0</span></span>
<span class="line"><span>    for bucket in oldtable:</span></span>
<span class="line"><span>        for k,v in bucket:</span></span>
<span class="line"><span>            this.put(k, v)</span></span>
<span class="line"><span></span></span></code></pre>
<p>In this example Iâ€™ve chosen to resize the table with a factor of 2. However, this is can actually lead to some problems.
The â€˜optimalâ€™ way is to choose a <em>prime</em> closest to <code>2 * oldsize</code>.</p>
<h3 id="hash-and-compress">Hash and compress</h3>
<p>In actuality, the hash functions are a composition of functions. First we get the <em>hash code</em> for a given object/value. Then we need to <em>compress</em> it to fit inside our hash table.</p>
<p>How we compress our is quite simple (often) - it is:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>index = hash_code % array_size</span></span>
<span class="line"><span>i = h % M</span></span>
<span class="line"><span></span></span></code></pre>
<p>This is called â€˜modularâ€™ hashing, itâ€™s the most common one. One thing to remember that the <em>hash code</em> <strong>never</strong> changes. Only the compressed version can change since we can change the size of it.</p>
<p>So we might see different outputs for <code>hash(x)</code> depending on size - but remember, the actual <em>hash code</em> <strong>never</strong> changes.</p>
<h3 id="requirements-on-hash-functions">Requirements on hash functions</h3>
<p>There is one very strict requirement on hash functions:</p>
<ul>
<li>Equal objects must have equal hash codes</li>
</ul>
<p>Or in coding terms:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>if x === y then x.hash() == y.hash()</span></span>
<span class="line"><span></span></span></code></pre>
<p>There are some desirable properties:</p>
<ul>
<li>If x and y have the same <em>hash code</em>, then they are â€˜equalâ€™</li>
<li>The distribution should be uniform and independent</li>
</ul>
<h3 id="open-addressing-probing">Open Addressing: Probing</h3>
<p>As we defined earlier, open addressing is a method where we find a new empty slot if thereâ€™s a conflict. Probing is how we find this empty slot.</p>
<p>The easiest approach is so called <em>linear probing</em>, where we simply go to the next index (increase with some constant) and check if itâ€™s empty, with wrapping around the array.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashSet&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of Item</span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>                if x == table[i]:</span></span>
<span class="line"><span>                    return</span></span>
<span class="line"><span>                i = (i + 1) % table.length</span></span>
<span class="line"><span>        table[i] = x</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span></span></span></code></pre>
<p>Or in the Hash Map case:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashMap&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Map&#x3C;Key, Value></span></span>
<span class="line"><span>    size : int = 0</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(k : Key, v : Value):</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>                if k == table[i]:</span></span>
<span class="line"><span>                    return</span></span>
<span class="line"><span>                i = (i + 1) % table.length</span></span>
<span class="line"><span>        table[i] = value</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="open-addressing-compared-to-separate-chaining">Open Addressing compared to Separate Chaining</h3>
<p>Letâ€™s now compare both of these approaches now that we have a grasp of them.</p>
<ul>
<li>Separate Chaining
<ul>
<li>Load factor can be > 1 without performance loss.</li>
<li>The extra list nodes take up unnecessary memory.</li>
<li>Since the list nodes are (usually) scattered in memory - we can not optimize via for example CPU caching.</li>
</ul>
</li>
<li>Open Addressing
<ul>
<li>Load factor <strong>must</strong> be &#x3C; 1, and the performance drops when load factor > 3/4.</li>
<li>Doesnâ€™t take up unnecessary memory with extra list nodes.</li>
<li>Elements with the same hash code tend to be close in memory - therefore we can utilize CPU caching.</li>
</ul>
</li>
</ul>
<h3 id="deletion">Deletion</h3>
<p>If we want to delete object while using Open Addressing - we will encounter a very famous problem called â€˜clustersâ€™.
A short definition of clusters is, due to Open Addressing, we will get small â€˜clustersâ€™ or â€˜chunksâ€™. These are quite valuable since they tell us which objects have similar hash codes.</p>
<p>But first to understand why, letâ€™s see how we <em>would</em> delete items.</p>
<h4 id="naive-approach">Naive approach</h4>
<p>Our naive approach would look something like:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>remove(x : Item):</span></span>
<span class="line"><span>    i = hash(x)</span></span>
<span class="line"><span>    while table[i] != NULL:</span></span>
<span class="line"><span>        if x == table[i]:</span></span>
<span class="line"><span>            table[i] = NULL</span></span>
<span class="line"><span>        i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span></code></pre>
<p>And in the map case:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>remove(k : Key):</span></span>
<span class="line"><span>    i = hash(x)</span></span>
<span class="line"><span>    while table[i] != NULL:</span></span>
<span class="line"><span>        if k == table[i]:</span></span>
<span class="line"><span>            table[i] = NULL</span></span>
<span class="line"><span>        i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span></code></pre>
<p>But this wonâ€™t work - if we then want to find something to the <strong>right</strong> of this deleted cell - but their hash is <strong>before</strong> the deleted cell, we wonâ€™t be able to, since we find the â€˜NULLâ€™ value before we can find the actual object.</p>
<p>There are two possible solutions:</p>
<ul>
<li>Lazy deletion:
<ul>
<li>We donâ€™t necessarily â€˜deleteâ€™ the item, just â€˜markâ€™ it deleted, rather than empty.</li>
</ul>
</li>
<li>Recalculation:
<ul>
<li>We reinsert all elements in the cluster that are to the <strong>right</strong> of the deleted element.</li>
</ul>
</li>
</ul>
<p>One problem we will also encounter is, we wonâ€™t be able to properly count # of deleted cells - therefore our resizing calculations will suffer - the solution is to have a variable for each deleted cell.
If this number exceeds some threshold we resize.</p>
<h3 id="final-implementations">Final implementations</h3>
<p>So, we have covered all topics and problems that come with implementing Hash tables - so letâ€™s implement the final version.</p>
<p>For a Hash <strong>Set</strong>:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashSet&#x3C;Item>:</span></span>
<span class="line"><span>    table: Array of HashCell</span></span>
<span class="line"><span>    size: int = 0</span></span>
<span class="line"><span>    n_deleted: int = 0</span></span>
<span class="line"><span>    DELETED: HashCell = HashCell(value = NULL)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class HashCell:</span></span>
<span class="line"><span>        value: Item</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    load_factor() -> float:</span></span>
<span class="line"><span>        return (size + deleted) / table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    add(x : Item):</span></span>
<span class="line"><span>        if load_factor() > 0.75:</span></span>
<span class="line"><span>            resize(2 * table.length)</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while table[i] != NULL and table[i] != DELETED:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span>        if table[i] = DELETED:</span></span>
<span class="line"><span>            n_deleted -= 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        table[i] = HashCell(value = x)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(x : Item) -> boolean:</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                return True</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        return False</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(x : Item):</span></span>
<span class="line"><span>        i = hash(x)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if x == table[i].value:</span></span>
<span class="line"><span>                table[i] = DELETED</span></span>
<span class="line"><span>                size -= 1</span></span>
<span class="line"><span>                n_deleted += 1</span></span>
<span class="line"><span>                if load_factor() &#x3C; 0.25:</span></span>
<span class="line"><span>                    resize(table.length // 2)</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    resize(buckets: int):</span></span>
<span class="line"><span>        oldtable = table</span></span>
<span class="line"><span>        table = new Array with size buckets</span></span>
<span class="line"><span>        size = n_deleted = 0</span></span>
<span class="line"><span>        for cell in oldtable:</span></span>
<span class="line"><span>            if cell != NULL and cell != DELETED:</span></span>
<span class="line"><span>                table.add(cell.value)</span></span>
<span class="line"><span></span></span></code></pre>
<p>And in the <strong>Map</strong> case:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LinearProbingHashMap&#x3C;Key, Value>:</span></span>
<span class="line"><span>    table: Array of HashCell</span></span>
<span class="line"><span>    size: int = 0</span></span>
<span class="line"><span>    n_deleted: int = 0</span></span>
<span class="line"><span>    DELETED: HashCell = HashCell(key = NULL,value = NULL)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    class HashCell:</span></span>
<span class="line"><span>        key: Key</span></span>
<span class="line"><span>        value: Value</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    load_factor() -> float:</span></span>
<span class="line"><span>        return (size + deleted) / table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    put(k : Key, v : Value):</span></span>
<span class="line"><span>        if load_factor() > 0.75:</span></span>
<span class="line"><span>            resize(2 * table.length)</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while table[i] != NULL and table[i] != DELETED:</span></span>
<span class="line"><span>            if k == table[i].key:</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        size += 1</span></span>
<span class="line"><span>        if table[i] = DELETED:</span></span>
<span class="line"><span>            n_deleted -= 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        table[i] = HashCell(key = k, value = v)</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    contains(k : Key) -> boolean:</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if k == table[i].key:</span></span>
<span class="line"><span>                return True</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span>        return False</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    remove(k : Key):</span></span>
<span class="line"><span>        i = hash(k)</span></span>
<span class="line"><span>        while table[i] != NULL:</span></span>
<span class="line"><span>            if k == table[i].value:</span></span>
<span class="line"><span>                table[i] = DELETED</span></span>
<span class="line"><span>                size -= 1</span></span>
<span class="line"><span>                n_deleted += 1</span></span>
<span class="line"><span>                if load_factor() &#x3C; 0.25:</span></span>
<span class="line"><span>                    resize(table.length // 2)</span></span>
<span class="line"><span>                return</span></span>
<span class="line"><span>            i = (i + 1) % table.length</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    resize(buckets: int):</span></span>
<span class="line"><span>        oldtable = table</span></span>
<span class="line"><span>        table = new Array with size buckets</span></span>
<span class="line"><span>        size = n_deleted = 0</span></span>
<span class="line"><span>        for cell in oldtable:</span></span>
<span class="line"><span>            if cell != NULL and cell != DELETED:</span></span>
<span class="line"><span>                table.add(cell.key, cell.value)</span></span>
<span class="line"><span></span></span></code></pre>
<h3 id="clustering">Clustering</h3>
<p>As mentioned before - clusters is by-product of open addressing - but these make the search times slower, in the worst time it becomes linear!</p>
<p>The famous Donald E. Knuth formulated the so called â€˜Knuthâ€™s parking problemâ€™ which shows how rapid this cluster problem grows.</p>
<h3 id="alternatives-to-linear-probing">Alternatives to linear probing</h3>
<p>Instead of linearly increase, we could do <em>quadratic</em>, <em>double hashing</em> which depends on a <em>second</em> hash function, or <em>moving</em> alternatives such as:
<em>cuckoo</em>, <em>hopscotch</em> and <em>Robin Hood</em> hashing. We will only use linear probing thoughâ€¦</p>
<h3 id="summary">Summary</h3>
<p>Thereâ€™s <strong>a lot</strong> to hashing and hash tables in general. But I think weâ€™ll leave it here, one final thing I want to bring up is:</p>
<p>Hash tables are not ordered! If we want to find a maximum value in a hash table - it will take linear time! Since thereâ€™s no underlying order.</p>
<p>In the next part weâ€™ll begin looking at trees - starting at <strong>B</strong>alanced <strong>S</strong>earch <strong>T</strong>rees or BSTs for short. Weâ€™ll actually compare them to Hash maps, since they are quite similar in some aspects.</p> <div class="mt-24"> <div class="grid grid-cols-2 gap-1.5 sm:gap-3"> <a href="/chalmers/dat038/dat038_4" class="group relative flex flex-nowrap rounded-lg border border-black/15 px-4 py-3 pl-10 no-underline transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-5 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-3 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="flex items-center text-sm"> Part 4 - Abstract Data Types </div> </a> <a href="/chalmers/dat038/dat038_6" class="group relative flex flex-grow flex-row-reverse flex-nowrap rounded-lg border border-black/15 px-4 py-4 pr-10 no-underline transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute right-2 top-1/2 size-5 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-3 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 19 12 12 19" class="-translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="flex items-center text-sm"> Part 6 - Trees </div> </a> </div> </div> <div class="mt-24"> <div class="giscus"></div> <script data-astro-rerun src="https://giscus.app/client.js" data-repo="rezaarezvan/rezvan.xyz" data-repo-id="R_kgDOHvQr3w" data-category="General" data-category-id="DIC_kwDOHvQr384CiWVC" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="en" data-loading="lazy" crossorigin="anonymous" async></script> </div> </article> </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-3"> <div class="relative"> <div class="absolute -top-12 right-0"> <button id="back-to-top" class="group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-8 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 rotate-90 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm">Back to top</div> </button> </div> </div> <div class="flex items-center justify-between"> <div>&copy; 2024 â€¢ rezvan.xyz </div> <div class="flex flex-wrap items-center gap-1.5"> <button id="light-theme-button" aria-label="Light theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect> <line x1="8" y1="21" x2="16" y2="21"></line> <line x1="12" y1="17" x2="12" y2="21"></line> </svg> </button> </div> </div> </div> </footer> <aside data-pagefind-ignore> <div id="backdrop" class="bg-[rgba(0, 0, 0, 0.5] invisible fixed left-0 top-0 z-50 flex h-screen w-full justify-center p-6 backdrop-blur-sm" data-astro-transition-persist="astro-3snakcvo-2"> <div id="pagefind-container" class="m-0 flex h-fit max-h-[80%] w-full max-w-screen-sm flex-col overflow-auto rounded border border-black/15 bg-neutral-100 p-2 px-4 py-3 shadow-lg dark:border-white/20 dark:bg-neutral-900"> <div id="search" class="pagefind-ui pagefind-init" data-pagefind-ui data-bundle-path="/pagefind/" data-ui-options="{&#34;showImages&#34;:false,&#34;excerptLength&#34;:15,&#34;resetStyles&#34;:false}"></div>  <div class="mr-2 pb-1 pt-4 text-right text-xs dark:prose-invert">
Press <span class="prose text-xs dark:prose-invert"><kbd class="">Esc</kbd></span> or click anywhere to close
</div> </div> </div> </aside> <script>
  const magnifyingGlass = document.getElementById("magnifying-glass");
  const backdrop = document.getElementById("backdrop");

  function openPagefind() {
    const searchDiv = document.getElementById("search");
    const search = searchDiv.querySelector("input");
    setTimeout(() => {
      search.focus();
    }, 0);
    backdrop?.classList.remove("invisible");
    backdrop?.classList.add("visible");
  }

  function closePagefind() {
    const search = document.getElementById("search");
    search.value = "";
    backdrop?.classList.remove("visible");
    backdrop?.classList.add("invisible");
  }

  // open pagefind
  magnifyingGlass?.addEventListener("click", () => {
    openPagefind();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "/") {
      e.preventDefault();
      openPagefind();
    } else if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      openPagefind();
    }
  });

  // close pagefind
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" || e.keyCode === 27) {
      closePagefind();
    }
  });

  // close pagefind when searched result(link) clicked
  document.addEventListener("click", (event) => {
    if (event.target.classList.contains("pagefind-ui__result-link")) {
      closePagefind();
    }
  });

  backdrop?.addEventListener("click", (event) => {
    if (!event.target.closest("#pagefind-container")) {
      closePagefind();
    }
  });

  // prevent form submission
  const form = document.getElementById("form");
  form?.addEventListener("submit", (event) => {
    event.preventDefault();
  });
</script>  </body></html>