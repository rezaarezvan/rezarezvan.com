<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/icon" href="/favicon.ico"><meta name="generator" content="Astro v4.11.5"><!-- Canonical URL --><link rel="canonical" href="https://rezvan.xyz/chalmers/tda384/tda384_4/"><!-- Primary Meta Tags --><title>Part 4 - Synchronization problems (1) | concurrent programming | rezvan.xyz</title><meta name="title" content="Part 4 - Synchronization problems (1) | concurrent programming | rezvan.xyz"><meta name="description"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://rezvan.xyz/chalmers/tda384/tda384_4/"><meta property="og:title" content="Part 4 - Synchronization problems (1) | concurrent programming | rezvan.xyz"><meta property="og:description"><meta property="og:image" content="https://rezvan.xyz/favicon.ico"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://rezvan.xyz/chalmers/tda384/tda384_4/"><meta property="twitter:title" content="Part 4 - Synchronization problems (1) | concurrent programming | rezvan.xyz"><meta property="twitter:description"><meta property="twitter:image" content="https://rezvan.xyz/favicon.ico"><!-- PageFind --><link href="/pagefind/pagefind-ui.css" rel="stylesheet"><script src="/pagefind/pagefind-ui.js"></script><!-- KaTeX support --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.15.2/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script><!-- inline KaTeX --><script>
    function renderKaTeX() {
        if (typeof renderMathInElement !== "undefined") {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                ],
            });
        }
    }

    document.addEventListener("DOMContentLoaded", renderKaTeX);
    document.addEventListener("astro:after-swap", renderKaTeX);
</script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script>
    function init() {
        preloadTheme();
        onScroll();
        animate();
        updateThemeButtons();
        addCopyCodeButtons();
        setGiscusTheme();

        const backToTop = document.getElementById("back-to-top");
        backToTop?.addEventListener("click", (event) => scrollToTop(event));

        const backToPrev = document.getElementById("back-to-prev");
        backToPrev?.addEventListener("click", () => window.history.back());

        const lightThemeButton = document.getElementById("light-theme-button");
        lightThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "light");
            toggleTheme(false);
            updateThemeButtons();
        });

        const darkThemeButton = document.getElementById("dark-theme-button");
        darkThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "dark");
            toggleTheme(true);
            updateThemeButtons();
        });

        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );
        systemThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "system");
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
            updateThemeButtons();
        });

        window
            .matchMedia("(prefers-color-scheme: dark)")
            .addEventListener("change", (event) => {
                if (localStorage.theme === "system") {
                    toggleTheme(event.matches);
                }
            });

        document.addEventListener("scroll", onScroll);
    }

    function updateThemeButtons() {
        const theme = localStorage.getItem("theme");
        const lightThemeButton = document.getElementById("light-theme-button");
        const darkThemeButton = document.getElementById("dark-theme-button");
        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );

        function removeActiveButtonTheme(button) {
            button?.classList.remove("bg-black/5");
            button?.classList.remove("dark:bg-white/5");
        }

        function addActiveButtonTheme(button) {
            button?.classList.add("bg-black/5");
            button?.classList.add("dark:bg-white/5");
        }

        removeActiveButtonTheme(lightThemeButton);
        removeActiveButtonTheme(darkThemeButton);
        removeActiveButtonTheme(systemThemeButton);

        if (theme === "light") {
            addActiveButtonTheme(lightThemeButton);
        } else if (theme === "dark") {
            addActiveButtonTheme(darkThemeButton);
        } else {
            addActiveButtonTheme(systemThemeButton);
        }
    }

    function animate() {
        const animateElements = document.querySelectorAll(".animate");

        animateElements.forEach((element, index) => {
            setTimeout(() => {
                element.classList.add("show");
            }, index * 100);
        });
    }

    function onScroll() {
        if (window.scrollY > 0) {
            document.documentElement.classList.add("scrolled");
        } else {
            document.documentElement.classList.remove("scrolled");
        }
    }

    function scrollToTop(event) {
        event.preventDefault();
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    }

    function toggleTheme(dark) {
        const css = document.createElement("style");

        css.appendChild(
            document.createTextNode(
                `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
            ),
        );

        document.head.appendChild(css);

        if (dark) {
            document.documentElement.classList.add("dark");
        } else {
            document.documentElement.classList.remove("dark");
        }

        window.getComputedStyle(css).opacity;
        document.head.removeChild(css);

        setGiscusTheme();
    }

    function preloadTheme() {
        const userTheme = localStorage.theme;

        if (userTheme === "light" || userTheme === "dark") {
            toggleTheme(userTheme === "dark");
        } else {
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
        }
    }

    function addCopyCodeButtons() {
        let copyButtonLabel = "ðŸ“‹";
        let codeBlocks = Array.from(document.querySelectorAll("pre"));

        async function copyCode(codeBlock, copyButton) {
            const codeText = codeBlock.innerText;
            const buttonText = copyButton.innerText;
            const textToCopy = codeText.replace(buttonText, "");

            await navigator.clipboard.writeText(textToCopy);
            copyButton.innerText = "âœ…";

            setTimeout(() => {
                copyButton.innerText = copyButtonLabel;
            }, 2000);
        }

        for (let codeBlock of codeBlocks) {
            const wrapper = document.createElement("div");
            wrapper.style.position = "relative";

            const copyButton = document.createElement("button");
            copyButton.innerText = copyButtonLabel;
            copyButton.classList = "copy-code";

            codeBlock.setAttribute("tabindex", "0");
            codeBlock.appendChild(copyButton);

            codeBlock.parentNode.insertBefore(wrapper, codeBlock);
            wrapper.appendChild(codeBlock);

            copyButton?.addEventListener("click", async () => {
                await copyCode(codeBlock, copyButton);
            });
        }
    }

    const setGiscusTheme = () => {
        const giscus = document.querySelector(".giscus-frame");

        const isDark = document.documentElement.classList.contains("dark");

        if (giscus) {
            const url = new URL(giscus.src);
            url.searchParams.set("theme", isDark ? "dark" : "light");
            giscus.src = url.toString();
        }
    };

    document.addEventListener("DOMContentLoaded", () => init());
    document.addEventListener("astro:after-swap", () => init());
    preloadTheme();
</script><link rel="stylesheet" href="/_astro/_subject_.CmU_Tg_r.css">
<style>summary[data-astro-cid-xvrfupwn]{cursor:pointer;border-top-left-radius:.5rem;border-top-right-radius:.5rem;padding:.375rem .75rem;font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}summary[data-astro-cid-xvrfupwn]:hover{background-color:#0000000d}summary[data-astro-cid-xvrfupwn]:hover:is(.dark *){background-color:#ffffff0d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]{background-color:#0000000d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]:is(.dark *){background-color:#ffffff0d}
</style><script type="module" src="/_astro/hoisted.DzxSAGjc.js"></script></head> <body> <header data-astro-transition-persist="astro-l7r54iwe-1"> <div class="mx-auto max-w-screen-sm px-3"> <div class="flex flex-wrap justify-between gap-y-2"> <a href="/" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out">  <div class="font-semibold"> rezvan.xyz </div>  </a> <nav class="flex items-center gap-1 text-sm"> <a href="/posts" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> posts </a> <span> / </span> <a href="/chalmers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> chalmers </a> <span> / </span> <a href="/cityu" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> cityu </a> <span> / </span> <button id="magnifying-glass" aria-label="Search" class="flex items-center rounded border border-black/15 bg-neutral-100 px-2 py-1 text-xs transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:bg-neutral-900 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg height="16" stroke-linejoin="round" viewBox="0 0 16 16" width="16" style="color: currentcolor;"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 7C3.5 5.067 5.067 3.5 7 3.5C8.933 3.5 10.5 5.067 10.5 7C10.5 7.88461 10.1718 8.69256 9.63058 9.30876L9.30876 9.63058C8.69256 10.1718 7.88461 10.5 7 10.5C5.067 10.5 3.5 8.933 3.5 7ZM9.96544 11.0261C9.13578 11.6382 8.11014 12 7 12C4.23858 12 2 9.76142 2 7C2 4.23858 4.23858 2 7 2C9.76142 2 12 4.23858 12 7C12 8.11014 11.6382 9.13578 11.0261 9.96544L14.0303 12.9697L14.5607 13.5L13.5 14.5607L12.9697 14.0303L9.96544 11.0261Z" fill="currentColor"></path></svg>
&nbsp;Search
</button> </nav> </div> </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-3"> <div class="animate"> <a href="/chalmers/tda384" class="not-prose group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-7 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm"> Back to concurrent programming </div> </a> </div> <div class="my-10 space-y-1"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> TDA384 </div>
&bull;
<div class="font-base text-sm"> <time datetime="2023-02-01T00:00:00.000Z"> February 01, 2023 </time> </div> 
&bull;
<div class="font-base text-sm">
Last modified:  <time datetime="2024-09-02T11:21:25.000Z"> September 02, 2024 </time> </div> 
&bull;
<div class="font-base text-sm"> 10 min read </div> </div> <h1 class="animate text-3xl font-semibold text-black dark:text-white"> Part 4 - Synchronization problems (1) </h1> </div> <details open class="animate rounded-lg border border-black/15 dark:border-white/20" data-astro-cid-xvrfupwn> <summary data-astro-cid-xvrfupwn>Table of Contents</summary> <nav class="" data-astro-cid-xvrfupwn> <ul class="py-3" data-astro-cid-xvrfupwn> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#dining-philosophers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Dining Philosophers </a> <ul class="translate-x-3"> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#solution" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Solution </a>  </li> </ul> </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#producer-consumer" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Producer-Consumer </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#unbounded-shared-buffer" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Unbounded shared buffer </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#barriers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Barriers </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#reusable-barriers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Reusable Barriers </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#readers-writers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Readers-Writers </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#summary" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Summary </a>  </li> </ul> </nav> </details> <article class="animate"> <p>In this part weâ€™ll cover how to solve some classical synchronization problems using threads and semaphores.</p>
<h3 id="dining-philosophers">Dining Philosophers</h3>
<p>To refresh our memory on the problem letâ€™s cover it again:</p>
<p>The dining philosophers problem describes how to avoid deadlock (circular conditions).</p>
<p>We have five philosophers (threads) sitting at a dining table. A fork is between each adjacent pair of philosophers.</p>
<p>Each philosopher alternates between thinking (non-critical section) and eating (critical section).
In order to eat, a philosopher needs to pick up both forks that lie to the right and left of the philosopher.</p>
<p>Since the forks are shared, there is a synchronization problem.</p>
<h4 id="solution">Solution</h4>
<p>A good solution would allow:</p>
<ul>
<li>Having an arbitrary number of philosophers</li>
</ul>
<ul>
<li>Deadlock freedom</li>
</ul>
<ul>
<li>Starvation freedom</li>
</ul>
<ul>
<li>Reasonable efficiency, it is possible to eat in parallel.</li>
</ul>
<p>Letâ€™s create an interface for the table.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>interface Table {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Philosopher at idx picks up both forks</span></span>
<span class="line"><span>    void getForks(int idx);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Philosopher at idx lies down both forks</span></span>
<span class="line"><span>    void putForks(int k);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Letâ€™s also represent each philosopher</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class Philosopher {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    int idx;</span></span>
<span class="line"><span>    Table table;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void think() {</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void eat() {</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>        .</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void run() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        while(true) {</span></span>
<span class="line"><span>            think();</span></span>
<span class="line"><span>            table.getForks();</span></span>
<span class="line"><span>            eat();</span></span>
<span class="line"><span>            table.putForks();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>One possible solution is to number each fork and philosopher. That we can easily know what is right and left of each philosopher.</p>
<p>For example:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public int left(int k) {</span></span>
<span class="line"><span>    return k;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public int right(int k) {</span></span>
<span class="line"><span>    return (k + 1) % N;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>To ensure mutual exclusion of the forks we can use semaphores.</p>
<p>We can even begin with using simple locks:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Lock[] forks = new Lock[N];</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// To pick up fork i we do</span></span>
<span class="line"><span>forks[i].lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// To put down fork i we do</span></span>
<span class="line"><span>forks[i].unlock();</span></span>
<span class="line"><span></span></span></code></pre>
<p>If we now implement a solution which makes all philosophers take up the left fork then the right fork.</p>
<p>We have a potential for deadlock, since if everyone picks up their left fork first. We have a circular waiting condition.</p>
<p>Instead, we implement a solution which ensures one philosopher picks up their right fork first, then left.
By breaking the symmetry we break the deadlock.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public void getForks(int k) {</span></span>
<span class="line"><span>    if (k == N) {</span></span>
<span class="line"><span>        forks[right(k)].lock();</span></span>
<span class="line"><span>        forks[left(k)].lock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    else {</span></span>
<span class="line"><span>        forks[left(k)].lock();</span></span>
<span class="line"><span>        forks[right(k)].lock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Another strategy could be limiting the amount of philosophers that can sit at a table. If we pick <code>M &#x3C; N</code>, we also ensure deadlock freedom.</p>
<p>We make each seat a semaphores like:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// M &#x3C; N</span></span>
<span class="line"><span>Semaphore seats = new Semaphore(M);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void getForks(int k) {</span></span>
<span class="line"><span>    seats.down()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    forks[left(k)].lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    forks[right(k)].lock();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void putForks(int k) {</span></span>
<span class="line"><span>    forks[left(k)].lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    forks[right(k)].lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    seats.down()</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>One thing that might not be obvious at first glance is that these solutions also ensure starvation freedom.
This is under the assumption that the locks/semaphores (and scheduling) are fair.</p>
<h3 id="producer-consumer">Producer-Consumer</h3>
<p>Producers and consumers exchange items through a so called shared (asynchronous) buffer.</p>
<p>The producer (asynchronously) produces items and places them on the buffer. While the consumer (asynchronously) consumes (removes) the items from the buffer.</p>
<p>So itâ€™s clear that the buffer needs to be shared. Therefore, we need a buffer that:</p>
<ul>
<li>Producers and consumers access the buffer in <strong>mutual exclusion</strong></li>
</ul>
<ul>
<li>Consumers are blocked when the buffer is empty (canâ€™t consume emptiness)</li>
</ul>
<ul>
<li>Producers are blocked when the buffer is full (canâ€™t overproduce)</li>
</ul>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>interface Buffer&#x3C;T> {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Add item onto buffer; If full block</span></span>
<span class="line"><span>    void put(T item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Extract item from buffer; If empty do nothing</span></span>
<span class="line"><span>    T get();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Get current number of items in buffer</span></span>
<span class="line"><span>    int count();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Other properties that we would like:</p>
<ul>
<li>Support an arbitrary number of producers and consumers</li>
</ul>
<ul>
<li>Deadlock freedom</li>
</ul>
<ul>
<li>Starvation freedom</li>
</ul>
<h3 id="unbounded-shared-buffer">Unbounded shared buffer</h3>
<p>One possible solution is using one lock and one semaphore:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class UnboundedBuffer&#x3C;T> implements Buffer&#x3C;T> {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Any collection (list, set, ...)</span></span>
<span class="line"><span>    Collection storage = ...;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // For exclusive access to buffer</span></span>
<span class="line"><span>    Lock lock = new Lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Number of items in buffer</span></span>
<span class="line"><span>    Semaphore nItems = new Semaphore(0);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    invariant {</span></span>
<span class="line"><span>        storage.count() == nItems.count() +</span></span>
<span class="line"><span>        at(nItems.up() in put,  lock.lock and T item = storage.remove() in get);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void put(T item) {</span></span>
<span class="line"><span>        // Lock to gain access to buffer</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /* Critical Section */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        storage.add(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // update nItems</span></span>
<span class="line"><span>        nItems.up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /* End of Critical Section */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Release access to buffer to others</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public T get() {</span></span>
<span class="line"><span>        // Wait until there is items on the buffer</span></span>
<span class="line"><span>        nItems.down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /* Critical Section */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Retrieve item</span></span>
<span class="line"><span>        T item =storage.remove();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        /* End of Critical Section */</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return item;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public int count() {</span></span>
<span class="line"><span>        return nItems.count();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This solution ensures that all requirements are met. There are some LOC that you can swap around.</p>
<p>But this will do. We can write a solution that is a so-called, bounded shared buffer, that uses two semaphores.</p>
<p>One for keeping track of how many items there are in buffer. The other to know how many slots are <strong>left</strong>.</p>
<p>Itâ€™s essentially the same code.</p>
<h3 id="barriers">Barriers</h3>
<p>A barrier in a concurrent program, is a form of synchronization where there is a point in a programâ€™s execution,
where all threads in a group, need to reach <em>before</em> any of them are allowed to continue.</p>
<p>A simple example is when we only have 2 threads. We use two binary semaphores:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>Semaphore[] done = {new Semaphore(0), new Semaphore(0)};</span></span>
<span class="line"><span></span></span></code></pre>
<p>$t_0$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Indicate that t0 is done</span></span>
<span class="line"><span>done[t0].up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Wait until t1 is done</span></span>
<span class="line"><span>done[t1].down();</span></span>
<span class="line"><span></span></span></code></pre>
<p>$t_1$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Indicate that t1 is done</span></span>
<span class="line"><span>done[t1].up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Wait until t0 is done</span></span>
<span class="line"><span>done[t0].down();</span></span>
<span class="line"><span></span></span></code></pre>
<p>We could also do:</p>
<p>$t_0$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Wait until t1 is done</span></span>
<span class="line"><span>done[t1].down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Indicate that t0 is done</span></span>
<span class="line"><span>done[t0].up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre>
<p>$t_1$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Indicate that t1 is done</span></span>
<span class="line"><span>done[t1].up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Wait until t0 is done</span></span>
<span class="line"><span>done[t0].down();</span></span>
<span class="line"><span></span></span></code></pre>
<p>This works if $t_0$ does <code>down</code> before <code>up</code>, or symmetrically, if $t_1$ does the same.</p>
<p>This is however, less efficient, since, the last thread to reach the barrier has to yield for the other.</p>
<p>One thing that might not be obvious but, if we do:</p>
<p>$t_0$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Wait until t1 is done</span></span>
<span class="line"><span>done[t1].down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Indicate that t0 is done</span></span>
<span class="line"><span>done[t0].up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span></code></pre>
<p>$t_1$â€˜s code:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Wait until t0 is done</span></span>
<span class="line"><span>done[t0].down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>// Indicate that t1 is done</span></span>
<span class="line"><span>done[t1].up();</span></span>
<span class="line"><span></span></span></code></pre>
<p>We will have a deadlock if $t_0$ and $t_1$ both perform <code>down</code> before any <code>up</code> calls.</p>
<p>Letâ€™s try to create a reusable, general barrier</p>
<h3 id="reusable-barriers">Reusable Barriers</h3>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>interface Barrier {</span></span>
<span class="line"><span>    // Block until expect() threads have reached barrier</span></span>
<span class="line"><span>    void wait();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Number of threads expected at the barrier</span></span>
<span class="line"><span>    int expect();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Letâ€™s try a naive approach and see what happens:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class NonBarrier1 implements Barrier {</span></span>
<span class="line"><span>    int nDone = 0; // number of done threads</span></span>
<span class="line"><span>    Semaphore open = new Semaphore(0);</span></span>
<span class="line"><span>    final int n;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // initialize barrier for `n' threads</span></span>
<span class="line"><span>    NonBarrier1(int n) {</span></span>
<span class="line"><span>        this.n = n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // number of threads expected at the barrier</span></span>
<span class="line"><span>    int expect() {</span></span>
<span class="line"><span>        return n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void wait() {</span></span>
<span class="line"><span>        synchronized(this) {</span></span>
<span class="line"><span>            nDone += 1;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (nDone == n) {</span></span>
<span class="line"><span>            // I'm the last arrived: All can go!</span></span>
<span class="line"><span>            open.up();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Proceed when possible</span></span>
<span class="line"><span>        open.down()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Let the next one go</span></span>
<span class="line"><span>        open.up()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        synchronized(this) {</span></span>
<span class="line"><span>            nDone -= 1;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (nDone == 0) {</span></span>
<span class="line"><span>            // I'm the last through: Close barrier!</span></span>
<span class="line"><span>            open.down();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This solution doesnâ€™t work perfectly though. If the n threads wait at <code>if(nDone == 0)</code>
then more than one thread may try to close the barrier, which results in a deadlock.</p>
<p>The same goes for opening the barrier, if more than one thread tries to open the barrier,
itâ€™s possible that some threads may be executing <code>wait</code> again before the barrier is closed again.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class NonBarrier2 implements Barrier {</span></span>
<span class="line"><span>    int nDone = 0; // number of done threads</span></span>
<span class="line"><span>    Semaphore open = new Semaphore(0);</span></span>
<span class="line"><span>    final int n;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // initialize barrier for `n' threads</span></span>
<span class="line"><span>    NonBarrier1(int n) {</span></span>
<span class="line"><span>        this.n = n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // number of threads expected at the barrier</span></span>
<span class="line"><span>    int expect() {</span></span>
<span class="line"><span>        return n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void wait() {</span></span>
<span class="line"><span>        synchronized(this) {</span></span>
<span class="line"><span>            nDone += 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>            if (nDone == n) {</span></span>
<span class="line"><span>                // I'm the last arrived: All can go!</span></span>
<span class="line"><span>                open.up();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Proceed when possible</span></span>
<span class="line"><span>        open.down()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Let the next one go</span></span>
<span class="line"><span>        open.up()</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        synchronized(this) {</span></span>
<span class="line"><span>            nDone -= 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>           if (nDone == 0) {</span></span>
<span class="line"><span>                // I'm the last through: Close barrier!</span></span>
<span class="line"><span>                open.down();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>Now this solution fixes the past issues listed. This solution has a problem of its own though.</p>
<p>If we have a thread which is incredibly fast, it may now get ahead of the other (slower) threads.
Even if we use strong semaphores, we cannot prevent this. This is because this happens due to the
last thread leaves the gate open.</p>
<p>To fix this we use a kind of two gate mechanic.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class SemaphoreBarrier implements Barrier {</span></span>
<span class="line"><span>    int nDone = 0; // number of done threads</span></span>
<span class="line"><span>    Semaphore gate1 = new Semaphore(0);// first gate</span></span>
<span class="line"><span>    Semaphore gate2 = new Semaphore(1);// second gate</span></span>
<span class="line"><span>    final int n;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // initialize barrier for `n' threads</span></span>
<span class="line"><span>    SemaphoreBarrier(int n) {</span></span>
<span class="line"><span>        this.n = n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>    // number of threads expected at the barrier</span></span>
<span class="line"><span>    int expect() {</span></span>
<span class="line"><span>        return n;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public void wait() {</span></span>
<span class="line"><span>    approach(); leave();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void approach() {</span></span>
<span class="line"><span>    synchronized (this) {</span></span>
<span class="line"><span>        nDone += 1; // arrived</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (nDone == n) { // if last in:</span></span>
<span class="line"><span>            gate1.up(); // open gate1</span></span>
<span class="line"><span>            gate2.down(); // close gate2</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    gate1.down(); // pass gate1</span></span>
<span class="line"><span>    gate1.up(); // let next pass</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>void leave() {</span></span>
<span class="line"><span>    synchronized (this) {</span></span>
<span class="line"><span>        nDone -= 1; // going out</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (nDone == 0) { // if last out:</span></span>
<span class="line"><span>            gate2.up(); // open gate2</span></span>
<span class="line"><span>            gate1.down(); // close gate1</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    gate2.down(); // pass gate2</span></span>
<span class="line"><span>    gate2.up(); // let next pass</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This solution is what a good, reusable barrier should look like.</p>
<h3 id="readers-writers">Readers-Writers</h3>
<p>A problem which we can encounter every day, say we have a board displaying data.
Readers and writers need to access this board to, read and write.</p>
<p>We need a board which does:</p>
<ul>
<li>
<p>Multiple readers can operate concurrently</p>
</li>
<li>
<p>Each writer has exclusive access</p>
<ul>
<li>Meaning that we have the invariant: # of writers = 0 OR (# of writers == 1 AND # of Readers == 0)</li>
</ul>
</li>
</ul>
<p>A naive approach would be:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class SyncBoard&#x3C;T> implements Board&#x3C;T> {</span></span>
<span class="line"><span>    int nReaders = 0;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // For exclusive access to nReaders</span></span>
<span class="line"><span>    Lock lock = new Lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // 1 if and only if no active threads</span></span>
<span class="line"><span>    Semaphore empty = new Semaphore(1);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    T message;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public T read() {</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Lock to update nReaders</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if(nReaders == 0) {</span></span>
<span class="line"><span>            // If first reader, set not empty</span></span>
<span class="line"><span>            empty.down();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Update nReaders</span></span>
<span class="line"><span>        nReaders += 1</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Release nReaders</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Read (critical section)</span></span>
<span class="line"><span>        T msg = message;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Aquire nReaders</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        nReaders -= 1;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if(nReaders == 0) {</span></span>
<span class="line"><span>            // If # of readers empty, set empty</span></span>
<span class="line"><span>            empty.up();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Releaes nReaders</span></span>
<span class="line"><span>        lock.unlock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return msg;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void write(T msg) {</span></span>
<span class="line"><span>        // Get exclusive access</span></span>
<span class="line"><span>        empty.down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        message = msg;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Release board</span></span>
<span class="line"><span>        empty.up();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span></span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This solution ensures almost everything we want, the only thing missing is that writers can now starve.</p>
<p>If there is always one reader active, writers will not be able to access the board at all.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-color-background);color:var(--astro-code-color-text); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class FairBoard&#x3C;T> extends SyncBoard&#x3C;T> {</span></span>
<span class="line"><span>    Semaphore baton = new Semaphore(1, true);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public T read() {</span></span>
<span class="line"><span>        // Wait until you get baton</span></span>
<span class="line"><span>        baton.down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Release a waiting thread</span></span>
<span class="line"><span>        baton.up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Read as in SyncBoard</span></span>
<span class="line"><span>        return super.read();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public void write(T msg) {</span></span>
<span class="line"><span>        // Wait until you get baton</span></span>
<span class="line"><span>        baton.down();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Write as in SyncBoard</span></span>
<span class="line"><span>        super.write(msg);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Release</span></span>
<span class="line"><span>        baton.up();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span></code></pre>
<p>This will ensure that readers and writers have the same priority.</p>
<h3 id="summary">Summary</h3>
<p>A looong part, but as we can see, all solution uses locks and semaphores.
When writing solutions to concurrent programs, we will always need to use these.
To lock and gain exclusive access.</p> <div class="mt-24"> <div class="grid grid-cols-2 gap-1.5 sm:gap-3"> <a href="/chalmers/tda384/tda384_3" class="group relative flex flex-nowrap rounded-lg border border-black/15 px-4 py-3 pl-10 no-underline transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-5 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-3 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="flex items-center text-sm"> Part 3 - Models of concurrency </div> </a> <a href="/chalmers/tda384/tda384_5" class="group relative flex flex-grow flex-row-reverse flex-nowrap rounded-lg border border-black/15 px-4 py-4 pr-10 no-underline transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute right-2 top-1/2 size-5 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-3 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 19 12 12 19" class="-translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="flex items-center text-sm"> Part 5 - Monitors </div> </a> </div> </div> <div class="mt-24"> <div class="giscus"></div> <script data-astro-rerun src="https://giscus.app/client.js" data-repo="rezaarezvan/rezvan.xyz" data-repo-id="R_kgDOHvQr3w" data-category="General" data-category-id="DIC_kwDOHvQr384CiWVC" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="en" data-loading="lazy" crossorigin="anonymous" async></script> </div> </article> </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-3"> <div class="relative"> <div class="absolute -top-12 right-0"> <button id="back-to-top" class="group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-8 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 rotate-90 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm">Back to top</div> </button> </div> </div> <div class="flex items-center justify-between"> <div>&copy; 2024 â€¢ rezvan.xyz </div> <div class="flex flex-wrap items-center gap-1.5"> <button id="light-theme-button" aria-label="Light theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect> <line x1="8" y1="21" x2="16" y2="21"></line> <line x1="12" y1="17" x2="12" y2="21"></line> </svg> </button> </div> </div> </div> </footer> <aside data-pagefind-ignore> <div id="backdrop" class="bg-[rgba(0, 0, 0, 0.5] invisible fixed left-0 top-0 z-50 flex h-screen w-full justify-center p-6 backdrop-blur-sm" data-astro-transition-persist="astro-3snakcvo-2"> <div id="pagefind-container" class="m-0 flex h-fit max-h-[80%] w-full max-w-screen-sm flex-col overflow-auto rounded border border-black/15 bg-neutral-100 p-2 px-4 py-3 shadow-lg dark:border-white/20 dark:bg-neutral-900"> <div id="search" class="pagefind-ui pagefind-init" data-pagefind-ui data-bundle-path="/pagefind/" data-ui-options="{&#34;showImages&#34;:false,&#34;excerptLength&#34;:15,&#34;resetStyles&#34;:false}"></div>  <div class="mr-2 pb-1 pt-4 text-right text-xs dark:prose-invert">
Press <span class="prose text-xs dark:prose-invert"><kbd class="">Esc</kbd></span> or click anywhere to close
</div> </div> </div> </aside> <script>
  const magnifyingGlass = document.getElementById("magnifying-glass");
  const backdrop = document.getElementById("backdrop");

  function openPagefind() {
    const searchDiv = document.getElementById("search");
    const search = searchDiv.querySelector("input");
    setTimeout(() => {
      search.focus();
    }, 0);
    backdrop?.classList.remove("invisible");
    backdrop?.classList.add("visible");
  }

  function closePagefind() {
    const search = document.getElementById("search");
    search.value = "";
    backdrop?.classList.remove("visible");
    backdrop?.classList.add("invisible");
  }

  // open pagefind
  magnifyingGlass?.addEventListener("click", () => {
    openPagefind();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "/") {
      e.preventDefault();
      openPagefind();
    } else if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      openPagefind();
    }
  });

  // close pagefind
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" || e.keyCode === 27) {
      closePagefind();
    }
  });

  // close pagefind when searched result(link) clicked
  document.addEventListener("click", (event) => {
    if (event.target.classList.contains("pagefind-ui__result-link")) {
      closePagefind();
    }
  });

  backdrop?.addEventListener("click", (event) => {
    if (!event.target.closest("#pagefind-container")) {
      closePagefind();
    }
  });

  // prevent form submission
  const form = document.getElementById("form");
  form?.addEventListener("submit", (event) => {
    event.preventDefault();
  });
</script>  </body></html>