<!DOCTYPE html><html lang="en"> <head><!-- Global Metadata --><meta charset="utf-8"><meta name="viewport" content="width=device-width,initial-scale=1"><link rel="icon" type="image/icon" href="/favicon.ico"><meta name="generator" content="Astro v5.0.5"><!-- Canonical URL --><link rel="canonical" href="https://rezvan.xyz/chalmers/tda384/tda384_10/"><!-- Primary Meta Tags --><title>Part 10 - Parallel linked lists | concurrent programming | rezarezvan.com</title><meta name="title" content="Part 10 - Parallel linked lists | concurrent programming | rezarezvan.com"><meta name="description"><!-- Open Graph / Facebook --><meta property="og:type" content="website"><meta property="og:url" content="https://rezvan.xyz/chalmers/tda384/tda384_10/"><meta property="og:title" content="Part 10 - Parallel linked lists | concurrent programming | rezarezvan.com"><meta property="og:description"><meta property="og:image" content="https://rezvan.xyz/favicon.ico"><!-- Twitter --><meta property="twitter:card" content="summary_large_image"><meta property="twitter:url" content="https://rezvan.xyz/chalmers/tda384/tda384_10/"><meta property="twitter:title" content="Part 10 - Parallel linked lists | concurrent programming | rezarezvan.com"><meta property="twitter:description"><meta property="twitter:image" content="https://rezvan.xyz/favicon.ico"><!-- PageFind --><link href="/pagefind/pagefind-ui.css" rel="stylesheet"><script src="/pagefind/pagefind-ui.js"></script><!-- KaTeX support --><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.css"><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/katex.min.js"></script><script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.11/dist/contrib/auto-render.min.js" onload="renderMathInElement(document.body);"></script><!-- inline KaTeX --><script>
    function renderKaTeX() {
        if (typeof renderMathInElement !== "undefined") {
            renderMathInElement(document.body, {
                delimiters: [
                    { left: "$$", right: "$$", display: true },
                    { left: "$", right: "$", display: false },
                ],
            });
        }
    }

    document.addEventListener("DOMContentLoaded", renderKaTeX);
    document.addEventListener("astro:after-swap", renderKaTeX);
</script><meta name="astro-view-transitions-enabled" content="true"><meta name="astro-view-transitions-fallback" content="animate"><script type="module" src="/_astro/ClientRouter.astro_astro_type_script_index_0_lang.BScVxmeO.js"></script><script>
    function init() {
        preloadTheme();
        onScroll();
        animate();
        updateThemeButtons();
        addCopyCodeButtons();
        setGiscusTheme();

        const backToTop = document.getElementById("back-to-top");
        backToTop?.addEventListener("click", (event) => scrollToTop(event));

        const backToPrev = document.getElementById("back-to-prev");
        backToPrev?.addEventListener("click", () => window.history.back());

        const lightThemeButton = document.getElementById("light-theme-button");
        lightThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "light");
            toggleTheme(false);
            updateThemeButtons();
        });

        const darkThemeButton = document.getElementById("dark-theme-button");
        darkThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "dark");
            toggleTheme(true);
            updateThemeButtons();
        });

        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );
        systemThemeButton?.addEventListener("click", () => {
            localStorage.setItem("theme", "system");
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
            updateThemeButtons();
        });

        window
            .matchMedia("(prefers-color-scheme: dark)")
            .addEventListener("change", (event) => {
                if (localStorage.theme === "system") {
                    toggleTheme(event.matches);
                }
            });

        document.addEventListener("scroll", onScroll);
    }

    function updateThemeButtons() {
        const theme = localStorage.getItem("theme");
        const lightThemeButton = document.getElementById("light-theme-button");
        const darkThemeButton = document.getElementById("dark-theme-button");
        const systemThemeButton = document.getElementById(
            "system-theme-button",
        );

        function removeActiveButtonTheme(button) {
            button?.classList.remove("bg-black/5");
            button?.classList.remove("dark:bg-white/5");
        }

        function addActiveButtonTheme(button) {
            button?.classList.add("bg-black/5");
            button?.classList.add("dark:bg-white/5");
        }

        removeActiveButtonTheme(lightThemeButton);
        removeActiveButtonTheme(darkThemeButton);
        removeActiveButtonTheme(systemThemeButton);

        if (theme === "light") {
            addActiveButtonTheme(lightThemeButton);
        } else if (theme === "dark") {
            addActiveButtonTheme(darkThemeButton);
        } else {
            addActiveButtonTheme(systemThemeButton);
        }
    }

    function animate() {
        const animateElements = document.querySelectorAll(".animate");

        animateElements.forEach((element, index) => {
            setTimeout(() => {
                element.classList.add("show");
            }, index * 100);
        });
    }

    function onScroll() {
        if (window.scrollY > 0) {
            document.documentElement.classList.add("scrolled");
        } else {
            document.documentElement.classList.remove("scrolled");
        }
    }

    function scrollToTop(event) {
        event.preventDefault();
        window.scrollTo({
            top: 0,
            behavior: "smooth",
        });
    }

    function toggleTheme(dark) {
        const css = document.createElement("style");

        css.appendChild(
            document.createTextNode(
                `* {
             -webkit-transition: none !important;
             -moz-transition: none !important;
             -o-transition: none !important;
             -ms-transition: none !important;
             transition: none !important;
          }
        `,
            ),
        );

        document.head.appendChild(css);

        if (dark) {
            document.documentElement.classList.add("dark");
        } else {
            document.documentElement.classList.remove("dark");
        }

        window.getComputedStyle(css).opacity;
        document.head.removeChild(css);

        setGiscusTheme();
    }

    function preloadTheme() {
        const userTheme = localStorage.theme;

        if (userTheme === "light" || userTheme === "dark") {
            toggleTheme(userTheme === "dark");
        } else {
            toggleTheme(
                window.matchMedia("(prefers-color-scheme: dark)").matches,
            );
        }
    }

    function addCopyCodeButtons() {
        let copyButtonLabel = "ðŸ“‹";
        let codeBlocks = Array.from(document.querySelectorAll("pre"));

        async function copyCode(codeBlock, copyButton) {
            const codeText = codeBlock.innerText;
            const buttonText = copyButton.innerText;
            const textToCopy = codeText.replace(buttonText, "");

            await navigator.clipboard.writeText(textToCopy);
            copyButton.innerText = "âœ…";

            setTimeout(() => {
                copyButton.innerText = copyButtonLabel;
            }, 2000);
        }

        for (let codeBlock of codeBlocks) {
            const wrapper = document.createElement("div");
            wrapper.style.position = "relative";

            const copyButton = document.createElement("button");
            copyButton.innerText = copyButtonLabel;
            copyButton.classList = "copy-code";

            codeBlock.setAttribute("tabindex", "0");
            codeBlock.appendChild(copyButton);

            codeBlock.parentNode.insertBefore(wrapper, codeBlock);
            wrapper.appendChild(codeBlock);

            copyButton?.addEventListener("click", async () => {
                await copyCode(codeBlock, copyButton);
            });
        }
    }

    const setGiscusTheme = () => {
        const giscus = document.querySelector(".giscus-frame");

        const isDark = document.documentElement.classList.contains("dark");

        if (giscus) {
            const url = new URL(giscus.src);
            url.searchParams.set("theme", isDark ? "dark" : "light");
            giscus.src = url.toString();
        }
    };

    document.addEventListener("DOMContentLoaded", () => init());
    document.addEventListener("astro:after-swap", () => init());
    preloadTheme();
</script><link rel="stylesheet" href="/_astro/_subject_.BiiDyz4N.css">
<style>summary[data-astro-cid-xvrfupwn]{cursor:pointer;border-top-left-radius:.5rem;border-top-right-radius:.5rem;padding:.375rem .75rem;font-weight:500;transition-property:color,background-color,border-color,text-decoration-color,fill,stroke;transition-timing-function:cubic-bezier(.4,0,.2,1);transition-duration:.15s}summary[data-astro-cid-xvrfupwn]:hover{background-color:#0000000d}summary[data-astro-cid-xvrfupwn]:hover:is(.dark *){background-color:#ffffff0d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]{background-color:#0000000d}details[data-astro-cid-xvrfupwn][open] summary[data-astro-cid-xvrfupwn]:is(.dark *){background-color:#ffffff0d}
[data-astro-image]{width:100%;height:auto;-o-object-fit:var(--fit);object-fit:var(--fit);-o-object-position:var(--pos);object-position:var(--pos);aspect-ratio:var(--w) / var(--h)}[data-astro-image=responsive]{max-width:calc(var(--w) * 1px);max-height:calc(var(--h) * 1px)}[data-astro-image=fixed]{width:calc(var(--w) * 1px);height:calc(var(--h) * 1px)}
</style></head> <body> <header data-astro-transition-persist="astro-l7r54iwe-1"> <div class="mx-auto max-w-screen-sm px-3"> <div class="flex flex-wrap justify-between gap-y-2"> <a href="/" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out">  <div class="font-semibold"> rezarezvan.com </div>  </a> <nav class="flex items-center gap-1 text-sm"> <a href="/posts" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> posts </a> <span> / </span> <a href="/chalmers" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> chalmers </a> <span> / </span> <a href="/cityu" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> cityu </a> <span> / </span> <a href="/pdf/cv/cv.pdf" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> cv </a> <span> / </span> <button id="magnifying-glass" aria-label="Search" class="flex items-center rounded border border-black/15 bg-neutral-100 px-2 py-1 text-xs transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:bg-neutral-900 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg height="16" stroke-linejoin="round" viewBox="0 0 16 16" width="16" style="color: currentcolor;"><path fill-rule="evenodd" clip-rule="evenodd" d="M3.5 7C3.5 5.067 5.067 3.5 7 3.5C8.933 3.5 10.5 5.067 10.5 7C10.5 7.88461 10.1718 8.69256 9.63058 9.30876L9.30876 9.63058C8.69256 10.1718 7.88461 10.5 7 10.5C5.067 10.5 3.5 8.933 3.5 7ZM9.96544 11.0261C9.13578 11.6382 8.11014 12 7 12C4.23858 12 2 9.76142 2 7C2 4.23858 4.23858 2 7 2C9.76142 2 12 4.23858 12 7C12 8.11014 11.6382 9.13578 11.0261 9.96544L14.0303 12.9697L14.5607 13.5L13.5 14.5607L12.9697 14.0303L9.96544 11.0261Z" fill="currentColor"></path></svg>
&nbsp;Search
</button> </nav> </div> </div> </header> <main>  <div class="mx-auto max-w-screen-sm px-3"> <div class="animate"> <a href="/chalmers/tda384" class="not-prose group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-7 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm"> Back to concurrent programming </div> </a> </div> <div class="my-10 space-y-1"> <div class="animate flex items-center gap-1.5"> <div class="font-base text-sm"> TDA384 </div>
&bull;
<div class="font-base text-sm"> <time datetime="2023-02-19T00:00:00.000Z"> February 19, 2023 </time> </div> 
&bull;
<div class="font-base text-sm">
Last modified:  <time datetime="2024-09-02T11:21:25.000Z"> September 02, 2024 </time> </div> 
&bull;
<div class="font-base text-sm"> 11 min read </div> </div> <h1 class="animate text-3xl font-semibold text-black dark:text-white"> Part 10 - Parallel linked lists </h1> </div> <details open class="animate rounded-lg border border-black/15 dark:border-white/20" data-astro-cid-xvrfupwn> <summary data-astro-cid-xvrfupwn>Table of Contents</summary> <nav class="" data-astro-cid-xvrfupwn> <ul class="py-3" data-astro-cid-xvrfupwn> <li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#the-trouble-with-locks" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> The trouble with locks </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#coarse-grained-locking" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Coarse grained locking </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#fine-grained-locking" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Fine-grained locking </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#optimistic-locking" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Optimistic locking </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#lazy-node-removal" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Lazy node removal </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#lock-free-access" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> Lock free access </a>  </li><li class="list-inside list-disc px-6 py-1.5 text-sm"> <a href="#when-to-lock-and-not" target="_self" class="inline-block decoration-black/30 dark:decoration-white/30 hover:decoration-black/50 focus-visible:decoration-black/50 dark:hover:decoration-white/50 dark:focus-visible:decoration-white/50 text-current hover:text-black focus-visible:text-black dark:hover:text-white dark:focus-visible:text-white transition-colors duration-300 ease-in-out underline underline-offset-[3px]"> When to lock and not </a>  </li> </ul> </nav> </details> <article class="animate"> <p>In this part weâ€™ll cover the <em>synchronization challenges</em> that arise when designing (correct) and efficient parallelizations.</p>
<p>But letâ€™s first see the burdens with locks</p>
<h3 id="the-trouble-with-locks">The trouble with locks</h3>
<p>Standard techniques for concurrent programming are ultimately based on locks.</p>
<p>Programming with locks has several drawbacks:</p>
<ul>
<li>
<p>Performance overhead.</p>
</li>
<li>
<p>Lock granularity is hard to choose:</p>
<ul>
<li>
<p>Not enough locking: race conditions.</p>
</li>
<li>
<p>Too much locking: not enough parallelism.</p>
</li>
</ul>
</li>
<li>
<p>Risk of deadlock and starvation.</p>
</li>
<li>
<p>Lock-based implementations do not compose (easily).</p>
</li>
<li>
<p>Lock-based programs are hard to maintain and modify.</p>
</li>
</ul>
<p>Message-passing programming is higher-level, but it also inevitably incurs on
synchronization costs â€“ of magnitude comparable to those associated with locks.</p>
<p>A good rule of thumb is:</p>
<ul>
<li>
<p>Lock-based programming is <em>pessimistic</em>: be prepared for the worst possible conditions:</p>
<ul>
<li>If things can go wrong, they will.</li>
</ul>
</li>
<li>
<p>Lock-free programming is <em>optimistic</em>: do what you have to do without worrying about race conditions:</p>
<ul>
<li>If things go wrong, just try again!</li>
</ul>
</li>
</ul>
<p>Ultimately, what Lock-free programming relies on is:</p>
<ul>
<li>
<p>Using stronger primitives for atomic access.</p>
</li>
<li>
<p>Building optimistic algorithms using those primitives.</p>
</li>
</ul>
<p>For example, remember the <code>compare-and-set</code> and <code>test-and-set</code> methods we have encountered.</p>
<p>Even if these are not â€˜freeâ€™, these operations also take time and performance.</p>
<p>There are two different classes of lock-free algorithms:</p>
<ul>
<li>
<p>Lock-free: guarantee <em>system-wide</em> progress: infinitely often, some process makes progress.</p>
</li>
<li>
<p>Wait-free: guarantee <em>per-process</em> progress: every process eventually makes progress.</p>
</li>
</ul>
<p>Wait-free is stronger than lock-free:</p>
<ul>
<li>Lock-free algorithms are free from deadlock.</li>
<li>Wait-free algorithms are free from deadlock <em>and starvation</em>.</li>
</ul>
<p>Letâ€™s see how we can parallelize linked lists!</p>
<p>But before that, letâ€™s quickly just have our linked list defined:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class SequentialNode&#x3C;T> implements Node&#x3C;T> {</span></span>
<span class="line"><span>    // Value stored in node</span></span>
<span class="line"><span>    private T item;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Hash code of item</span></span>
<span class="line"><span>    private int key;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // Next node in chain</span></span>
<span class="line"><span>    private Node&#x3C;T> next;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    T item() { return item; }</span></span>
<span class="line"><span>    int key() { return key; }</span></span>
<span class="line"><span>    Node&#x3C;T> next() { return next; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    void setItem(T item) { this.item = item; }</span></span>
<span class="line"><span>    void setKey(int key) { this.key = key; }</span></span>
<span class="line"><span>    void setNext(Node&#x3C;T> next) { this.next = next; }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        curr = start;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        do {</span></span>
<span class="line"><span>            pred = curr; curr = curr.next();</span></span>
<span class="line"><span>        } while (curr.key() &#x3C; key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return (pred,curr);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean has(T item) {</span></span>
<span class="line"><span>        int key = item.key();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Find position of key from head:</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, key);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        return curr.key() == key;</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean add(T item) {</span></span>
<span class="line"><span>        // New node to be added</span></span>
<span class="line"><span>        Node&#x3C;T> node = new Node&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // curr.key >= item.key()</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (curr.key() == item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            node.setNext(curr);</span></span>
<span class="line"><span>            pred.setNext(node);</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean remove(T item) {</span></span>
<span class="line"><span>        // curr.key() >= item.key()</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (curr.key() > item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            pred.setNext(curr.next());</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<h3 id="coarse-grained-locking">Coarse grained locking</h3>
<p>The simple idea is to lock every method.</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class CoarseSet&#x3C;T> extends SequentialSet&#x3C;T> {</span></span>
<span class="line"><span>    // Lock controlling access to the whole set</span></span>
<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean add(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute â€˜addâ€™ while locking</span></span>
<span class="line"><span>            return super.add(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean remove(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute â€˜removeâ€™ while locking</span></span>
<span class="line"><span>            return super.remove(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    public boolean has(T item) {</span></span>
<span class="line"><span>        lock.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            // Execute â€˜hasâ€™ while locking</span></span>
<span class="line"><span>            return super.has(item);</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            // Done: release lock</span></span>
<span class="line"><span>            lock.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>Now this is a <strong>very</strong> naive approach - but letâ€™s list the pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Obviously correct â€“ avoids race conditions and deadlocks.</p>
</li>
<li>
<p>If the lock is fair, so is access to the list.</p>
</li>
<li>
<p>If contention is low (not many threads accessing the set concurrently), <code>CoarseSet</code> is quite efficient.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>Access to the list is sequential â€“ missing opportunities for parallelization.</p>
</li>
<li>
<p>If contention is high (many threads accessing the set concurrently), <code>CoarseSet</code> is quite slow.</p>
</li>
</ul>
</li>
</ul>
<p>Now letâ€™s look at <code>CoarseSet</code> predecessor</p>
<h3 id="fine-grained-locking">Fine-grained locking</h3>
<p>The idea here is, instead of locking the whole list when doing operations, we just lock that specific node(s).</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class FineSet&#x3C;T> extends SequentialSet&#x3C;T> {</span></span>
<span class="line"><span>    public FineSet() {</span></span>
<span class="line"><span>        // Smallest key</span></span>
<span class="line"><span>        head = new LockableNode&#x3C;>(Integer.MIN _ VALUE);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Largest key</span></span>
<span class="line"><span>        tail = new LockableNode&#x3C;>(Integer.MAX _ VALUE);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        head.setNext(tail);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>Since each node is lockable:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class LockableNode&#x3C;T> extends SequentialNode&#x3C;T> {</span></span>
<span class="line"><span>    private Lock lock = new ReentrantLock();</span></span>
<span class="line"><span>        void lock() { lock.lock(); }</span></span>
<span class="line"><span>        void unlock() { lock.unlock(); }</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>Now letâ€™s see the implementations of each operation:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Find while locking pred and curr, return locked position</span></span>
<span class="line"><span>protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr;</span></span>
<span class="line"><span>    pred = start; curr = start.next();</span></span>
<span class="line"><span>    pred.lock(); curr.lock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    while (curr.key &#x3C; key) {</span></span>
<span class="line"><span>        // Unlock pred node</span></span>
<span class="line"><span>        pred.unlock();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Move to next node</span></span>
<span class="line"><span>        pred = curr; curr = curr.next();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        // Lock next node</span></span>
<span class="line"><span>        curr.lock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return (pred, curr);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = new LockableNode&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Add node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Remove node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    try {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        // Check node as in SequentialSet, while locking</span></span>
<span class="line"><span>    } finally {</span></span>
<span class="line"><span>        pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>As we see, itâ€™s all about the <code>find</code> operation.</p>
<p>Pros and cons:</p>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>If locks are fair, so is access to the list, because threads proceed along the list one
after the other without changing order.</p>
</li>
<li>
<p>Threads operating on disjoint portions of the list may be able to operate in parallel.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>It is still possible that one thread prevents another thread from operating in parallel on
a disjoint portion of the list â€“ for example, if one thread wants to access the end of the
list but, another thread blocks it while locking the beginning of the list.</p>
</li>
<li>
<p>The hand-over-hand locking protocol may be quite slow, as it involves a significant
number of lock operations.</p>
</li>
</ul>
</li>
</ul>
<h3 id="optimistic-locking">Optimistic locking</h3>
<p>Letâ€™s try to implement <code>find</code> without using locks. The idea is to <em>validate</em>
a position <em>after finding it</em>, there is some implementation detail about the nodes,
for example we need to make sure we have the <code>volatile</code> keyword for the <code>next</code> attribute in a node.</p>
<p>But that is besides the point, letâ€™s take an overview of how the operations should work:</p>
<ol>
<li>
<p>Find the itemâ€™s position inside the list without locking.</p>
</li>
<li>
<p>Lock the positionâ€™s nodes <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>Validate the position while the nodes are locked:</p>
<ul>
<li>
<p>3.1 If the position is <strong>valid</strong>, perform the operation while the nodes are locked, then
release locks.</p>
</li>
<li>
<p>3.2 If the position is <strong>invalid</strong>, release locks and repeat the operation from <strong>scratch</strong>.</p>
</li>
</ul>
</li>
</ol>
<p>This approach is optimistic because it works well when validation is often successful
(so we donâ€™t have to repeat operations).</p>
<p>Now letâ€™s implement these operations:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>// Find as in SequentialSet find</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = new ReadWriteNode&#x3C;>(item);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                // Physically add node</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                // Physically remove node</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // If not valid: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                return curr.key() == item.key();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // If not valid: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected boolean valid(Node&#x3C;T> pred, Node&#x3C;T> curr) {</span></span>
<span class="line"><span>    Node&#x3C;T> node = head;</span></span>
<span class="line"><span>    while (node.key() &#x3C;= pred.key()) {</span></span>
<span class="line"><span>        if (node == pred) {</span></span>
<span class="line"><span>            return pred.next() == curr;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        node = node.next();</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return false;</span></span>
<span class="line"><span>}</span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Threads operating on disjoint portions of the list can operate in parallel.</p>
</li>
<li>
<p>When validation often succeeds, there is much less locking involved than in <code>FineSet</code>.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p><code>OptimisticSet</code> is not starvation free; A thread, $t$, may fail validation forever
if other threads keep removing and adding <code>pred</code> / <code>curr</code> between when $t$ performs
<code>find</code> and when it locks <code>pred</code> and <code>curr</code>.</p>
</li>
<li>
<p>If traversing the list twice without locking is not significantly faster than traversing it
once with locking, <code>OptimisticSet</code> does not have a clear advantage over <code>FineSet</code>.</p>
</li>
</ul>
</li>
</ul>
<h3 id="lazy-node-removal">Lazy node removal</h3>
<p>This is the idea that, we need a way to atomically share the information that a node is being removed, but
without locking.</p>
<p>To this end, each node includes a flag <code>valid</code> with setters and getters.</p>
<p>Which means:</p>
<ul>
<li>
<p>Validation only needs to check the mark <code>valid</code>.</p>
</li>
<li>
<p>Operation <code>remove</code> marks a node invalid before removing it.</p>
</li>
<li>
<p>Operation <code>has</code> is lock-free.</p>
</li>
<li>
<p>Operation <code>add</code> works as in <code>OptimisticSet</code>.</p>
</li>
</ul>
<p>Letâ€™s start with the implementation:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public class LazySet&#x3C;T> extends OptimisticSet&#x3C;T> {</span></span>
<span class="line"><span>    public LazySet() {</span></span>
<span class="line"><span>        head = new ValidatedNode&#x3C;>(Integer.MIN_VALUE);</span></span>
<span class="line"><span>        tail = new ValidatedNode&#x3C;>(Integer.MAX_VALUE);</span></span>
<span class="line"><span>        head.setNext(tail);</span></span>
<span class="line"><span>    }</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected boolean valid(Node&#x3C;T> pred, Node&#x3C;T> curr) {</span></span>
<span class="line"><span>    return pred.valid() &#x26;&#x26; curr.valid() &#x26;&#x26; pred.next() == curr;</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>    return curr.valid() &#x26;&#x26; curr.key() == item.key();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        pred.lock(); curr.lock();</span></span>
<span class="line"><span>        try {</span></span>
<span class="line"><span>            if (valid(pred, curr)) {</span></span>
<span class="line"><span>                if (curr.key() != item.key()) {</span></span>
<span class="line"><span>                    return false;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>                else {</span></span>
<span class="line"><span>                    curr.setInvalid();</span></span>
<span class="line"><span>                    pred.setNext(curr.next());</span></span>
<span class="line"><span>                    return true;</span></span>
<span class="line"><span>                }</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        } finally {</span></span>
<span class="line"><span>            pred.unlock(); curr.unlock();</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>Validation is constant time.</p>
</li>
<li>
<p>Membership checking does not require any locking â€“ itâ€™s even wait-free (it traverses
the list once without locking).</p>
</li>
<li>
<p>Physical removal of logically removed nodes could be batched and performed when
convenient â€“ thus reducing the number of times the physical chain of nodes is
changed, in turn reducing the expensive propagation of information between threads.</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>Operations add and remove still require locking (as in OptimisticSet), which may
reduce the amount of parallelism.</li>
</ul>
</li>
</ul>
<p>Now lastly, letâ€™s solve this using <em>no locks</em>!</p>
<h3 id="lock-free-access">Lock free access</h3>
<p>If weâ€™re not using locks we need to use stronger synchronization primitives than locks.</p>
<p>Therefore weâ€™ll use the <code>compare-and-set</code> operation.</p>
<p>Letâ€™s try to implement <code>remove</code> using this:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    boolean done;</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() >= item.key()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        else {</span></span>
<span class="line"><span>            done = pred.next().compareAndSet(pred.next(), curr.next());</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    } while (!done);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    return true;</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>This is however a naive approach and will not work, unfortunately. If two threads call <code>remove</code> at the same time,
it is possible that only one of them are successful.</p>
<p>We will need to borrow the idea of marking and updating nodes from <code>LazySet</code>.</p>
<p>Which means:</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>class AtomicMarkableReference&#x3C;V> {</span></span>
<span class="line"><span>    // Current reference and mark</span></span>
<span class="line"><span>    V, boolean get();</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // if reference == expectRef set mark to newMark and return true</span></span>
<span class="line"><span>    // otherwise do not change anything and return false.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean attemptMark(V expectRef, boolean newMark);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    // if reference == expectRef and mark == expectMark,</span></span>
<span class="line"><span>    // set reference to newRef, mark to newMark and return true;</span></span>
<span class="line"><span>    // otherwise, do not change anything and return false.</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    boolean compareAndSet(V expectRef, V newRef, boolean expectMark, boolean newMark)</span></span>
<span class="line"><span>}</span></span></code></pre>
<p>There are some more implementation details about our nodes, but letâ€™s skip that :).</p>
<pre class="astro-code css-variables" style="background-color:var(--astro-code-background);color:var(--astro-code-foreground); overflow-x: auto;" tabindex="0" data-language="plaintext"><code><span class="line"><span>public boolean remove(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() != item.key() || !curr.valid()) {</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (!curr.setInvalid()) {</span></span>
<span class="line"><span>            continue;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        pred.setNextIfValid(curr, curr.next());</span></span>
<span class="line"><span>        return true;</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // changed during logical removal: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean add(T item) {</span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        Node&#x3C;T> pred, curr = find(head, item.key());</span></span>
<span class="line"><span>        if (curr.key() == item.key() &#x26;&#x26; curr.valid()) {</span></span>
<span class="line"><span>            // already in set and valid</span></span>
<span class="line"><span>            return false;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>        Node&#x3C;T> node = new LockFreeNode&#x3C;>(item).setNext(curr);</span></span>
<span class="line"><span></span></span>
<span class="line"><span>        if (pred.setNextIfValid(curr, node)) {</span></span>
<span class="line"><span>            return true;</span></span>
<span class="line"><span>        }</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>    // pred changed during add: try again!</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>public boolean has(T item) {</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr = super.find(head, item.key());</span></span>
<span class="line"><span>    return curr.valid() &#x26;&#x26; curr.key() == item.key();</span></span>
<span class="line"><span>}</span></span>
<span class="line"><span></span></span>
<span class="line"><span>protected Node&#x3C;T>, Node&#x3C;T> find(Node&#x3C;T> start, int key) {</span></span>
<span class="line"><span>    boolean valid;</span></span>
<span class="line"><span>    Node&#x3C;T> pred, curr, succ;</span></span>
<span class="line"><span></span></span>
<span class="line"><span>    do {</span></span>
<span class="line"><span>        pred = start;</span></span>
<span class="line"><span>        curr = start.next();</span></span>
<span class="line"><span>        do {</span></span>
<span class="line"><span>            succ, valid = curr.nextValid();</span></span>
<span class="line"><span>            while (!valid) {</span></span>
<span class="line"><span>                if (!pred.setNextIfValid(curr, succ)) continue retry;</span></span>
<span class="line"><span>                curr = succ; succ, valid = curr.nextValid();</span></span>
<span class="line"><span>            }</span></span>
<span class="line"><span>        if (curr.key() >= key) return (pred, curr);</span></span>
<span class="line"><span>        pred = curr; curr = succ;</span></span>
<span class="line"><span>        } while (true);</span></span>
<span class="line"><span>    } while (true);</span></span>
<span class="line"><span>}</span></span></code></pre>
<ul>
<li>
<p>Pros:</p>
<ul>
<li>
<p>No operations require locking: maximum potential for parallelism.</p>
</li>
<li>
<p>Membership checking does not require any locking â€“ itâ€™s even wait-free (it traverses
the list once without locking).</p>
</li>
</ul>
</li>
<li>
<p>Cons:</p>
<ul>
<li>
<p>The implementation needs test-and-set-like synchronization primitives, which have to
be supported and come with their own performance costs.</p>
</li>
<li>
<p>Operations add and remove are lock-free but not wait-free: they may have to repeat
operations, and they may be delayed while they physically remove invalid nodes, with
the risk of introducing contention on nodes that have been already previously
logically deleted.</p>
</li>
</ul>
</li>
</ul>
<h3 id="when-to-lock-and-not">When to lock and not</h3>
<p>Each of the different implementations of concurrent set is the best choice for certain
applications and not for others:</p>
<ul>
<li>
<p><code>CoarseSet</code> works well with low contention.</p>
</li>
<li>
<p><code>FineSet</code> works well when threads tend to access the list orderly.</p>
</li>
<li>
<p><code>OptimisticSet</code> works well to let threads operate on disjoint portions of the list.</p>
</li>
<li>
<p><code>LazySet</code> works well when batching invalid node removal is convenient.</p>
</li>
<li>
<p><code>LockFreeSet</code> works well when locking is quite expensive</p>
</li>
</ul> <div class="mt-24"> <div class="grid grid-cols-2 gap-1.5 sm:gap-3"> <a href="/chalmers/tda384/tda384_9" class="group relative flex flex-nowrap rounded-lg border border-black/15 px-4 py-3 pl-10 no-underline transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-5 -translate-y-1/2 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-3 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="flex items-center text-sm"> Part 9 - Parallelizing computations </div> </a> <div class="invisible"></div> </div> </div> <div class="mt-24"> <div class="giscus"></div> <script data-astro-rerun src="https://giscus.app/client.js" data-repo="rezaarezvan/rezvan.xyz" data-repo-id="R_kgDOHvQr3w" data-category="General" data-category-id="DIC_kwDOHvQr384CiWVC" data-mapping="pathname" data-strict="0" data-reactions-enabled="1" data-emit-metadata="0" data-input-position="bottom" data-theme="preferred_color_scheme" data-lang="en" data-loading="lazy" crossorigin="anonymous" async></script> </div> </article> </div>  </main> <footer class="animate"> <div class="mx-auto max-w-screen-sm px-3"> <div class="relative"> <div class="absolute -top-12 right-0"> <button id="back-to-top" class="group relative flex w-fit flex-nowrap rounded border border-black/15 py-1.5 pl-8 pr-3 transition-colors duration-300 ease-in-out hover:bg-black/5 hover:text-black focus-visible:bg-black/5 focus-visible:text-black dark:border-white/20 dark:hover:bg-white/5 dark:hover:text-white dark:focus-visible:bg-white/5 dark:focus-visible:text-white"> <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" class="absolute left-2 top-1/2 size-4 -translate-y-1/2 rotate-90 fill-none stroke-current stroke-2"> <line x1="5" y1="12" x2="19" y2="12" class="translate-x-2 scale-x-0 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-hover:scale-x-100 group-focus-visible:translate-x-0 group-focus-visible:scale-x-100"></line> <polyline points="12 5 5 12 12 19" class="translate-x-1 transition-transform duration-300 ease-in-out group-hover:translate-x-0 group-focus-visible:translate-x-0"></polyline> </svg> <div class="text-sm">Back to top</div> </button> </div> </div> <div class="flex items-center justify-between"> <div>&copy; 2024 â€¢ rezarezvan.com </div> <div class="flex flex-wrap items-center gap-1.5"> <button id="light-theme-button" aria-label="Light theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <circle cx="12" cy="12" r="5"></circle> <line x1="12" y1="1" x2="12" y2="3"></line> <line x1="12" y1="21" x2="12" y2="23"></line> <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line> <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line> <line x1="1" y1="12" x2="3" y2="12"></line> <line x1="21" y1="12" x2="23" y2="12"></line> <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line> <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line> </svg> </button> <button id="dark-theme-button" aria-label="Dark theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path> </svg> </button> <button id="system-theme-button" aria-label="System theme" class="group flex size-9 items-center justify-center rounded border border-black/15 hover:bg-black/5 focus-visible:bg-black/5 dark:border-white/20 dark:hover:bg-white/5 dark:focus-visible:bg-white/5"> <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round" class="transition-colors duration-300 ease-in-out group-hover:animate-pulse group-hover:stroke-black group-focus-visible:animate-pulse group-focus-visible:stroke-black group-hover:dark:stroke-white dark:group-focus-visible:stroke-white"> <rect x="2" y="3" width="20" height="14" rx="2" ry="2"></rect> <line x1="8" y1="21" x2="16" y2="21"></line> <line x1="12" y1="17" x2="12" y2="21"></line> </svg> </button> </div> </div> </div> </footer> <aside data-pagefind-ignore> <div id="backdrop" class="bg-[rgba(0, 0, 0, 0.5] invisible fixed left-0 top-0 z-50 flex h-screen w-full justify-center p-6 backdrop-blur-sm" data-astro-transition-persist="astro-3snakcvo-2"> <div id="pagefind-container" class="m-0 flex h-fit max-h-[80%] w-full max-w-screen-sm flex-col overflow-auto rounded border border-black/15 bg-neutral-100 p-2 px-4 py-3 shadow-lg dark:border-white/20 dark:bg-neutral-900"> <div id="search" class="pagefind-ui pagefind-init" data-pagefind-ui data-bundle-path="/pagefind/" data-ui-options="{&#34;showImages&#34;:false,&#34;excerptLength&#34;:15,&#34;resetStyles&#34;:false}"></div> <script type="module" src="/_astro/Search.astro_astro_type_script_index_0_lang.BoThSDgl.js"></script> <div class="mr-2 pb-1 pt-4 text-right text-xs dark:prose-invert">
Press <span class="prose text-xs dark:prose-invert"><kbd class="">Esc</kbd></span> or click anywhere to close
</div> </div> </div> </aside> <script>
  const magnifyingGlass = document.getElementById("magnifying-glass");
  const backdrop = document.getElementById("backdrop");

  function openPagefind() {
    const searchDiv = document.getElementById("search");
    const search = searchDiv.querySelector("input");
    setTimeout(() => {
      search.focus();
    }, 0);
    backdrop?.classList.remove("invisible");
    backdrop?.classList.add("visible");
  }

  function closePagefind() {
    const search = document.getElementById("search");
    search.value = "";
    backdrop?.classList.remove("visible");
    backdrop?.classList.add("invisible");
  }

  // open pagefind
  magnifyingGlass?.addEventListener("click", () => {
    openPagefind();
  });

  document.addEventListener("keydown", (e) => {
    if (e.key === "/") {
      e.preventDefault();
      openPagefind();
    } else if ((e.metaKey || e.ctrlKey) && e.key === "k") {
      e.preventDefault();
      openPagefind();
    }
  });

  // close pagefind
  document.addEventListener("keydown", (e) => {
    if (e.key === "Escape" || e.keyCode === 27) {
      closePagefind();
    }
  });

  // close pagefind when searched result(link) clicked
  document.addEventListener("click", (event) => {
    if (event.target.classList.contains("pagefind-ui__result-link")) {
      closePagefind();
    }
  });

  backdrop?.addEventListener("click", (event) => {
    if (!event.target.closest("#pagefind-container")) {
      closePagefind();
    }
  });

  // prevent form submission
  const form = document.getElementById("form");
  form?.addEventListener("submit", (event) => {
    event.preventDefault();
  });
</script>  </body></html>